<Type Name="ITextRangeProvider" FullName="System.Windows.Automation.Provider.ITextRangeProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86b3fa97aa346591419b18aa93b7764b7859fb28" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65012472" /></Metadata><TypeSignature Language="C#" Value="public interface ITextRangeProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITextRangeProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.ITextRangeProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface ITextRangeProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class ITextRangeProvider" />
  <TypeSignature Language="F#" Value="type ITextRangeProvider = interface" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.Guid("5347ad7b-c355-46f8-aff5-909033582f63")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e4e7a-101">Expose les méthodes et les propriétés permettant de prendre en charge l’accès du client UI Automation à une étendue de texte continu dans un conteneur de texte qui implémente <see cref="T:System.Windows.Automation.Provider.ITextProvider" />.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-101">Exposes methods and properties to support UI Automation client access to a span of continuous text in a text container that implements <see cref="T:System.Windows.Automation.Provider.ITextProvider" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-102">Implémenté sur un fournisseur UI Automation qui doit prendre en charge la <xref:System.Windows.Automation.TextPattern> modèle de contrôle.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-102">Implemented on a UI Automation provider that must support the <xref:System.Windows.Automation.TextPattern> control pattern.</span></span>  
  
 <span data-ttu-id="e4e7a-103">Un <xref:System.Windows.Automation.Text.TextPatternRange> peut représenter un point d’insertion, un sous-ensemble ou tout le texte dans un <xref:System.Windows.Automation.TextPattern> conteneur.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-103">A <xref:System.Windows.Automation.Text.TextPatternRange> can represent an insertion point, a subset, or all of the text in a <xref:System.Windows.Automation.TextPattern> container.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Text.TextPatternRange" />
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-overview.md"><span data-ttu-id="e4e7a-104">Vue d'ensemble des modèles de contrôle UI Automation</span><span class="sxs-lookup"><span data-stu-id="e4e7a-104">UI Automation Control Patterns Overview</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/6acc6d08-bd67-4e2e-915c-9c1d34eb86fe"><span data-ttu-id="e4e7a-105">Implémentation de fournisseur côté serveur UI Automation</span><span class="sxs-lookup"><span data-stu-id="e4e7a-105">Server-side UI Automation Provider Implementation</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/3584c0a1-9cd0-4968-8b63-b06390890ef6"><span data-ttu-id="e4e7a-106">Implémentation de fournisseur côté client UI Automation</span><span class="sxs-lookup"><span data-stu-id="e4e7a-106">Client-side UI Automation Provider Implementation</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/0d635c35-ffa8-4dc8-bbc9-12fcd5445776"><span data-ttu-id="e4e7a-107">Prendre en charge des modèles de contrôle dans un fournisseur UI Automation</span><span class="sxs-lookup"><span data-stu-id="e4e7a-107">Support Control Patterns in a UI Automation Provider</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/41787927-df1f-4f4a-aba3-641662854fc4"><span data-ttu-id="e4e7a-108">Vue d'ensemble de TextPattern d'UI Automation</span><span class="sxs-lookup"><span data-stu-id="e4e7a-108">UI Automation TextPattern Overview</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberSignature Language="F#" Value="abstract member AddToSelection : unit -&gt; unit" Usage="iTextRangeProvider.AddToSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4e7a-109">Ajoute à la collection de texte mis en surbrillance dans un conteneur de texte qui prend en charge les sélections multiples et disjointes.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-109">Adds to the collection of highlighted text in a text container that supports multiple, disjoint selections.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-110">Le point d’insertion de texte se déplace vers la zone de la nouvelle sélection.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-110">The text insertion point moves to the area of the new selection.</span></span>  
  
 <span data-ttu-id="e4e7a-111">En fournissant une plage de texte dégénérée déplace le point d’insertion.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-111">Providing a degenerate text range moves the insertion point.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e4e7a-112">Si le fournisseur de texte ne prend pas en charge plusieurs sélections disjointes (autrement dit, <see cref="P:System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</span><span class="sxs-lookup"><span data-stu-id="e4e7a-112">If text provider does not support multiple, disjoint selections (that is, <see cref="P:System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection" /> must have a value of <see langword="Multiple" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4e7a-113">Récupère un nouvel élément <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> identique à l'élément <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> d'origine et héritant de toutes les propriétés de l'original.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-113">Returns a new <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> identical to the original <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> and inheriting all properties of the original.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-114">Nouvelle plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-114">The new text range.</span></span> <span data-ttu-id="e4e7a-115">Une référence null (<see langword="Nothing" /> en Visual Basic) n’est jamais retournée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-115">A null reference (<see langword="Nothing" /> in Visual Basic) is never returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-116">La nouvelle plage peut être manipulée indépendamment de l’original.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-116">The new range can be manipulated independently from the original.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Provider.ITextRangeProvider range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Compare(class System.Windows.Automation.Provider.ITextRangeProvider range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Compare(System.Windows.Automation.Provider.ITextRangeProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As ITextRangeProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Provider::ITextRangeProvider ^ range);" />
      <MemberSignature Language="F#" Value="abstract member Compare : System.Windows.Automation.Provider.ITextRangeProvider -&gt; bool" Usage="iTextRangeProvider.Compare range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
      </Parameters>
      <Docs>
        <param name="range"><span data-ttu-id="e4e7a-117">Plage de texte à comparer.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-117">A text range to compare</span></span></param>
        <summary><span data-ttu-id="e4e7a-118">Retourne une valeur qui indique si l'étendue (du point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> au point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />) d'une plage de texte est la même qu'une autre plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-118">Returns a value that indicates whether the span (the <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> endpoint to the <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoint) of a text range is the same as another text range.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-119"><see langword="true" /> si l'étendue des deux plages de texte est identique ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-119"><see langword="true" /> if the span of both text ranges is identical; otherwise <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4e7a-120">Si la plage qui est comparée ne provient pas du même fournisseur de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-120">If the range being compared does not come from the same text provider.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As ITextRangeProvider, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Provider::ITextRangeProvider ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="abstract member CompareEndpoints : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Provider.ITextRangeProvider * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; int" Usage="iTextRangeProvider.CompareEndpoints (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint"><span data-ttu-id="e4e7a-121">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de l'appelant.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-121">The <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> or <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoint of the caller.</span></span></param>
        <param name="targetRange"><span data-ttu-id="e4e7a-122">Plage cible à comparer.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-122">The target range for comparison.</span></span></param>
        <param name="targetEndpoint"><span data-ttu-id="e4e7a-123">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la cible.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-123">The <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> or <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoint of the target.</span></span></param>
        <summary><span data-ttu-id="e4e7a-124">Retourne une valeur qui spécifie si deux plages de texte ont des points de terminaison identiques.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-124">Returns a value that specifies whether two text ranges have identical endpoints.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-125">Retourne une valeur négative si le point de terminaison de l'appelant se situe dans le texte avant le point de terminaison cible.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-125">Returns a negative value if the caller's endpoint occurs earlier in the text than the target endpoint.</span></span>  
  
<span data-ttu-id="e4e7a-126">Retourne zéro si le point de terminaison de l'appelant est au même emplacement que le point de terminaison cible.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-126">Returns zero if the caller's endpoint is at the same location as the target endpoint.</span></span>  
  
<span data-ttu-id="e4e7a-127">Retourne une valeur positive si le point de terminaison de l'appelant se situe dans le texte après le point de terminaison cible.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-127">Returns a positive value if the caller's endpoint occurs later in the text than the target endpoint.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4e7a-128">Si <paramref name="targetRange" /> provient d’un fournisseur de textes différent.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-128">If <paramref name="targetRange" /> is from a different text provider.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberSignature Language="F#" Value="abstract member ExpandToEnclosingUnit : System.Windows.Automation.Text.TextUnit -&gt; unit" Usage="iTextRangeProvider.ExpandToEnclosingUnit unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit"><span data-ttu-id="e4e7a-129">Unité de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-129">The textual unit.</span></span></param>
        <summary><span data-ttu-id="e4e7a-130">Développe la plage de texte jusqu’à l’unité de texte spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-130">Expands the text range to the specified text unit.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-131">Si la plage est déjà une quantité exacte d’unités spécifiées, elle reste inchangée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-131">If the range is already an exact quantity of the specified units then it remains unchanged.</span></span>  
  
 <span data-ttu-id="e4e7a-132">Il existe une série d’étapes impliquées dans les coulisses afin que le <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> méthode à exécuter avec succès.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-132">There is a series of steps are involved behind the scenes in order for the <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> method to execute successfully.</span></span>  
  
1.  <span data-ttu-id="e4e7a-133">La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-133">The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint superfluous.</span></span> <span data-ttu-id="e4e7a-134">Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-134">This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [https://www.microsoft.com/](https://www.microsoft.com/) is embedded in text" where "{" and "}" are the text range endpoints.</span></span>  
  
2.  <span data-ttu-id="e4e7a-135">La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> au début de la limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-135">The resulting range is moved backward in the <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> to the beginning of the requested `unit` boundary.</span></span>  
  
3.  <span data-ttu-id="e4e7a-136">La plage est avancée ou reculée dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> du nombre demandé de limites `unit` .</span><span class="sxs-lookup"><span data-stu-id="e4e7a-136">The range is moved forward or backward in the <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> by the requested number of `unit` boundaries.</span></span>  
  
4.  <span data-ttu-id="e4e7a-137">La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-137">The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint by one requested `unit` boundary.</span></span>  
  
 <span data-ttu-id="e4e7a-138">![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")</span><span class="sxs-lookup"><span data-stu-id="e4e7a-138">![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")</span></span>  
<span data-ttu-id="e4e7a-139">Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()</span><span class="sxs-lookup"><span data-stu-id="e4e7a-139">Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e4e7a-140">Ces étapes sont nécessaires dans la mesure où il est courant pour un lecteur d’écran lire un mot complet, une phrase ou un paragraphe entier au point d’insertion ou de n’importe quelle position de curseur virtuel.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-140">These steps are necessary since it is common for a screen reader to read out a full word, sentence, or entire paragraph at the insertion point or any virtual cursor position.</span></span>  
  
 <span data-ttu-id="e4e7a-141"><xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-141"><xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> respects both hidden and visible text.</span></span>  
  
 <span data-ttu-id="e4e7a-142"><xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-142"><xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.</span></span>  
  
 <span data-ttu-id="e4e7a-143">L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-143">The order, from smallest unit to largest, is listed below.</span></span>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindAttribute (int attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindAttribute(int32 attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindAttribute(System.Int32,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As Integer, value As Object, backward As Boolean) As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ FindAttribute(int attribute, System::Object ^ value, bool backward);" />
      <MemberSignature Language="F#" Value="abstract member FindAttribute : int * obj * bool -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.FindAttribute (attribute, value, backward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute"><span data-ttu-id="e4e7a-144">Attribut à rechercher.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-144">The attribute to search for.</span></span></param>
        <param name="value"><span data-ttu-id="e4e7a-145">Valeur d'attribut à rechercher.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-145">The attribute value to search for.</span></span> <span data-ttu-id="e4e7a-146">Cette valeur doit correspondre au type spécifié pour l'attribut.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-146">This value must match the type specified for the attribute.</span></span></param>
        <param name="backward"><span data-ttu-id="e4e7a-147"><see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-147"><see langword="true" /> if the last occurring text range should be returned instead of the first; otherwise <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e4e7a-148">Retourne un sous-ensemble de la plage de texte qui a la valeur d'attribut spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-148">Returns a text range subset that has the specified attribute value.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-149">Plage de texte dont l’attribut et la valeur d’attribut correspondent ; sinon, null (<see langword="Nothing" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e4e7a-149">A text range having a matching attribute and attribute value; otherwise null (<see langword="Nothing" /> in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-150">Il n’existe aucune distinction entre du texte masqué et visible.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-150">There is no differentiation between hidden and visible text.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member FindText : string * bool * bool -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.FindText (text, backward, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="e4e7a-151">Chaîne de texte à rechercher.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-151">The text string to search for.</span></span></param>
        <param name="backward"><span data-ttu-id="e4e7a-152"><see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-152"><see langword="true" /> if the last occurring text range should be returned instead of the first; otherwise <see langword="false" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="e4e7a-153"><see langword="true" /> si la casse doit être ignorée ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-153"><see langword="true" /> if case should be ignored; otherwise <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e4e7a-154">Retourne un sous-ensemble de la plage de texte qui contient le texte spécifié.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-154">Returns a text range subset that contains the specified text.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-155">Plage de texte correspondant au texte spécifié ; sinon, null (<see langword="Nothing" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e4e7a-155">A text range matching the specified text; otherwise null (<see langword="Nothing" /> in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-156">Il n’existe aucune distinction entre du texte masqué et visible.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-156">There is no differentiation between hidden and visible text.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (int attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAttributeValue(int32 attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetAttributeValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(int attribute);" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeValue : int -&gt; obj" Usage="iTextRangeProvider.GetAttributeValue attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attribute"><span data-ttu-id="e4e7a-157">Attribut de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-157">The text attribute.</span></span></param>
        <summary><span data-ttu-id="e4e7a-158">Récupère la valeur de l'attribut spécifié sur la totalité de la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-158">Retrieves the value of the specified attribute across the text range.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-159">Récupère un objet qui représente la valeur de l'attribut spécifié.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-159">Retrieves an object representing the value of the specified attribute.</span></span> <span data-ttu-id="e4e7a-160">Par exemple, <c>GetAttributeValue(TextPattern.FontNameAttribute)</c> retourne une chaîne qui représente le nom de la police de la plage de texte, tandis que <c>GetAttributeValue(TextPattern.IsItalicAttribute)</c> retourne une valeur de type <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-160">For example, <c>GetAttributeValue(TextPattern.FontNameAttribute)</c> would return a string that represents the font name of the text range while <c>GetAttributeValue(TextPattern.IsItalicAttribute)</c> would return a value of type <see cref="T:System.Boolean" />.</span></span>  
  
<span data-ttu-id="e4e7a-161">Retourne <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> si la valeur de l'attribut spécifié varie sur la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-161">Returns <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> if the value of the specified attribute varies over the text range.</span></span>  
  
<span data-ttu-id="e4e7a-162">Retourne <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> si l'attribut spécifié n'est pas pris en charge par le fournisseur ou par le contrôle.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-162">Returns <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> if the specified attribute is not supported by the provider or the control.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-163">Il n’existe aucune distinction entre du texte masqué et visible.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-163">There is no differentiation between hidden and visible text.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4e7a-164">Si l’attribut spécifié n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-164">If the specified attribute is not valid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public double[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ GetBoundingRectangles();" />
      <MemberSignature Language="F#" Value="abstract member GetBoundingRectangles : unit -&gt; double[]" Usage="iTextRangeProvider.GetBoundingRectangles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4e7a-165">Récupère une collection de rectangles englobants pour chaque ligne de texte complètement ou partiellement visible dans une plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-165">Retrieves a collection of bounding rectangles for each fully or partially visible line of text in a text range.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-166">Tableau de rectangles englobants pour chaque ligne de texte complète ou partielle dans une plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-166">An array of bounding rectangles for each full or partial line of text in a text range.</span></span>  
  
<span data-ttu-id="e4e7a-167">Tableau vide pour une plage dégénérée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-167">An empty array for a degenerate range.</span></span>  
  
<span data-ttu-id="e4e7a-168">Tableau vide pour une plage de texte qui a des coordonnées d'écran qui la placent complètement hors écran, qui la font défiler en dehors de l'affichage ou qui la masquent par une fenêtre superposée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-168">An empty array for a text range that has screen coordinates placing it completely off-screen, scrolled out of view, or obscured by an overlapping window.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As IRawElementProviderSimple()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::Provider::IRawElementProviderSimple ^&gt; ^ GetChildren();" />
      <MemberSignature Language="F#" Value="abstract member GetChildren : unit -&gt; System.Windows.Automation.Provider.IRawElementProviderSimple[]" Usage="iTextRangeProvider.GetChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4e7a-169">Récupère une collection de tous les objets incorporés qui se trouvent dans la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-169">Retrieves a collection of all embedded objects that fall within the text range.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-170">Une collection de tous les objets enfants qui se trouvent dans la plage.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-170">A collection of child objects that fall within the range.</span></span> <span data-ttu-id="e4e7a-171">Les enfants superposés à la plage de texte mais qui ne sont pas entièrement contenus dans la plage seront également inclus dans la collection.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-171">Children that overlap with the text range but are not entirely enclosed by it will also be included in the collection.</span></span>  
  
<span data-ttu-id="e4e7a-172">Retourne une collection vide s'il n'y a pas d'objets enfants.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-172">Returns an empty collection if there are no child objects.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As IRawElementProviderSimple" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::IRawElementProviderSimple ^ GetEnclosingElement();" />
      <MemberSignature Language="F#" Value="abstract member GetEnclosingElement : unit -&gt; System.Windows.Automation.Provider.IRawElementProviderSimple" Usage="iTextRangeProvider.GetEnclosingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4e7a-173">Retourne le contrôle le plus profond qui encadre la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-173">Returns the innermost control that encloses the text range.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-174">Contrôle englobant, en général le fournisseur de texte qui fournit la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-174">The enclosing control, typically the text provider that supplies the text range.</span></span> <span data-ttu-id="e4e7a-175">Cependant, si le fournisseur de texte prend en charge des éléments enfants comme des tables ou des liens hypertexte, l'élément englobant peut être un descendant du fournisseur de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-175">However, if the text provider supports child elements such as tables or hyperlinks, then the enclosing element could be a descendant of the text provider.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberSignature Language="F#" Value="abstract member GetText : int -&gt; string" Usage="iTextRangeProvider.GetText maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength"><span data-ttu-id="e4e7a-176">Longueur maximale de la chaîne à retourner.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-176">The maximum length of the string to return.</span></span> <span data-ttu-id="e4e7a-177">Utilisez <c>-1</c> si aucune limite n'est exigée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-177">Use <c>-1</c> if no limit is required.</span></span></param>
        <summary><span data-ttu-id="e4e7a-178">Récupère le texte brut de la plage.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-178">Retrieves the plain text of the range.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-179">Texte brut de la plage de texte, éventuellement tronqué à la longueur <paramref name="maxLength" /> spécifiée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-179">The plain text of the text range, possibly truncated at the specified <paramref name="maxLength" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-180"><xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-180"><xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> respects both hidden and visible text.</span></span>  
  
 <span data-ttu-id="e4e7a-181">Si `maxLength` est supérieur à la longueur de l’étendue de texte de l’appelant, la chaîne retournée sera le texte brut de la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-181">If `maxLength` is greater than the length of the text span of the caller, the string returned will be the plain text of the text range.</span></span>  
  
 <span data-ttu-id="e4e7a-182"><xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> ne seront pas affectées par l’ordre des points de terminaison dans le flux de texte ; elle retourne toujours le texte entre les points de terminaison de début et de fin de la plage de texte dans l’ordre de flux de texte logique.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-182"><xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> will not be affected by the order of endpoints in the text flow; it will always return the text between the Start and End endpoints of the text range in the logical text flow order.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e4e7a-183">Si <paramref name="maxLength" /> est inférieur à -1.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-183">If <paramref name="maxLength" /> is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="abstract member Move : System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="iTextRangeProvider.Move (unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit"><span data-ttu-id="e4e7a-184">Limite d'unité de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-184">The text unit boundary.</span></span></param>
        <param name="count"><span data-ttu-id="e4e7a-185">Nombre d'unités de texte à déplacer.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-185">The number of text units to move.</span></span>  
  
<span data-ttu-id="e4e7a-186">Une valeur positive déplace la plage de texte vers l'avant, une valeur négative déplace la plage de texte vers l'arrière. 0 n'a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-186">A positive value moves the text range forward, a negative value moves the text range backward, and 0 has no effect.</span></span></param>
        <summary><span data-ttu-id="e4e7a-187">Déplace la plage de texte du nombre spécifié d'unités de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-187">Moves the text range the specified number of text units.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-188">Nombre d'unités réellement déplacées.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-188">The number of units actually moved.</span></span> <span data-ttu-id="e4e7a-189">Ce peut être moins que le nombre requis si l'un ou l'autre des nouveaux points de terminaison de plage de texte est supérieur ou inférieur aux points de terminaison de <see cref="P:System.Windows.Automation.Provider.ITextProvider.DocumentRange" />.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-189">This can be less than the number requested if either of the new text range endpoints is greater than or less than the <see cref="P:System.Windows.Automation.Provider.ITextProvider.DocumentRange" /> endpoints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-190">Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> .</span><span class="sxs-lookup"><span data-stu-id="e4e7a-190">When it is necessary to traverse the content of a text range, a series of steps are involved behind the scenes in order for the <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> method to execute successfully.</span></span>  
  
1.  <span data-ttu-id="e4e7a-191">La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-191">The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint superfluous.</span></span> <span data-ttu-id="e4e7a-192">Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-192">This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [https://www.microsoft.com/](https://www.microsoft.com/) is embedded in text" where "{" and "}" are the text range endpoints.</span></span>  
  
2.  <span data-ttu-id="e4e7a-193">La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> au début de la limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-193">The resulting range is moved backward in the <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> to the beginning of the requested `unit` boundary.</span></span>  
  
3.  <span data-ttu-id="e4e7a-194">La plage est avancée ou reculée dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> du nombre demandé de limites `unit` .</span><span class="sxs-lookup"><span data-stu-id="e4e7a-194">The range is moved forward or backward in the <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> by the requested number of `unit` boundaries.</span></span>  
  
4.  <span data-ttu-id="e4e7a-195">La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-195">The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint by one requested `unit` boundary.</span></span>  
  
 <span data-ttu-id="e4e7a-196">![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")</span><span class="sxs-lookup"><span data-stu-id="e4e7a-196">![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")</span></span>  
<span data-ttu-id="e4e7a-197">Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()</span><span class="sxs-lookup"><span data-stu-id="e4e7a-197">Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()</span></span>  
  
 <span data-ttu-id="e4e7a-198">Le contenu textuel (ou texte interne) d'un conteneur de texte et d'un objet incorporé, tel qu'un lien hypertexte ou une cellule de tableau, est exposé en tant que flux de texte unique et continu dans l'affichage de contrôle et l'affichage du contenu de l'arborescence [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] ; le contour des objets est ignoré.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-198">The textual content (or inner text) of a text container and an embedded object, such as a hyperlink or table cell, is exposed as a single, continuous text stream in both the control view and the content view of the [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] tree; object boundaries are ignored.</span></span>  
  
 <span data-ttu-id="e4e7a-199">![Plages de texte sur lesquelles s’étend des objets incorporés. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Les plages de texte sur lesquelles s’étend des objets incorporés.")</span><span class="sxs-lookup"><span data-stu-id="e4e7a-199">![Text ranges spanned by embedded objects.](~/add/media/uia-textpattern-embeddedobjecttextranges.png "Text ranges spanned by embedded objects.")</span></span>  
<span data-ttu-id="e4e7a-200">Exemple de flux de texte avec des objets incorporés et leurs amplitudes</span><span class="sxs-lookup"><span data-stu-id="e4e7a-200">Example of a text stream with embedded objects and their range spans</span></span>  
  
 <span data-ttu-id="e4e7a-201"><xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-201"><xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> respects both hidden and visible text.</span></span>  
  
 <span data-ttu-id="e4e7a-202"><xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-202"><xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.</span></span>  
  
 <span data-ttu-id="e4e7a-203">L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-203">The order, from smallest unit to largest, is listed below.</span></span>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 <span data-ttu-id="e4e7a-204">Le texte n’est pas modifié de quelque façon, la plage de texte couvre juste une autre partie du texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-204">The text is not altered in any way, the text range just spans a different part of the text.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As ITextRangeProvider, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Provider::ITextRangeProvider ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="abstract member MoveEndpointByRange : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Provider.ITextRangeProvider * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; unit" Usage="iTextRangeProvider.MoveEndpointByRange (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint"><span data-ttu-id="e4e7a-205">Point de terminaison à déplacer.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-205">The endpoint to move.</span></span></param>
        <param name="targetRange"><span data-ttu-id="e4e7a-206">Une autre plage du même fournisseur de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-206">Another range from the same text provider.</span></span></param>
        <param name="targetEndpoint"><span data-ttu-id="e4e7a-207">Point de terminaison sur l'autre plage.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-207">An endpoint on the other range.</span></span></param>
        <summary><span data-ttu-id="e4e7a-208">Déplace un point de terminaison d'une plage de texte au point de terminaison spécifié d'une deuxième plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-208">Moves one endpoint of a text range to the specified endpoint of a second text range.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-209">Si le point de terminaison en cours de déplacement traverse l’autre point de terminaison de la même plage de texte, cette autre point de terminaison est également déplacé, provoquant une plage dégénérée et assurant le classement correct des points de terminaison (autrement dit, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> est toujours inférieure ou égale à <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).</span><span class="sxs-lookup"><span data-stu-id="e4e7a-209">If the endpoint being moved crosses the other endpoint of the same text range then that other endpoint is moved also, resulting in a degenerate range and ensuring the correct ordering of the endpoints (that is, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> is always less than or equal to <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="abstract member MoveEndpointByUnit : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="iTextRangeProvider.MoveEndpointByUnit (endpoint, unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint"><span data-ttu-id="e4e7a-210">Point de terminaison à déplacer.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-210">The endpoint to move.</span></span></param>
        <param name="unit"><span data-ttu-id="e4e7a-211">Unité de texte à déplacer.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-211">The textual unit for moving.</span></span></param>
        <param name="count"><span data-ttu-id="e4e7a-212">Nombre d'unités à déplacer.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-212">The number of units to move.</span></span> <span data-ttu-id="e4e7a-213">Une valeur positive déplace le point de terminaison vers l'avant.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-213">A positive value moves the endpoint forward.</span></span> <span data-ttu-id="e4e7a-214">Une valeur négative le déplace vers l'arrière.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-214">A negative value moves backward.</span></span> <span data-ttu-id="e4e7a-215">Une valeur de 0 n'a pas d'effet.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-215">A value of 0 has no effect.</span></span></param>
        <summary><span data-ttu-id="e4e7a-216">Déplace un point de terminaison de la plage de texte du nombre spécifié d'unités de texte dans la plage de documents.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-216">Moves one endpoint of the text range the specified number of text units within the document range.</span></span></summary>
        <returns><span data-ttu-id="e4e7a-217">Nombre d'unités réellement déplacées, qui peut être inférieur au nombre requis si le déplacement des points de terminaison atteint le début ou la fin du document.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-217">The number of units actually moved, which can be less than the number requested if moving the endpoint runs into the beginning or end of the document.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-218">Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> .</span><span class="sxs-lookup"><span data-stu-id="e4e7a-218">When it is necessary to traverse the content of a text range, a series of steps are involved behind the scenes in order for the <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> method to execute successfully.</span></span>  
  
1.  <span data-ttu-id="e4e7a-219">La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-219">The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint superfluous.</span></span> <span data-ttu-id="e4e7a-220">Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-220">This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [https://www.microsoft.com/](https://www.microsoft.com/) is embedded in text" where "{" and "}" are the text range endpoints.</span></span>  
  
2.  <span data-ttu-id="e4e7a-221">La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> au début de la limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-221">The resulting range is moved backward in the <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> to the beginning of the requested `unit` boundary.</span></span>  
  
3.  <span data-ttu-id="e4e7a-222">La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-222">The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint by one requested `unit` boundary.</span></span>  
  
 <span data-ttu-id="e4e7a-223">![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")</span><span class="sxs-lookup"><span data-stu-id="e4e7a-223">![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")</span></span>  
<span data-ttu-id="e4e7a-224">Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()</span><span class="sxs-lookup"><span data-stu-id="e4e7a-224">Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()</span></span>  
  
 <span data-ttu-id="e4e7a-225"><xref:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-225"><xref:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit%2A> defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.</span></span>  
  
 <span data-ttu-id="e4e7a-226">L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-226">The order, from smallest unit to largest, is listed below.</span></span>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberSignature Language="F#" Value="abstract member RemoveFromSelection : unit -&gt; unit" Usage="iTextRangeProvider.RemoveFromSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4e7a-227">Supprime une section de texte en surbrillance, correspondant aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de l’appelant, de la collection de textes mis en surbrillance dans un conteneur de texte qui prend en charge des sélections multiples et disjointes.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-227">Removes a highlighted section of text, corresponding to the caller's <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> and <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoints, from the collection of highlighted text in a text container that supports multiple, disjoint selections.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-228">Le point d’insertion de texte se déplacera vers la zone de la mise en surbrillance supprimé.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-228">The text insertion point will move to the area of the removed highlight.</span></span>  
  
 <span data-ttu-id="e4e7a-229">En fournissant une plage de texte dégénérée déplacera le point d’insertion.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-229">Providing a degenerate text range will move the insertion point.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e4e7a-230">Si le fournisseur de texte ne prend pas en charge plusieurs sélections disjointes (par exemple, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</span><span class="sxs-lookup"><span data-stu-id="e4e7a-230">If text provider does not support multiple, disjoint selections (for example, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> must have a value of <see langword="Multiple" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberSignature Language="F#" Value="abstract member ScrollIntoView : bool -&gt; unit" Usage="iTextRangeProvider.ScrollIntoView alignToTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop"><span data-ttu-id="e4e7a-231"><see langword="true" /> si le contrôle de texte doit défiler de façon à ce que la plage de texte soit au même niveau que le haut de la fenêtre d'affichage ; <see langword="false" /> si elle doit être au même niveau que le bas de la fenêtre d'affichage.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-231"><see langword="true" /> if the text control should be scrolled so the text range is flush with the top of the viewport; <see langword="false" /> if it should be flush with the bottom of the viewport.</span></span></param>
        <summary><span data-ttu-id="e4e7a-232">Provoque le défilement vertical du contrôle de texte jusqu'à ce que la plage de texte soit visible dans la fenêtre d'affichage.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-232">Causes the text control to scroll vertically until the text range is visible in the viewport.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-233"><xref:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-233"><xref:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView%2A> respects both hidden and visible text.</span></span>  
  
 <span data-ttu-id="e4e7a-234">Si la plage de texte est masquée, le contrôle de texte défile uniquement si le texte masqué a une ancre dans la fenêtre d’affichage.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-234">If the text range is hidden, the text control will scroll only if the hidden text has an anchor in the viewport.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="abstract member Select : unit -&gt; unit" Usage="iTextRangeProvider.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4e7a-235">Met en surbrillance le texte dans le contrôle de texte qui correspond aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-235">Highlights text in the text control corresponding to the text range <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> and <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoints.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4e7a-236">Si une plage de texte dégénérée est fournie, le point d’insertion de texte se déplace à la <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> point de terminaison de la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-236">If a degenerate text range is provided, the text insertion point will move to the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint of the text range.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e4e7a-237">Se produit lorsque la sélection de texte n’est pas prise en charge par le contrôle de texte.</span><span class="sxs-lookup"><span data-stu-id="e4e7a-237">Occurs when text selection is not supported by the text control.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>