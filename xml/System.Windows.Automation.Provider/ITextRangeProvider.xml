<Type Name="ITextRangeProvider" FullName="System.Windows.Automation.Provider.ITextRangeProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0b2cec9c21bf5d5fd39998eb38715ed0b2540f55" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51904476" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ITextRangeProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITextRangeProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.ITextRangeProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface ITextRangeProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class ITextRangeProvider" />
  <TypeSignature Language="F#" Value="type ITextRangeProvider = interface" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.Guid("5347ad7b-c355-46f8-aff5-909033582f63")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expose les méthodes et les propriétés permettant de prendre en charge l’accès du client UI Automation à une étendue de texte continu dans un conteneur de texte qui implémente <see cref="T:System.Windows.Automation.Provider.ITextProvider" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémenté sur un fournisseur UI Automation qui doit prendre en charge la <xref:System.Windows.Automation.TextPattern> modèle de contrôle.  
  
 Un <xref:System.Windows.Automation.Text.TextPatternRange> peut représenter un point d’insertion, un sous-ensemble ou tout le texte dans un <xref:System.Windows.Automation.TextPattern> conteneur.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Text.TextPatternRange" />
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-overview.md">Vue d’ensemble des modèles de contrôle UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/6acc6d08-bd67-4e2e-915c-9c1d34eb86fe">Implémentation de fournisseur côté serveur UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/3584c0a1-9cd0-4968-8b63-b06390890ef6">Implémentation de fournisseur côté client UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/0d635c35-ffa8-4dc8-bbc9-12fcd5445776">Prendre en charge des modèles de contrôle dans un fournisseur UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/41787927-df1f-4f4a-aba3-641662854fc4">Vue d'ensemble de TextPattern d'UI Automation</related>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberSignature Language="F#" Value="abstract member AddToSelection : unit -&gt; unit" Usage="iTextRangeProvider.AddToSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ajoute à la collection de texte mis en surbrillance dans un conteneur de texte qui prend en charge les sélections multiples et disjointes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le point d’insertion de texte se déplace vers la zone de la nouvelle sélection.  
  
 En fournissant une plage de texte dégénérée déplace le point d’insertion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si le fournisseur de texte ne prend pas en charge les sélections multiples disjointes (par exemple, <see cref="P:System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère un nouvel élément <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> identique à l'élément <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> d'origine et héritant de toutes les propriétés de l'original.</summary>
        <returns>Nouvelle plage de texte. Une référence null (<see langword="Nothing" /> en Visual Basic) n’est jamais retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La nouvelle plage peut être manipulée indépendamment de l’original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Provider.ITextRangeProvider range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Compare(class System.Windows.Automation.Provider.ITextRangeProvider range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Compare(System.Windows.Automation.Provider.ITextRangeProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As ITextRangeProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Provider::ITextRangeProvider ^ range);" />
      <MemberSignature Language="F#" Value="abstract member Compare : System.Windows.Automation.Provider.ITextRangeProvider -&gt; bool" Usage="iTextRangeProvider.Compare range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
      </Parameters>
      <Docs>
        <param name="range">Plage de texte à comparer.</param>
        <summary>Retourne une valeur qui indique si l'étendue (du point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> au point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />) d'une plage de texte est la même qu'une autre plage de texte.</summary>
        <returns>
          <see langword="true" /> si l'étendue des deux plages de texte est identique ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Si la plage qui est comparée ne vient pas du même fournisseur de textes.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As ITextRangeProvider, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Provider::ITextRangeProvider ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="abstract member CompareEndpoints : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Provider.ITextRangeProvider * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; int" Usage="iTextRangeProvider.CompareEndpoints (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de l'appelant.</param>
        <param name="targetRange">Plage cible à comparer.</param>
        <param name="targetEndpoint">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la cible.</param>
        <summary>Retourne une valeur qui spécifie si deux plages de texte ont des points de terminaison identiques.</summary>
        <returns>Retourne une valeur négative si le point de terminaison de l'appelant se situe dans le texte avant le point de terminaison cible.  
  
Retourne zéro si le point de terminaison de l'appelant est au même emplacement que le point de terminaison cible.  
  
Retourne une valeur positive si le point de terminaison de l'appelant se situe dans le texte après le point de terminaison cible.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="targetRange" /> est d'un fournisseur de textes différent.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberSignature Language="F#" Value="abstract member ExpandToEnclosingUnit : System.Windows.Automation.Text.TextUnit -&gt; unit" Usage="iTextRangeProvider.ExpandToEnclosingUnit unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Unité de texte.</param>
        <summary>Développe la plage de texte jusqu’à l’unité de texte spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la plage est déjà une quantité exacte d’unités spécifiées, elle reste inchangée.  
  
 Il existe une série d’étapes impliquées dans les coulisses afin que le <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> méthode à exécuter avec succès.  
  
1.  La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu. Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.  
  
2.  La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> au début de la limite `unit` demandée.  
  
3.  La plage est avancée ou reculée dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> du nombre demandé de limites `unit`.  
  
4.  La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.  
  
 ![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")  
Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()  
  
> [!NOTE]
>  Ces étapes sont nécessaires dans la mesure où il est courant pour un lecteur d’écran lire un mot complet, une phrase ou un paragraphe entier au point d’insertion ou de n’importe quelle position de curseur virtuel.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> respecte le texte à la fois visible et masqué.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.  
  
 L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindAttribute (int attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindAttribute(int32 attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindAttribute(System.Int32,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As Integer, value As Object, backward As Boolean) As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ FindAttribute(int attribute, System::Object ^ value, bool backward);" />
      <MemberSignature Language="F#" Value="abstract member FindAttribute : int * obj * bool -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.FindAttribute (attribute, value, backward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">Attribut à rechercher.</param>
        <param name="value">Valeur d'attribut à rechercher. Cette valeur doit correspondre au type spécifié pour l'attribut.</param>
        <param name="backward">
          <see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</param>
        <summary>Retourne un sous-ensemble de la plage de texte qui a la valeur d'attribut spécifiée.</summary>
        <returns>Plage de texte dont l’attribut et la valeur d’attribut correspondent ; sinon, null (<see langword="Nothing" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’existe aucune distinction entre du texte masqué et visible.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member FindText : string * bool * bool -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.FindText (text, backward, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">Chaîne de texte à rechercher.</param>
        <param name="backward">
          <see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> si la casse doit être ignorée ; sinon, <see langword="false" />.</param>
        <summary>Retourne un sous-ensemble de la plage de texte qui contient le texte spécifié.</summary>
        <returns>Plage de texte correspondant au texte spécifié ; sinon, null (<see langword="Nothing" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’existe aucune distinction entre du texte masqué et visible.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (int attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAttributeValue(int32 attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetAttributeValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(int attribute);" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeValue : int -&gt; obj" Usage="iTextRangeProvider.GetAttributeValue attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attribute">Attribut de texte.</param>
        <summary>Récupère la valeur de l'attribut spécifié sur la totalité de la plage de texte.</summary>
        <returns>Récupère un objet qui représente la valeur de l'attribut spécifié. Par exemple, <c>GetAttributeValue(TextPattern.FontNameAttribute)</c> retourne une chaîne qui représente le nom de la police de la plage de texte, tandis que <c>GetAttributeValue(TextPattern.IsItalicAttribute)</c> retourne une valeur de type <see cref="T:System.Boolean" />.  
  
Retourne <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> si la valeur de l'attribut spécifié varie sur la plage de texte.  
  
Retourne <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> si l'attribut spécifié n'est pas pris en charge par le fournisseur ou par le contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’existe aucune distinction entre du texte masqué et visible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si l’attribut spécifié n’est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public double[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ GetBoundingRectangles();" />
      <MemberSignature Language="F#" Value="abstract member GetBoundingRectangles : unit -&gt; double[]" Usage="iTextRangeProvider.GetBoundingRectangles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection de rectangles englobants pour chaque ligne de texte complètement ou partiellement visible dans une plage de texte.</summary>
        <returns>Tableau de rectangles englobants pour chaque ligne de texte complète ou partielle dans une plage de texte.  
  
Tableau vide pour une plage dégénérée.  
  
Tableau vide pour une plage de texte qui a des coordonnées d'écran qui la placent complètement hors écran, qui la font défiler en dehors de l'affichage ou qui la masquent par une fenêtre superposée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As IRawElementProviderSimple()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::Provider::IRawElementProviderSimple ^&gt; ^ GetChildren();" />
      <MemberSignature Language="F#" Value="abstract member GetChildren : unit -&gt; System.Windows.Automation.Provider.IRawElementProviderSimple[]" Usage="iTextRangeProvider.GetChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection de tous les objets incorporés qui se trouvent dans la plage de texte.</summary>
        <returns>Une collection de tous les objets enfants qui se trouvent dans la plage. Les enfants superposés à la plage de texte mais qui ne sont pas entièrement contenus dans la plage seront également inclus dans la collection.  
  
Retourne une collection vide s’il n’y a pas d’objets enfants.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As IRawElementProviderSimple" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::IRawElementProviderSimple ^ GetEnclosingElement();" />
      <MemberSignature Language="F#" Value="abstract member GetEnclosingElement : unit -&gt; System.Windows.Automation.Provider.IRawElementProviderSimple" Usage="iTextRangeProvider.GetEnclosingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le contrôle le plus profond qui encadre la plage de texte.</summary>
        <returns>Contrôle englobant, en général le fournisseur de texte qui fournit la plage de texte. Cependant, si le fournisseur de texte prend en charge des éléments enfants comme des tables ou des liens hypertexte, l'élément englobant peut être un descendant du fournisseur de texte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberSignature Language="F#" Value="abstract member GetText : int -&gt; string" Usage="iTextRangeProvider.GetText maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">Longueur maximale de la chaîne à retourner. Utilisez <c>-1</c> si aucune limite n'est exigée.</param>
        <summary>Récupère le texte brut de la plage.</summary>
        <returns>Texte brut de la plage de texte, éventuellement tronqué à la longueur <paramref name="maxLength" /> spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> respecte le texte à la fois visible et masqué.  
  
 Si `maxLength` est supérieur à la longueur de l’étendue de texte de l’appelant, la chaîne retournée sera le texte brut de la plage de texte.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> ne seront pas affectées par l’ordre des points de terminaison dans le flux de texte ; elle retourne toujours le texte entre les points de terminaison de début et de fin de la plage de texte dans l’ordre de flux de texte logique.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si <paramref name="maxLength" /> est inférieur à -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="abstract member Move : System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="iTextRangeProvider.Move (unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">Limite d'unité de texte.</param>
        <param name="count">Nombre d'unités de texte à déplacer.  
  
Une valeur positive déplace la plage de texte vers l'avant, une valeur négative déplace la plage de texte vers l'arrière. 0 n'a aucun effet.</param>
        <summary>Déplace la plage de texte du nombre spécifié d'unités de texte.</summary>
        <returns>Nombre d'unités réellement déplacées. Ce peut être moins que le nombre requis si l'un ou l'autre des nouveaux points de terminaison de plage de texte est supérieur ou inférieur aux points de terminaison de <see cref="P:System.Windows.Automation.Provider.ITextProvider.DocumentRange" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> .  
  
1.  La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu. Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.  
  
2.  La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> au début de la limite `unit` demandée.  
  
3.  La plage est avancée ou reculée dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> du nombre demandé de limites `unit`.  
  
4.  La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.  
  
 ![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")  
Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()  
  
 Le contenu textuel (ou texte interne) d'un conteneur de texte et d'un objet incorporé, tel qu'un lien hypertexte ou une cellule de tableau, est exposé en tant que flux de texte unique et continu dans l'affichage de contrôle et l'affichage du contenu de l'arborescence [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] ; le contour des objets est ignoré.  
  
 ![Plages de texte sur lesquelles s’étend des objets incorporés. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Les plages de texte sur lesquelles s’étend des objets incorporés.")  
Exemple de flux de texte avec des objets incorporés et leurs amplitudes  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> respecte le texte à la fois visible et masqué.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.  
  
 L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 Le texte n’est pas modifié de quelque façon, la plage de texte couvre juste une autre partie du texte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As ITextRangeProvider, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Provider::ITextRangeProvider ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="abstract member MoveEndpointByRange : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Provider.ITextRangeProvider * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; unit" Usage="iTextRangeProvider.MoveEndpointByRange (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Point de terminaison à déplacer.</param>
        <param name="targetRange">Une autre plage du même fournisseur de texte.</param>
        <param name="targetEndpoint">Point de terminaison sur l'autre plage.</param>
        <summary>Déplace un point de terminaison d'une plage de texte au point de terminaison spécifié d'une deuxième plage de texte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le point de terminaison en cours de déplacement traverse l’autre point de terminaison de la même plage de texte, cette autre point de terminaison est également déplacé, provoquant une plage dégénérée et assurant le classement correct des points de terminaison (autrement dit, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> est toujours inférieure ou égale à <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="abstract member MoveEndpointByUnit : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="iTextRangeProvider.MoveEndpointByUnit (endpoint, unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">Point de terminaison à déplacer.</param>
        <param name="unit">Unité de texte à déplacer.</param>
        <param name="count">Nombre d'unités à déplacer. Une valeur positive déplace le point de terminaison vers l'avant. Une valeur négative le déplace vers l'arrière. Une valeur de 0 n'a pas d'effet.</param>
        <summary>Déplace un point de terminaison de la plage de texte du nombre spécifié d'unités de texte dans la plage de documents.</summary>
        <returns>Nombre d'unités réellement déplacées, qui peut être inférieur au nombre requis si le déplacement des points de terminaison atteint le début ou la fin du document.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> .  
  
1.  La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu. Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.  
  
2.  La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> au début de la limite `unit` demandée.  
  
3.  La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.  
  
 ![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")  
Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.  
  
 L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberSignature Language="F#" Value="abstract member RemoveFromSelection : unit -&gt; unit" Usage="iTextRangeProvider.RemoveFromSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime une section de texte en surbrillance, correspondant aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de l’appelant, de la collection de textes mis en surbrillance dans un conteneur de texte qui prend en charge des sélections multiples et disjointes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le point d’insertion de texte se déplacera vers la zone de la mise en surbrillance supprimé.  
  
 En fournissant une plage de texte dégénérée déplacera le point d’insertion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si le fournisseur de texte ne prend pas en charge les sélections multiples disjointes (par exemple, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberSignature Language="F#" Value="abstract member ScrollIntoView : bool -&gt; unit" Usage="iTextRangeProvider.ScrollIntoView alignToTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" /> si le contrôle de texte doit défiler de façon à ce que la plage de texte soit au même niveau que le haut de la fenêtre d'affichage ; <see langword="false" /> si elle doit être au même niveau que le bas de la fenêtre d'affichage.</param>
        <summary>Provoque le défilement vertical du contrôle de texte jusqu'à ce que la plage de texte soit visible dans la fenêtre d'affichage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView%2A> respecte le texte à la fois visible et masqué.  
  
 Si la plage de texte est masquée, le contrôle de texte défile uniquement si le texte masqué a une ancre dans la fenêtre d’affichage.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="abstract member Select : unit -&gt; unit" Usage="iTextRangeProvider.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met en surbrillance le texte dans le contrôle de texte qui correspond aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la plage de texte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une plage de texte dégénérée est fournie, le point d’insertion de texte se déplace à la <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> point de terminaison de la plage de texte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se produit lorsque la sélection de texte n’est pas prise en charge par le contrôle de texte.</exception>
      </Docs>
    </Member>
  </Members>
</Type>