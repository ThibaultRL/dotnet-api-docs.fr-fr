<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a82244528eac6e037120c521525c7c211c363f52" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53394315" /></Metadata><TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un jeu de méthodes pour faciliter la gestion de la compilation d'une application ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.Compilation.BuildManager> classe gère le processus de compilation des assemblys et des pages pour une application. Il est une classe sealed et ne peut pas être héritée.  
  
 <xref:System.Web.Compilation.BuildManager> contient des membres statiques qui fournissent des informations sur les assemblys compilés.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dependency">Chaîne représentant une dépendance.</param>
        <summary>Spécifie une chaîne qui représente une dépendance utilisée par le gestionnaire de génération pour aider à déterminer si une génération propre est requise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode doit être appelée pendant la `Application_PreStartInit` étape de l’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="dependency" /> est <see langword="null" /> ou une chaîne vide.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode doit être appelée après l'étape <see langword="Application_PreStartInit" /> de l'application.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Assembly à ajouter.</param>
        <summary>Ajoute un assembly au jeu d'assemblys référencés de l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode est équivalente à l’ajout de l’assembly au fichier Web.config de niveau application. La méthode doit être appelée pendant la `Application_PreStartInit` étape de l’application.  
  
 Le <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> méthode retournera le jeu d’assemblys qui sont déterminés à partir de fichiers de configuration et de tous les assemblys qui ont été ajoutés à l’aide de cette méthode.  
  
 Si une tentative est faite pour ajouter un assembly qui a déjà été ajouté, l’entrée en double est ignorée.  
  
 Cette méthode doit être appelée avant la `Application_Start` se produit l’événement dans le fichier Global.asax.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="assembly" /> a la valeur <see langword="null" /> ou est vide.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode n'a pas été appelée avant que l'événement <see langword="Application_Start" /> du fichier Global.asax ne se soit produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la compilation en batch est activée.</summary>
        <value><see langword="true" /> si la compilation en batch est toujours activée, <see langword="false" /> si la compilation en batch n'est jamais activée, ou <see langword="null" /> si le paramètre de compilation est déterminé à partir du fichier de configuration. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d’activer ou désactiver la compilation en batch par programmation. Il correspond à la `batch` attribut de la `compilation` élément dans le fichier Web.config. Pour plus d’informations, consultez [compilation, élément (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/7c319582-074a-4d2a-a787-03b9d4541c12).  
  
 La propriété peut être définie uniquement dans le `PreApplicationStart` (méthode). Pour plus d'informations sur la méthode `PreApplicationStart`, consultez <xref:System.Web.PreApplicationStartMethodAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété n'a pas été définie dans la méthode <see langword="PreApplicationStart" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste d'assemblys générés à partir du répertoire App_Code.</summary>
        <value>Collection <see cref="T:System.Collections.IList" /> qui contient les assemblys générés à partir du répertoire App_Code.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier à créer.</param>
        <summary>Crée un fichier mis en cache.</summary>
        <returns>Objet <see cref="T:System.IO.Stream" /> pour le nouveau fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode et la <xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A> méthode que vous puissiez effectuer la mise en cache qui persiste lors des redémarrages de domaine d’application dans les environnements de confiance partielle. Il est utilisé par l’infrastructure MVC pour cache les résultats de la recherche de contrôleur.  
  
 En cache des données, vous écrivez dans le <xref:System.IO.Stream> objet qui est retourné par cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d'accès virtuel du fichier dont une instance doit être créée.</param>
        <param name="requiredBaseType">Type de base qui définit l'objet à créer.</param>
        <summary>Traite un fichier selon son chemin d'accès virtuel et crée une instance du résultat.</summary>
        <returns><see cref="T:System.Object" /> qui représente l'instance du fichier traité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A> méthode fonctionne pour les pages compilées et sans compilation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un jeu de dépendances de génération à partir du cache ASP.NET.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">Contexte de la requête.</param>
        <param name="virtualPath">Chemin d'accès virtuel à partir duquel déterminer le jeu de dépendances de génération.</param>
        <summary>Retourne un jeu de dépendances de génération pour un chemin d'accès virtuel s'il est localisé dans le cache ASP.NET.</summary>
        <returns>Objet <see cref="T:System.Web.Compilation.BuildDependencySet" /> stocké dans le cache ou <see langword="null" /> si l'objet <see cref="T:System.Web.Compilation.BuildDependencySet" /> ne peut pas être récupéré du cache.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="context">Contexte de la requête.</param>
        <param name="virtualPath">Chemin d'accès virtuel à partir duquel déterminer le jeu de dépendances de génération.</param>
        <param name="ensureIsUpToDate"><see langword="true" /> pour spécifier que seul un jeu de dépendances de génération actuel doit être retourné, ou <see langword="false" /> pour indiquer que tous les jeux de dépendances de génération disponibles doivent être retournés, même s'ils ne sont pas actuels. La valeur par défaut est <see langword="true" />.</param>
        <summary>Retourne le jeu de dépendances de génération d'un chemin virtuel si le chemin se trouve dans le cache ASP.NET, même si le contenu n'est pas actuel.</summary>
        <returns>Objet <see cref="T:System.Web.Compilation.BuildDependencySet" /> stocké dans le cache ou <see langword="null" /> si l'objet <see cref="T:System.Web.Compilation.BuildDependencySet" /> ne peut pas être récupéré du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `ensureIsUpToDate` paramètre a la valeur `true`, le <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> surcharge de méthode se comporte comme la <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> surcharge de méthode. Les deux surcharges retournent une dépendance de build actuel définie s’il en existe, sinon, elles retournent `null`.  
  
 Toutefois, le <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> surcharge de méthode inclut une option pour retourner tout jeu de dépendances de build qui est disponible, même obsolète. Si le `ensureIsUpToDate` paramètre a la valeur `false`, la méthode retournera tout jeu de dépendances de génération disponibles.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d'accès virtuel à inclure dans un assembly.</param>
        <summary>Compile un fichier en assembly à l'aide du chemin d'accès virtuel spécifié.</summary>
        <returns>Objet <see cref="T:System.Reflection.Assembly" /> compilé à partir du chemin d'accès virtuel spécifié qui est mis en cache dans la mémoire ou sur le disque.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d'accès virtuel au fichier à générer.</param>
        <summary>Compile un fichier, en fonction de son chemin d'accès virtuel, et retourne une chaîne personnalisée que le fournisseur de générations rend persistante dans le cache.</summary>
        <returns>Chaîne retournée par la méthode <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" /> qui est mise en cache sur le disque ou dans la mémoire.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d'accès virtuel à inclure dans un type.</param>
        <summary>Compile un fichier, en fonction de son chemin d'accès virtuel, et retourne le type compilé.</summary>
        <returns>Objet<see cref="T:System.Type" /> représentant le type généré à partir de la compilation du chemin d'accès virtuel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Une erreur s'est produite lors de la compilation du chemin d'accès virtuel.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet qui représente le type compilé pour le fichier Global.asax.</summary>
        <returns>Objet qui représente le type compilé pour le fichier Global.asax.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une exception est levée si cette méthode est appelée avant que le fichier Global.asax a été compilé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il a été tenté d'appeler cette méthode avant la compilation de la page Global.asax.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d'accès virtuel.</param>
        <param name="throwIfNotFound"><see langword="true" /> pour générer une erreur si le chemin d'accès virtuel n'existe pas ; sinon, <see langword="false" />. Si le chemin d'accès virtuel n'existe pas et si <paramref name="throwIfNotFound" /> est <see langword="false" />, cette méthode retourne <see langword="null" />.</param>
        <summary>Obtient une fabrique d'objets pour le chemin d'accès virtuel spécifié.</summary>
        <returns>Fabrique d'objets.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne un objet qui vous permet de générer un type en compilant le chemin d’accès virtuel. Elle retourne un objet indépendamment de si le site Web est précompilé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le chemin d'accès virtuel n'existe pas.  
  
ou 
Une exception de niveau supérieur existait déjà lorsque cette méthode a été appelée.  
  
- ou - 
Cette méthode a été appelée pendant que le processus de compilation générait des fichiers de niveau supérieur.  
  
- ou - 
Il s'agit d'une application précompilée et le chemin d'accès virtuel était introuvable dans le cache.  
  
- ou - 
Une référence circulaire a été détectée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie une liste des références d'assembly que toutes les compilations de page doivent référencer.</summary>
        <returns>Collection <see cref="T:System.Collections.ICollection" /> de références d'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La collection d’assemblys qui est retournée à partir de la <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> méthode inclut des assemblys spécifiés dans l’élément du fichier Web.config, des assemblys générés à partir de code personnalisé dans le répertoire App_Code et des assemblys dans d’autres dossiers de niveau supérieur.  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances du .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un type dans les assemblys de niveau supérieur ou dans les assemblys définis dans la configuration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly de niveau supérieur fait référence au fichier Global.asax, ou à un fichier qui se trouve dans le répertoire App_GlobalResources, App_WebReferences, App_Code ou App_Browsers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom du type.</param>
        <param name="throwOnError"><see langword="true" /> pour lever une exception si aucun objet <see cref="T:System.Type" /> ne peut être généré pour le nom de type ; sinon, <see langword="false" />.</param>
        <summary>Recherche un type dans les assemblys de niveau supérieur ou dans les assemblys définis dans la configuration et lève éventuellement une exception en cas d'échec.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente le paramètre <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly de niveau supérieur fait référence au fichier Global.asax, ou à un fichier qui se trouve dans le répertoire App_GlobalResources, App_WebReferences, App_Code ou App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> n'est pas valide.  
  
- ou - 
 <paramref name="typeName" /> est ambigu.  
  
- ou - 
 <paramref name="typeName" /> est introuvable et <paramref name="throwOnError" /> a la valeur <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom du type.</param>
        <param name="throwOnError"><see langword="true" /> afin de lever une exception si aucun <see cref="T:System.Type" /> ne peut être généré pour le nom de type ; sinon, <see langword="false" />.</param>
        <param name="ignoreCase"><see langword="true" /> si <paramref name="typeName" /> respecte la casse ; sinon, <see langword="false" />.</param>
        <summary>Recherche un type dans les assemblys de niveau supérieur ou dans les assemblys définis dans la configuration à l'aide d'une recherche ne respectant pas la casse et en levant éventuellement une exception en cas d'échec.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente le paramètre <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly de niveau supérieur fait référence au fichier Global.asax, ou à un fichier qui se trouve dans le répertoire App_GlobalResources, App_WebReferences, App_Code ou App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> n'est pas valide.  
  
ou 
 <paramref name="typeName" /> est ambigu.  
  
- ou - 
 <paramref name="typeName" /> est introuvable et <paramref name="throwOnError" /> a la valeur <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d'accès virtuel utilisé pour déterminer les dépendances.</param>
        <summary>Fournit une collection de dépendances de chemin d'accès virtuel pour un chemin d'accès virtuel spécifié.</summary>
        <returns>Collection <see cref="T:System.Collections.ICollection" /> de fichiers représentée par des chemins d'accès virtuel qui mettent en cache des dépendances pour le chemin d'accès virtuel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si l'application est précompilée.</summary>
        <value><see langword="true" /> si l'application est précompilée ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si l'application est précompilée comme pouvant être mise à jour.</summary>
        <value><see langword="true" /> si l'application est précompilée comme pouvant être mise à jour ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier à lire.</param>
        <summary>Lit un fichier mis en cache.</summary>
        <returns>Objet <see cref="T:System.IO.Stream" /> pour le fichier, ou <see langword="null" /> si le fichier n'existe pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode et la <xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A> méthode que vous puissiez effectuer la mise en cache qui persiste lors des redémarrages de domaine d’application dans les environnements de confiance partielle. Il est utilisé par l’infrastructure MVC pour cache les résultats de la recherche de contrôleur.  
  
 Pour récupérer des données mises en cache, que vous lire à partir du <xref:System.IO.Stream> objet qui est retourné par cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la version cible du .NET Framework pour le site Web actuel.</summary>
        <value>Version cible du .NET Framework pour le site Web actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété prend en charge la fonctionnalité de multi-ciblage ASP.NET, qui vous permet d’utiliser la dernière version de Visual Studio pour développer des applications qui s’exécuteront avec les versions antérieures du .NET Framework. Un fournisseur de générations peut utiliser cette propriété pour vous assurer que le fournisseur génère du code qui convient à la version ciblée du .NET Framework. Par exemple, vous souhaiterez peut-être générer un code différent en fonction de si un site Web cible le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] ou [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]. Pour plus d’informations sur le multi-ciblage, consultez [.NET Framework Multi-Targeting pour les projets Web ASP.NET](https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76).  
  
 Si le site Web n’a pas d’un fichier Web.config, ASP.NET suppose que la version du framework cible est la version qui est associée avec le pool d’applications IIS du site sous lequel s’exécute. Pour un site Web de système de fichiers qui s’exécute dans Visual Studio, la version de framework par défaut est la version actuelle du .NET Framework.  
  
 Si le site Web dispose d’un fichier Web.config, ASP.NET détermine le framework cible en examinant le fichier Web.config.  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>Sites Web qui ciblent le .NET Framework 2.0  
 Applications Web qui ciblent le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] sont compilées comme si la cible était le [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]. Le processus de génération ne fait pas de distinction entre les [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] et [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] , car le fichier Web.config n’indique pas le framework de version ou la cible du compilateur lors d’une de ces versions est ciblée. (Pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)], le fichier Web.config spécifie la version du compilateur et pour le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], le fichier Web.config spécifie le framework cible.) Par conséquent, pour les applications Web qui ciblent le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], cette propriété retourne un moniker du framework cible qui indique le [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)].  
  
 Normalement, cela n’entraîne pas de tous les problèmes. Visual Studio vous empêche de créer des références à [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] fonctionnalités dans un projet qui est ciblé pour le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]. Par exemple, Visual Studio ne fournit pas de modèles d’élément pour les services WCF dans un projet qui est ciblé pour [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], étant donné que WCF a été introduit avec le [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] et n’est pas compatible avec le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 Si vous envisagez de déployer un site Web dans un [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] environnement d’exécution et que vous utilisez un outil autre que Visual Studio pour référencer les fonctionnalités qui sont compatibles uniquement avec [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], le projet peut se générer sans générer d’erreurs ou avertissements. Toutefois, l’application peut générer des erreurs lorsque le site Web s’exécute sur le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>