<Type Name="WebBrowser" FullName="System.Windows.Controls.WebBrowser">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d3dd2b0b4615183b59259c697928fe43c6127f85" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65006220" /></Metadata><TypeSignature Language="C#" Value="public sealed class WebBrowser : System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed WebBrowser extends System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.WebBrowser" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WebBrowser&#xA;Inherits ActiveXHost" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebBrowser sealed : System::Windows::Interop::ActiveXHost" />
  <TypeSignature Language="F#" Value="type WebBrowser = class&#xA;    inherit ActiveXHost" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Interop.ActiveXHost</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <summary>Héberge des documents HTML et navigue entre ceux-ci. Permet l’interopérabilité entre le code managé WPF et le script HTML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.WebBrowser> contrôle offre les fonctionnalités suivantes :  
  
 **Navigation**: <xref:System.Windows.Controls.WebBrowser.Source%2A>, <xref:System.Windows.Controls.WebBrowser.Navigate%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToStream%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToString%2A>et <xref:System.Windows.Controls.WebBrowser.Refresh%2A>.  
  
 **Durée de vie de navigation**: <xref:System.Windows.Controls.WebBrowser.Navigating>, <xref:System.Windows.Controls.WebBrowser.Navigated>, et <xref:System.Windows.Controls.WebBrowser.LoadCompleted>.  
  
 **Journalisation de la navigation**: <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>, <xref:System.Windows.Controls.WebBrowser.GoBack%2A>, <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>, et <xref:System.Windows.Controls.WebBrowser.GoForward%2A>.  
  
 **Interopérabilité WPF/HTML**: <xref:System.Windows.Controls.WebBrowser.InvokeScript%2A> et <xref:System.Windows.Controls.WebBrowser.ObjectForScripting%2A>, et <xref:System.Windows.Controls.WebBrowser.Document%2A>.  
  
 <xref:System.Windows.Controls.WebBrowser> est lié par les contraintes de sécurité de la [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application qui héberge le <xref:System.Windows.Controls.WebBrowser>:  
  
-   Lorsque <xref:System.Windows.Controls.WebBrowser> est hébergé par un niveau de confiance totale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application (une application autonome, par exemple), <xref:System.Windows.Controls.WebBrowser> peut héberger [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] documents à partir de n’importe quel emplacement.  
  
-   Lorsque <xref:System.Windows.Controls.WebBrowser> est hébergé par un niveau de confiance partiel [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application (un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)], par exemple), <xref:System.Windows.Controls.WebBrowser> peut héberger uniquement des documents qui sont **Site d’origine** fichiers de données d’application. Pour plus d’informations, consultez [Fichiers de ressources, de contenu et de données d’une application WPF](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md).  
  
> [!CAUTION]
>  Le <xref:System.Windows.Controls.WebBrowser> instancie en interne le contrôle WebBrowser ActiveX natif. WPF active les fonctionnalités de sécurité en appliquant des contrôles de fonctionnalités pour le contrôle WebBrowser ActiveX. Les contrôles de fonctionnalités qui sont appliquées diffèrent pour les applications XBAP et les applications autonomes. Certaines applications doivent appliquer des contrôles de fonctionnalités supplémentaires pour empêcher l’exécution d’un contenu malveillant. Pour plus d’informations, consultez la section « Contrôle WebBrowser et contrôles de fonctionnalité » dans [sécurité (WPF)](~/docs/framework/wpf/security-wpf.md) et [didacticiels et des vues d’ensemble du contrôle WebBrowser](https://go.microsoft.com/fwlink/?LinkId=179388).  
  
   
  
## Examples  
 L’exemple suivant montre comment configurer <xref:System.Windows.Controls.WebBrowser> pour accéder à un [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document à l’aide de balisage uniquement.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 L’exemple suivant montre comment configurer <xref:System.Windows.Controls.WebBrowser> pour accéder à un document à l’aide de balisage et code-behind.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 L’exemple suivant montre comment gérer les `NewWindow2` d’événements et les événements similaires à l’aide un <xref:System.Windows.Controls.WebBrowser> contrôle. Cet exemple requiert une référence à **SHDocVw.dll**, un `using System.Runtime.InteropServices;` instruction et un <xref:System.Windows.Controls.WebBrowser> contrôle nommé `webBrowser1`.  
  
```csharp  
public MainWindow()  
{  
    InitializeComponent();  
  
    var serviceProvider = (IServiceProvider)webBrowser1.Document;  
    if (serviceProvider != null)  
    {  
        Guid serviceGuid = new Guid("0002DF05-0000-0000-C000-000000000046");  
        Guid iid = typeof(SHDocVw.WebBrowser).GUID;  
        var webBrowserPtr = (SHDocVw.WebBrowser)serviceProvider  
            .QueryService(ref serviceGuid, ref iid);  
        if (webBrowserPtr != null)  
        {  
            webBrowserPtr.NewWindow2 += webBrowser1_NewWindow2;  
        }  
    }  
}  
  
private void webBrowser1_NewWindow2(ref object ppDisp, ref bool Cancel)  
{  
    // Handle the event.  
}  
  
[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]  
[Guid("6d5140c1-7436-11ce-8034-00aa006009fa")]  
internal interface IServiceProvider  
{  
    [return: MarshalAs(UnmanagedType.IUnknown)]  
    object QueryService(ref Guid guidService, ref Guid riid);  
}  
```  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160056">XBAP hébergeant Silverlight, exemple</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebBrowser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebBrowser();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.WebBrowser" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.WebBrowserPermission">pour appeler cette méthode. Énumération associée : <see cref="F:System.Security.Permissions.WebBrowserPermissionLevel.Safe" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique s'il existe un document vers lequel naviguer en arrière.</summary>
        <value>Un <see cref="T:System.Boolean" /> valeur qui indique s’il existe un document vers lequel naviguer en arrière.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment naviguer dans le document précédent en appelant <xref:System.Windows.Controls.WebBrowser.GoBack%2A>. L’exemple vérifie d’abord qu’il existe des documents pour revenir en vérifiant <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique s'il existe un document vers lequel naviguer en avant.</summary>
        <value>Un <see cref="T:System.Boolean" /> valeur qui indique s’il existe un document vers lequel naviguer en avant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment naviguer vers l’avant à l’autre [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document en appelant <xref:System.Windows.Controls.WebBrowser.GoForward%2A>. L’exemple vérifie d’abord qu’il existe des documents vers lequel naviguer en avant en vérifiant <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public object Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Document { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : obj" Usage="System.Windows.Controls.WebBrowser.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’objet Document qui représente le texte hébergé [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] page.</summary>
        <value>Objet Document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet de Document doit être converti à l’interface COM que vous attendez.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">appel à cette propriété. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="webBrowser.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Naviguez en arrière vers le document précédent (s'il en existe un).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous appelez <xref:System.Windows.Controls.WebBrowser.GoBack%2A> et ne sont pas tous les documents pour accéder à, <xref:System.Windows.Controls.WebBrowser> n’effectue pas de navigation et une exception est levée. Si vous le souhaitez, vous pouvez inspecter la valeur de la <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A> propriété afin de déterminer s’il existe des documents pour revenir à.  
  
   
  
## Examples  
 L’exemple suivant montre comment naviguer vers la précédente [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document en appelant <xref:System.Windows.Controls.WebBrowser.GoBack%2A>. L’exemple vérifie d’abord qu’il n’y [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] documents pour naviguer arrière en examinant <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Il n’existe aucun document vers lequel naviguer en arrière.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="webBrowser.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Naviguez en avant vers le document [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] suivant (s’il en existe un).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous appelez <xref:System.Windows.Controls.WebBrowser.GoForward%2A> et il n’existe pas de documents vers lequel naviguer en avant, <xref:System.Windows.Controls.WebBrowser> n’effectue pas de navigation et une exception est levée. Si vous le souhaitez, vous pouvez inspecter la valeur de la <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A> propriété afin de déterminer s’il existe des documents vers lequel naviguer en avant.  
  
   
  
## Examples  
 L’exemple suivant montre comment naviguer vers l’avant vers le document suivant en appelant <xref:System.Windows.Controls.WebBrowser.GoForward%2A>. L’exemple vérifie d’abord qu’il existe des documents vers lequel naviguer en avant en vérifiant <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Il n’existe aucun document vers lequel naviguer en avant.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute une fonction de script définie dans le document actuellement chargé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="webBrowser.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nom de la fonction de script à exécuter.</param>
        <summary>Exécute une fonction de script implémentée par le document actuellement chargé.</summary>
        <returns>Objet retourné par l'appel Active Scripting.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29> ne doit pas être appelée avant la fin du document qui l’implémente le chargement. Vous pouvez détecter qu’un document a terminé le chargement en gérant la <xref:System.Windows.Controls.WebBrowser.LoadCompleted> événement.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler une fonction de script dans un document à partir d’un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application à l’aide de <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29>. Dans cet exemple, la fonction de script a aucun paramètre.  
  
 Voici le [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document qui implémente la fonction de script qui sera appelée à partir de [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function called!";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Le suivant le [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] implémentation pour appeler la fonction de script dans le [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters");  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">La fonction de script n’existe pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="webBrowser.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="scriptName">Nom de la fonction de script à exécuter.</param>
        <param name="args">Paramètres à passer à la fonction de script.</param>
        <summary>Exécute une fonction de script qui est définie dans le document actuellement chargé.</summary>
        <returns>Objet retourné par l'appel Active Scripting.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29> ne doit pas être appelée avant la fin du document qui l’implémente le chargement. Vous pouvez détecter qu’un document a terminé le chargement en gérant la <xref:System.Windows.Controls.WebBrowser.LoadCompleted> événement.  
  
 Si vous ne passez pas suffisamment valeurs de paramètre au script que vous appelez, les paramètres que vous ne passez pas de valeurs à aura la valeur undefined. Si vous passez trop de valeurs de paramètre, les valeurs excédentaires sont ignorés.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler des fonctions de script dans un document à partir d’une application à l’aide de <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29>. Dans cet exemple, les fonctions de script requièrent des paramètres.  
  
 Voici le document qui implémente les fonctions de script qui seront appelées à partir de [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function 'called: " + message + ".";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Le suivant le [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] implémentation pour appeler le script fonctionne dans le [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters", this.messageTextBox.Text);  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">La fonction de script n’existe pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le téléchargement du document sur lequel porte la navigation est terminé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gestionnaires d’événements de navigation sont transmis à une instance de la <xref:System.Windows.Navigation.NavigationEventArgs> classe, qui fournit des informations contextuelles sur la navigation, y compris les détails de la réponse Web.  
  
 Cet événement est déclenché uniquement pour les navigations de niveau supérieur.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Naviguez de façon asynchrone au document à l’emplacement spécifié <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">URL à atteindre.</param>
        <summary>Navigue de façon asynchrone jusqu'au document situé au niveau de l'URL spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29> méthode pour accéder à une URL qui peut inclure des caractères d’échappement. Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> méthode pour accéder à un <xref:System.Uri> qui n’inclut pas les caractères d’échappement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">Le <see cref="T:System.Uri" /> à atteindre.</param>
        <summary>Naviguez de façon asynchrone au document à l’emplacement spécifié <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> a le même effet en tant que paramètre le <xref:System.Windows.Controls.WebBrowser.Source%2A> propriété. <xref:System.Windows.Controls.WebBrowser.Source%2A> est utilisé à partir du balisage par les développeurs qui souhaitent spécifier de façon déclarative le document initial qui <xref:System.Windows.Controls.WebBrowser> navigue lorsque <xref:System.Windows.Controls.WebBrowser> est initialisé.  
  
 Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29> méthode pour accéder à une URL qui peut inclure des caractères d’échappement. Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> méthode pour accéder à un <xref:System.Uri> qui n’inclut pas les caractères d’échappement.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Windows.Controls.WebBrowser> pour accéder à un document à l’aide de la <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> (méthode).  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation à partir d’une application qui s’exécute en confiance partielle vers un <see cref="T:System.Uri" /> qui ne se trouve pas dans le site d’origine.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetFrameName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="postData" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="additionalHeaders" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">URL à atteindre.</param>
        <param name="targetFrameName">Nom du frame dans lequel afficher le contenu du document.</param>
        <param name="postData">Données HTTP POST à envoyer au serveur lorsque la source est demandée.</param>
        <param name="additionalHeaders">En-têtes HTTP à envoyer au serveur lorsque la source est demandée.</param>
        <summary>Navigue de façon asynchrone jusqu'au document situé au niveau de l'URL spécifiée et spécifie le frame cible dans lequel le contenu du document doit être chargé. Des données HTTP POST et des en-têtes HTTP supplémentaires peuvent être envoyés au serveur dans le cadre de la demande de navigation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> méthode pour accéder à une URL qui peut inclure des caractères d’échappement. Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> méthode pour accéder à un <xref:System.Uri> qui n’inclut pas les caractères d’échappement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="targetFrameName" Type="System.String" />
        <Parameter Name="postData" Type="System.Byte[]" />
        <Parameter Name="additionalHeaders" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Le <see cref="T:System.Uri" /> à atteindre.</param>
        <param name="targetFrameName">Nom du frame dans lequel afficher le contenu du document.</param>
        <param name="postData">Données HTTP POST à envoyer au serveur lorsque la source est demandée.</param>
        <param name="additionalHeaders">En-têtes HTTP à envoyer au serveur lorsque la source est demandée.</param>
        <summary>Naviguez de façon asynchrone au document à l’emplacement spécifié <see cref="T:System.Uri" /> et spécifiez le frame cible dans lequel charger le contenu du document. Des données HTTP POST et des en-têtes HTTP supplémentaires peuvent être envoyés au serveur dans le cadre de la demande de navigation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> méthode pour accéder à une URL qui peut inclure des caractères d’échappement. Utilisez le <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> méthode pour accéder à un <xref:System.Uri> qui n’inclut pas les caractères d’échappement.  
  
   
  
## Examples  
 L’exemple suivant montre comment naviguer vers un document et l’ouvrir dans une nouvelle fenêtre de navigateur en spécifiant le « sur : vide » cible.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri, "_blank", null, null);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation à partir d’une application qui s’exécute en confiance partielle : 
- Vers <see cref="T:System.Uri" /> qui ne se trouve pas sur le site d’origine, ou 
-   Le nom <paramref name="targetFrameName" /> n’est ni <see langword="null" /> ni vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le document sur lequel porte la navigation est localisé et en cours de téléchargement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gestionnaires d’événements de navigation sont transmis à une instance de la <xref:System.Windows.Navigation.NavigationEventArgs> classe, qui fournit des informations contextuelles sur la navigation, y compris les détails de la réponse Web.  
  
 Cet événement est déclenché uniquement pour les navigations de niveau supérieur.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToStream">
      <MemberSignature Language="C#" Value="public void NavigateToStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToStream(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.NavigateToStream : System.IO.Stream -&gt; unit" Usage="webBrowser.NavigateToStream stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Le <see cref="T:System.IO.Stream" /> qui contient le contenu d’un document.</param>
        <summary>Naviguez de façon asynchrone vers un <see cref="T:System.IO.Stream" /> qui contient le contenu d’un document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `stream` paramètre est `null`, <xref:System.Windows.Controls.WebBrowser> accède à un document vierge (« à propos : vide »).  
  
 Si le paramètre de flux de données n’est pas dans un valide [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] format, il sera affiché en tant que texte brut.  
  
 Après la navigation, <xref:System.Windows.Controls.WebBrowser.Source%2A> sera `null`.  
  
   
  
## Examples  
 L’exemple suivant montre comment naviguer vers un flux qui contient un document.  
  
```csharp  
private void goNavigateToStreamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a stream  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithScript.html", UriKind.Absolute);  
  Stream source = Application.GetResourceStream(uri).Stream;  
  
  // Navigate to HTML document stream  
  this.webBrowser.NavigateToStream(source);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToString">
      <MemberSignature Language="C#" Value="public void NavigateToString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub NavigateToString (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToString(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.NavigateToString : string -&gt; unit" Usage="webBrowser.NavigateToString text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Le <see cref="T:System.String" /> qui contient le contenu d’un document.</param>
        <summary>Naviguez de façon asynchrone vers un <see cref="T:System.String" /> qui contient le contenu d’un document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `text` paramètre est `null`, <xref:System.Windows.Controls.WebBrowser> accède à un document vierge (« à propos : vide »).  
  
 Si le paramètre de texte n’est pas valide [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] format, il sera affiché en tant que texte brut.  
  
 Après la navigation, <xref:System.Windows.Controls.WebBrowser.Source%2A> sera `null`.  
  
   
  
## Examples  
 L’exemple suivant montre comment naviguer vers une chaîne qui contient un document.  
  
```csharp  
private void goNavigateToStringButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a string  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithoutScript.html", UriKind.Absolute);  
  Stream stream = Application.GetResourceStream(uri).Stream;  
  using (StreamReader reader = new StreamReader(stream))  
  {  
    // Navigate to HTML document string  
    this.webBrowser.NavigateToString(reader.ReadToEnd());  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit juste avant la navigation vers un document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Navigation gestionnaires d’événements sont transmis à une instance de la <xref:System.Windows.Navigation.NavigatingCancelEventArgs> classe. Vous pouvez annuler la navigation en définissant le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.Windows.Navigation.NavigatingCancelEventArgs> objet `true`.  
  
 Cet événement est déclenché uniquement pour les navigations de niveau supérieur.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="ObjectForScripting">
      <MemberSignature Language="C#" Value="public object ObjectForScripting { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ObjectForScripting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectForScripting As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ObjectForScripting { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectForScripting : obj with get, set" Usage="System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une instance d'une classe public, implémentée par l'application hôte, qui est accessible par script à partir d'un document hébergé.</summary>
        <value>Le <see cref="T:System.Object" /> qui est une instance d’un <see langword="public" /> (classe), implémentée par l’application hôte, qui est accessible par script à partir d’un document hébergé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut être définie sur n’importe quel objet visible par COM pour lequel vous souhaitez que ses propriétés et méthodes publiques disponibles au code de script. Vous pouvez rendre une classe visible par COM en le marquant avec le <xref:System.Runtime.InteropServices.ComVisibleAttribute>.  
  
 L’objet qui est défini pour le script est exposé au document actif par le [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] DOM à l’aide du `window.external` propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Controls.WebBrowser.ObjectForScripting" /> est défini avec une instance du type qui n’est pas <see langword="COMVisible" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recharge la page active.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="webBrowser.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recharge la page active.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (bool noCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(bool noCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (noCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(bool noCache);" />
      <MemberSignature Language="F#" Value="member this.Refresh : bool -&gt; unit" Usage="webBrowser.Refresh noCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="noCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noCache">Spécifie s’il faut actualiser sans validation du cache.</param>
        <summary>Recharge la page active avec validation du cache facultative.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `noCache` est `true`, le <xref:System.Windows.Controls.WebBrowser> contrôler des actualisations sans validation du cache en envoyant une « pragma : no-cache » en-tête au serveur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Controls.WebBrowser.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Uri" /> du document actif hébergé dans le <see cref="T:System.Windows.Controls.WebBrowser" />.</summary>
        <value>Le <see cref="T:System.Uri" /> actif [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de la propriété source force <xref:System.Windows.Controls.WebBrowser> pour accéder au document spécifié par la <xref:System.Uri>. Si le <xref:System.Uri> est `null`, un document vierge s’affiche (« à propos : vide »).  
  
   
  
## Examples  
 L’exemple suivant montre comment configurer <xref:System.Windows.Controls.WebBrowser> pour accéder à un [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] document à l’aide de balisage uniquement.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance de <see cref="T:System.Windows.Controls.WebBrowser" /> n’est plus valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer une référence au <c>WebBrowser</c> natif sous-jacent.</exception>
        <exception cref="T:System.Security.SecurityException">Navigation à partir d’une application qui s’exécute en confiance partielle vers un <see cref="T:System.Uri" /> qui ne se trouve pas dans le site d’origine.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TabInto">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TabInto (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TabInto(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TabInto(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Function TabInto (request As TraversalRequest) As Boolean Implements IKeyboardInputSink.TabInto" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TabInto(System::Windows::Input::TraversalRequest ^ request) = System::Windows::Interop::IKeyboardInputSink::TabInto;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="request">Spécifie si le focus doit être défini sur le premier ou le dernier taquet de tabulation.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />.</summary>
        <returns><see langword="true" /> Si le focus a été défini comme demandé ; <see langword="false" />, s’il n’y a aucune taquets de tabulation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Controls.WebBrowser> est castée en interface <xref:System.Windows.Interop.IKeyboardInputSink>.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">WPF et vue d’ensemble de l’interopérabilité Win32</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Vue d'ensemble des entrées</related>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateAccelerator (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateAccelerator (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateAccelerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateAccelerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="msg">Le message et les données associées. Ne modifiez pas cette structure. Il est passé par référence uniquement à des fins de performances.</param>
        <param name="modifiers">Touches de modification.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns><see langword="true" /> Si le message a été géré par l’implémentation de méthode ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Controls.WebBrowser> est castée en interface <xref:System.Windows.Interop.IKeyboardInputSink>.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">WPF et vue d’ensemble de l’interopérabilité Win32</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Vue d'ensemble des entrées</related>
      </Docs>
    </Member>
    <Member MemberName="TabIntoCore">
      <MemberSignature Language="C#" Value="protected override bool TabIntoCore (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TabIntoCore(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TabIntoCore(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TabIntoCore (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TabIntoCore(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool" Usage="webBrowser.TabIntoCore request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="request">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateAcceleratorCore">
      <MemberSignature Language="C#" Value="protected override bool TranslateAcceleratorCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TranslateAcceleratorCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TranslateAcceleratorCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TranslateAcceleratorCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TranslateAcceleratorCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="override this.TranslateAcceleratorCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="webBrowser.TranslateAcceleratorCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>