<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="612e86224680a392836bcd29ec30a65434b4b558" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39960825" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit les représentations des champs des instructions MSIL (Microsoft Intermediate Language) pour l'émission par les membres de classe <see cref="T:System.Reflection.Emit.ILGenerator" /> (par exemple, <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir une description détaillée des codes de membre d’une opération de données, consultez la documentation de Common Language Infrastructure (CLI), en particulier « Partition III : CIL Instruction Set » et « Partition II : Metadata Definition and Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
   
  
## Examples  
 L’exemple suivant illustre la construction d’une méthode dynamique à l’aide <xref:System.Reflection.Emit.ILGenerator> à émettre `OpCodes` dans un <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ajoute deux valeurs et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|58|add|Ajoute deux valeurs numériques, retournant une nouvelle valeur numérique.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est ajouté à `value2`.  
  
4.  Le résultat est placé sur la pile.  
  
 Dépassement de capacité n’est pas détecté pour les opérations sur les entiers (pour la gestion du dépassement de capacité, consultez <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Ajout de l’entier encapsule, au lieu de saturer. Par exemple, en supposant que des entiers 8 bits où `value1` a la valeur 255 et `value2` est définie sur 1, le résultat renvoyé à la ligne est 0 au lieu de 256.  
  
 Dépassement de capacité à virgule flottante retourne `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).  
  
 Les types d’opérande acceptables et leur type de données de résultat correspondant sont répertoriés dans le tableau ci-dessous. S’il n’existe aucune entrée pour une combinaison de type particulier (par exemple, `int32` et `float`; `int32` et `int64`), il est un non valide langage MSIL (Microsoft Intermediate) et génère une erreur.  
  
|opérande|type valeur 1|type valeur 2|type de résultat|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `add` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ajoute deux entiers, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D6|Add.ovf|Ajoute deux valeurs entières signées avec une vérification de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est ajouté à `value2` avec une vérification de dépassement de capacité.  
  
4.  Le résultat est placé sur la pile.  
  
 <xref:System.OverflowException> est levée si le résultat n’est pas représenté dans le type de résultat.  
  
 Vous pouvez effectuer cette opération sur les entiers signés. Pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Les types d’opérande acceptables et leur type de données de résultat correspondant sont répertoriés dans le tableau ci-dessous. S’il n’existe aucune entrée pour une combinaison de type particulier (par exemple, `int32` et `float`; `int32` et `int64`), il est une instruction de langage MSIL (Microsoft Intermediate Language) non valide et génère une erreur.  
  
|opérande|type valeur 1|type valeur 2|type de résultat|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `add.ovf` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ajoute deux valeurs entières non signées, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D7|Add.ovf.un|Ajoute deux valeurs entières non signées avec une vérification de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est ajouté à `value2` avec une vérification de dépassement de capacité.  
  
4.  Le résultat est placé sur la pile.  
  
 <xref:System.OverflowException> est levée si le résultat n’est pas représenté dans le type de résultat.  
  
 Vous pouvez effectuer cette opération sur les entiers signés. Pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Les types d’opérande acceptables et leur type de données de résultat correspondant sont répertoriés dans le tableau ci-dessous. S’il n’existe aucune entrée pour une combinaison de type particulier (par exemple, `int32` et `float`; `int32` et `int64`), il est une instruction de langage MSIL (Microsoft Intermediate Language) non valide et génère une erreur.  
  
|opérande|type valeur 1|type valeur 2|type de résultat|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `add.ovf.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcule l'opération de bits AND de deux valeurs et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Instruction|Description |  
|------------|-----------------|-----------------|  
|5F|et|Détermine l’opération de bits AND de deux valeurs entières.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value1` et `value2` sont dépilés ; l’opération de bits AND de deux valeurs est calculée.  
  
4.  Le résultat est placé sur la pile.  
  
 La `and` instruction calcule le AND au niveau du bit des valeurs des deux premiers sur la pile et laisse le résultat dans la pile.  
  
 `And` est une opération spécifique aux entiers.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `and` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne un pointeur non managé vers la liste d'arguments de la méthode actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 00|arglist|Retourne un handle de liste d’arguments pour la méthode actuelle.|  
  
 Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.  
  
 Le `arglist` instruction retourne un handle opaque (un pointeur non managé, de type `native int`) qui représente la liste d’arguments de la méthode actuelle. Ce handle est uniquement valide pendant la durée de vie de la méthode actuelle. Vous pouvez, toutefois, passez le handle à d’autres méthodes tant que la méthode actuelle est sur le thread de contrôle. Vous pouvez uniquement exécuter la `arglist` instruction dans une méthode qui accepte un nombre variable d’arguments.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `arglist` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si les deux valeurs sont égales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|3 B &LT; `int32` >|beq `target`|Branche à l’instruction cible à l’offset `target` si les deux valeurs sont égales.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est égal à `value2`, cette opération est effectuée.  
  
 Le `beq` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est égal à `value2`. L’effet est le même résultat qu’un `ceq` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Les types d’opérande acceptables sont encapsulés ci-dessous :  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.  
  
 Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction (ces transferts sont strictement limités et devez utiliser la <xref:System.Reflection.Emit.OpCodes.Leave> instruction à la place).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `beq` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si les deux valeurs sont égales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|2E &LT; `int8` >|beq.s `target`|Branche à l’instruction cible à l’offset `target` Si égal, forme abrégée|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est égal à `value2`, cette opération est effectuée.  
  
 Le `beq.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est égal à `value2`. L’effet est le même résultat qu’un `ceq` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Les types d’opérande acceptables sont encapsulés ci-dessous :  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.  
  
 Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction (ces transferts sont strictement limités et devez utiliser la <xref:System.Reflection.Emit.OpCodes.Leave> instruction à la place).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `beq.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est supérieure ou égale à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.  
  
 Le `bge` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`. L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure ou égale à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.  
  
 Le `bge.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`. L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième valeur (valeurs non signées).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.  
  
 Le `bge.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge.un` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième valeur (valeurs non signées), forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.  
  
 Le `bge.un.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge.un.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est supérieure à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|3D &LT; `int32` >|bgt `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.  
  
 Le `bgt` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`. L’effet est identique à l’exécution d’un `cgt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.  
  
 Le `bgt.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`. L’effet est identique à l’exécution d’un `cgt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur (valeurs non signées).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.  
  
 Le `bgt.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `cgt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt.un` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur (valeurs non signées), forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.  
  
 Le `bgt.un.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `cgt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt.un.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est inférieure ou égale à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|3E `<int32>`|bLe `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.  
  
 Le `ble` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`. L’effet est identique à l’exécution d’un `cgt` instruction (`cgt.un` à virgule flottante) suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure ou égale à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|31 `<int8>`|bLe.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.  
  
 Le `ble.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`. L’effet est identique à l’exécution d’un `cgt` instruction (`cgt.un` à virgule flottante) instruction suivie d’un`brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est inférieure ou égale à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|43 `<int32>`|bLe.un `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième valeur (valeurs non signées).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.  
  
 Le `ble.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `cgt.un` instruction (`cgt` à virgule flottante) suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble.un` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure ou égale à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|36 `<int8>`|bLe.un.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième valeur (valeurs non signées), forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.  
  
 Le `ble.un.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `cgt.un` instruction (`cgt` à virgule flottante) suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble.un.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est inférieure à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.  
  
 Le `blt` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`. L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure à la deuxième.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.  
  
 Le `blt.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure à `value2`. L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si la première valeur est inférieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième valeur (valeurs non signées).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.  
  
 Le `blt.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt.un` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième valeur (valeurs non signées), forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.  
  
 Le `blt.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt.un.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible lorsque deux valeurs entières non signées ou valeurs float non ordonnées ne sont pas égales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|Branche à la cible instruction à l’offset spécifié si les deux valeurs entières non signées ne sont ne pas égales (valeurs non signées).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` n’est pas égal à `value2`, cette opération est effectuée.  
  
 Le `bne.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` n’est pas égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `ceq` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bne.un` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible lorsque deux valeurs entières non signées ou valeurs float non ordonnées ne sont pas égales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Branche à la cible instruction à l’offset spécifié si les deux valeurs entières non signées ne sont pas égales (valeurs non signées), forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés ; si `value1` n’est pas égal à `value2`, cette opération est effectuée.  
  
 Le `bne.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` n’est pas égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées. L’effet est identique à l’exécution d’un `ceq` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bne.un.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit un type valeur en référence d'objet (type <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|8C < `T` >|zone `valTypeToken`|Convertir un type valeur (du type spécifié dans `valTypeToken`) à une référence d’objet true.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Un type valeur est envoyé à la pile.  
  
2.  Le type de valeur est retirée de la pile ; le `box` opération est effectuée.  
  
3.  Une référence d’objet pour le type de valeur « boxed » qui en résulte est placée sur la pile.  
  
 Un type valeur a deux représentations distinctes au sein de l’Infrastructure (CLI) :  
  
-   Un formulaire « brut » utilisé lorsqu’un type valeur est incorporé au sein d’un autre objet ou sur la pile.  
  
-   Un formulaire « boxed », où les données dans le type de valeur sont encapsulées (boxed) dans un objet afin qu’il peut exister une entité indépendante.  
  
 Le `box` instruction convertit le type de valeur « brut » (unboxed) en une référence d’objet (type `O`). Cela s’effectue en créant un nouvel objet et de copie des données à partir du type de valeur dans l’objet nouvellement alloué. `valTypeToken` est un jeton de métadonnées indiquant le type du type de valeur sur la pile.  
  
 <xref:System.OutOfMemoryException> est levée si la mémoire est insuffisante pour satisfaire la requête.  
  
 <xref:System.TypeLoadException> est levée si la classe est introuvable. Cela est généralement détecté lorsque le langage MSIL (Microsoft Intermediate Language) est converti en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `box` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible de manière non conditionnelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Branches à une instruction cible à l’offset spécifié.|  
  
 Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.  
  
 La `br` instruction transfère sans condition le contrôle à une instruction cible. L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `br` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible de manière non conditionnelle (forme abrégée).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|2 B &LT; `int8` >|br.s `target`|Branches à une instruction cible à l’offset spécifié, la forme abrégée.|  
  
 Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.  
  
 La `br.s` instruction transfère sans condition le contrôle à une instruction cible. L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `br.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Active l'infrastructure CLI de façon à informer le débogueur qu'un point d'arrêt a été dépassé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|01|break|signale à un débogueur qu’un point d’arrêt a été atteint.|  
  
 Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.  
  
 La `break` instruction est prise en charge de débogage. Il signale l’interface CLI pour informer le débogueur qu’un point d’arrêt a été dépassé. Il n’a aucun autre effet sur l’état de l’interpréteur.  
  
 La `break` instruction a le plus petit possible taille activation code instructions mise à jour corrective avec un point d’arrêt et d’affecter le code environnant.  
  
 La `break` instruction peut intercepter un débogueur, ne rien faire ou lever une exception de sécurité. Le comportement exact est défini par l’implémentation.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `break` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si <paramref name="value" /> est <see langword="false" />, une référence null (<see langword="Nothing" /> en Visual Basic) ou zéro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero correspondants `target`|Branches à une instruction cible à l’offset spécifié si `false`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile par une opération précédente.  
  
2.  `value` est retirée de la pile ; Si `value` est `false`, créer une branche vers `target`.  
  
 Le `brfalse` instruction (et ses alias `brnull` et `brzero`) transfère le contrôle à l’instruction cible spécifiée si `value` (de type `int32`, `int64`, référence d’objet `O`managé pointeur `&`, pointeur transitoire `*`, `native int`) est égal à zéro (`false`). Si `value` est différente de zéro (`true`) l’exécution se poursuit à l’instruction suivante.  
  
 L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brfalse` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si <paramref name="value" /> est <see langword="false" />, une référence null ou zéro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Branches à une instruction cible à l’offset spécifié si `false`, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile par une opération précédente.  
  
2.  `value` est retirée de la pile ; Si `value` est `false`, créer une branche vers `target`.  
  
 Le `brfalse.s` instruction (et ses alias `brnull` et `brzero`) transfère le contrôle à l’instruction cible spécifiée si `value` (de type `int32`, `int64`, référence d’objet `O`managé pointeur `&`, pointeur transitoire `*`, `native int`) est égal à zéro (`false`). Si `value` est différente de zéro (`true`) l’exécution se poursuit à l’instruction suivante.  
  
 L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brfalse.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible si <paramref name="value" /> est <see langword="true" />, non null ou différent de zéro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Créer une branche vers une instruction cible à l’offset spécifié si différente de zéro (`true`).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile par une opération précédente.  
  
2.  `value` est retirée de la pile ; Si `value` est `true`, créer une branche vers `target`.  
  
 Le `brtrue` instruction transfère le contrôle à l’instruction cible spécifiée si `value` (type `native int`) est différent de zéro (`true`). Si `value` est égal à zéro (`false`) l’exécution se poursuit à l’instruction suivante.  
  
 Si `value` est une référence d’objet (type `O`) puis `brinst` (un alias pour `brtrue`) transfère le contrôle s’il représente une instance d’un objet (par exemple, si elle n’est pas la référence d’objet null ; consultez <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brtrue` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère le contrôle à une instruction cible (forme abrégée) si <paramref name="value" /> est <see langword="true" />, non null ou différent de zéro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|2D &LT; `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Créer une branche vers une instruction cible à l’offset spécifié si différente de zéro (`true`), forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile par une opération précédente.  
  
2.  `value` est retirée de la pile ; Si `value` est `true`, créer une branche vers `target`.  
  
 Le `brtrue.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value` (type `native int`) est différent de zéro (`true`). Si `value` est égal à zéro (`false`) l’exécution se poursuit à l’instruction suivante.  
  
 Si `value` est une référence d’objet (type `O`) puis `brinst` (un alias pour `brtrue`) transfère le contrôle s’il représente une instance d’un objet (par exemple, si elle n’est pas la référence d’objet null ; consultez <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes. Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brtrue.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Appelle la méthode indiquée par le descripteur de méthode passé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|28 < `T` >|Appel `methodDesc`|Appelez la méthode décrite par `methodDesc`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Arguments de méthode `arg1` via `argN` sont envoyées dans la pile.  
  
2.  Arguments de méthode `arg1` via `argN` sont dépilés ; l’appel de méthode est effectué avec ces arguments et le contrôle est transféré à la méthode référencée par le descripteur de méthode. Lorsque vous avez terminé, une valeur de retour est générée par la méthode de l’appelé et envoyée à l’appelant.  
  
3.  La valeur de retour est placée sur la pile.  
  
 La `call` instruction appelle la méthode indiquée par le descripteur de méthode passé avec l’instruction. Le descripteur de méthode est un jeton de métadonnées qui indique la méthode à l’appel et le nombre, le type et l’ordre des arguments qui ont été placés sur la pile à passer à cette méthode, ainsi que la convention d’appel à utiliser. Le `call` instruction peut être immédiatement précédée d’un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) instruction pour spécifier que l’état actuel de la méthode doit être libéré avant le transfert du contrôle du préfixe. Si l’appel transfère le contrôle à une méthode de confiance plus élevé que la méthode d’origine, le frame de pile n’est pas libéré. Au lieu de cela, l’exécution se poursuit en mode silencieux comme si le `tail` n’avait pas été fourni. Le jeton de métadonnées transporte des informations suffisantes pour déterminer si l’appel concerne une méthode statique, une méthode d’instance, une méthode virtuelle ou une fonction globale. Dans tous ces cas l’adresse de destination est entièrement déterminée à partir du descripteur de méthode (Ceci contraste avec le <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction d’appel de méthodes virtuelles, où l’adresse de destination dépend également du type de runtime de l’instance référence envoyé avant le <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Les arguments sont placés sur la pile dans l’ordre de gauche à droite. Autrement dit, le premier argument est calculé et placé sur la pile, puis le deuxième argument, puis le troisième, jusqu'à ce que tous les arguments nécessaires sont située en haut de la pile dans l’ordre décroissant. Il existe trois cas particuliers importants :  
  
 1. Les appels à une instance (ou virtuel) méthode doit transmettre cette référence d’instance avant tout l’argument visible par l’utilisateur. La référence d’instance ne doit pas être une référence null. La signature dans les métadonnées ne contient pas une entrée dans la liste de paramètres pour le `this` pointeur ; au lieu de cela, elle utilise un bit pour indiquer si la méthode requiert le passage du `this` pointeur.  
  
 2. Il est possible d’appeler une méthode virtuelle à l’aide `call` (au lieu de `callvirt`) ; cela indique que la méthode doit être résolu à l’aide de la classe spécifiée par la méthode plutôt que comme spécifié dynamiquement à partir de l’objet appelé.  
  
 3. Notez que d’un délégué `Invoke` méthode peut être appelée avec soit le `call` ou `callvirt` instruction.  
  
 <xref:System.Security.SecurityException> peut être levée si le système de sécurité n’accorde pas l’appelant l’accès à la méthode appelée. La vérification de sécurité peut se produire lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif plutôt qu’au moment de l’exécution.  
  
> [!NOTE]
>  Lorsque vous appelez des méthodes de System.Object sur des types valeur, envisagez d’utiliser le `constrained` avec le préfixe le `callvirt` instruction au lieu de l’émission d’un `call` instruction. Cela supprime la nécessité d’émettre un IL différent en fonction de la valeur déterminant le type de valeur substitue la méthode, en évitant un problème potentiel de la gestion des versions. Envisagez d’utiliser le `constrained` préfixe lors de l’appel des méthodes d’interface sur des types valeur, étant donné que la méthode de type valeur mise en œuvre de la méthode d’interface peut être modifié à l’aide un `MethodImpl`. Ces problèmes sont décrits plus en détail dans le <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `call` opcode :  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  Le <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> méthode est fournie pour `varargs` appels. Utilisez le <xref:System.Reflection.Emit.ILGenerator.Emit%2A> méthode pour les appels normaux.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Appelle la méthode indiquée dans la pile d'évaluation (sous la forme d'un pointeur vers un point d'entrée) avec les arguments décrits par une convention d'appel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Appelle la méthode pointée avec les arguments décrits par la convention d’appel.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Arguments de méthode `arg1` via `argN` sont envoyées dans la pile.  
  
2.  Le pointeur d’entrée de méthode est placé sur la pile.  
  
3.  Arguments de méthode `arg1` via `argN` et le pointeur d’entrée de méthode sont dépilés ; l’appel à la méthode est effectuée. Lorsque vous avez terminé, une valeur de retour est générée par la méthode de l’appelé et envoyée à l’appelant.  
  
4.  La valeur de retour est placée sur la pile.  
  
 Le `calli` instruction appelle le pointeur d’entrée de méthode avec les arguments `arg1` via `argN`. Les types de ces arguments sont décrits par la convention d’appel spécifique (`callSiteDesc`). Le `calli` instruction peut être immédiatement précédée d’un `tail` préfixe (<xref:System.Reflection.Emit.OpCodes.Tailcall>) pour spécifier que l’état actuel de la méthode doit être libéré avant le transfert du contrôle. Si l’appel transfère le contrôle à une méthode de confiance plus élevé que la méthode d’origine le frame de pile n’est pas libéré ; au lieu de cela, l’exécution se poursuit en silence comme si le `tail` n’avait pas été fourni.  
  
 Le pointeur d’entrée de méthode est censé pour être un pointeur spécifique en code natif (de l’ordinateur cible) qui peut être appelée de manière légitime avec les arguments décrits par la convention d’appel (un jeton de métadonnées pour une signature autonome). Ce type de pointeur peut être créé à l’aide de la <xref:System.Reflection.Emit.OpCodes.Ldftn> ou <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> obtenir des instructions, ou transmise par le code natif.  
  
 La convention d’appel n’est pas vérifiée dynamiquement, par conséquent, code qui utilise un `calli` instruction ne fonctionne pas correctement si la destination n’utilise pas réellement la convention d’appel spécifiée.  
  
 Les arguments sont placés sur la pile dans l’ordre de gauche à droite. Autrement dit, le premier argument est calculé et placé sur la pile, puis le deuxième argument, puis le troisième, jusqu'à ce que tous les arguments nécessaires sont située en haut de la pile dans l’ordre décroissant. La séquence de génération de code pour une instance ou une méthode virtuelle doit transmettre cette référence d’instance (qui ne doit pas être une référence null) avant tout argument visible par l’utilisateur.  
  
 <xref:System.Security.SecurityException> peut être levée si le système de sécurité n’accorde pas l’accès de l’appelant à la méthode appelée. La vérification de sécurité peut se produire lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> méthodes peuvent être utilisées pour effectuer un `calli` obtenir des instructions sur la pile. Notez que `calli` doit être appelé via les méthodes ci-dessous au lieu d’utiliser la <xref:System.Reflection.Emit.ILGenerator.Emit%2A> classe pour placer l’instruction directement sur la pile.  
  
-   ILGenerator.EmitCalli (Opcode, CallingConventions, Type, Type [], Type[]) pour les appels à l’aide d’une convention d’appel managée.  
  
-   ILGenerator.EmitCalli (Opcode, Type[]) CallingConvention, Type, pour les appels à l’aide d’une convention d’appel non managée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Appelle une méthode à liaison tardive sur un objet, en exécutant un push de la valeur de retour dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Appelle une méthode spécifique associée `obj`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `obj` est placé sur la pile.  
  
2.  Arguments de méthode `arg1` via `argN` sont envoyées dans la pile.  
  
3.  Arguments de méthode `arg1` via `argN` et la référence d’objet `obj` sont dépilés ; l’appel de méthode est effectué avec ces arguments et le contrôle est transféré à la méthode dans `obj` référencé par la méthode jeton de métadonnées. Lorsque vous avez terminé, une valeur de retour est générée par la méthode de l’appelé et envoyée à l’appelant.  
  
4.  La valeur de retour est placée sur la pile.  
  
 La `callvirt` instruction appelle une méthode à liaison tardive sur un objet. Autrement dit, la méthode est choisie en fonction du type de runtime de `obj` plutôt que de la classe de compilation visible dans le pointeur de la méthode. `Callvirt` peut être utilisé pour appeler à la fois virtuels et de méthodes d’instance. Le `callvirt` instruction peut être immédiatement précédée d’un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) pour spécifier que le frame de pile actuel doit être libéré avant de transférer le contrôle. Si l’appel transfère le contrôle à une méthode de confiance plus élevé que la méthode d’origine, le frame de pile ne sera pas publié.  
  
 Le jeton de métadonnées de méthode fournit le nom, la classe et la signature de la méthode à appeler. La classe associée `obj` est la classe dont il s’agit d’une instance. Si la classe définit une méthode non statique qui correspond au nom de la méthode indiquée et signature, cette méthode est appelée. Dans le cas contraire, toutes les classes dans la chaîne de la classe de base de cette classe sont vérifiées dans l’ordre. C’est une erreur si aucune méthode n’est trouvée.  
  
 `Callvirt` Dépile l’objet et les arguments associés de la pile d’évaluation avant d’appeler la méthode. Si la méthode a une valeur de retour, elle est ajoutée à la pile à l’achèvement de la méthode. Sur le côté de l’appelé, le `obj` paramètre est accessible en tant qu’argument 0, `arg1` en tant qu’argument 1 et ainsi de suite.  
  
 Les arguments sont placés sur la pile dans l’ordre de gauche à droite. Autrement dit, le premier argument est calculé et placé sur la pile, puis le deuxième argument, puis le troisième, jusqu'à ce que tous les arguments nécessaires sont située en haut de la pile dans l’ordre décroissant. La référence d’instance `obj` (toujours obligatoire pour `callvirt`) doivent être envoyées avant les arguments visible par l’utilisateur. La signature (contenue dans le jeton de métadonnées) pas besoin de contenir une entrée dans la liste de paramètres pour ce pointeur.  
  
 Notez qu’une méthode virtuelle peut également être appelée à l’aide de la <xref:System.Reflection.Emit.OpCodes.Call> instruction.  
  
 <xref:System.MissingMethodException> est levée si une méthode non statique avec le nom indiqué et la signature est introuvable dans la classe associée `obj` ou l’un de ses classes de base. Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.  
  
 <xref:System.NullReferenceException> est levé si obj est null.  
  
 <xref:System.Security.SecurityException> est levée si le système de sécurité n’accorde pas l’appelant l’accès à la méthode appelée. La vérification de sécurité peut se produire lorsque le fichier CIL est converti en code natif plutôt qu’au moment de l’exécution.  
  
> [!NOTE]
>  Lorsque vous appelez des méthodes de System.Object sur des types valeur, envisagez d’utiliser le `constrained` avec le préfixe le `callvirt` instruction. Cela supprime la nécessité d’émettre un IL différent en fonction de la valeur déterminant le type de valeur substitue la méthode, en évitant un problème potentiel de la gestion des versions. Envisagez d’utiliser le `constrained` préfixe lors de l’appel des méthodes d’interface sur des types valeur, étant donné que la méthode de type valeur mise en œuvre de la méthode d’interface peut être modifié à l’aide un `MethodImpl`. Ces problèmes sont décrits plus en détail dans le <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `callvirt` opcode :  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tente d'effectuer un cast d'un objet passé par référence en classe spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Convertit un objet vers un nouvel objet de type `class`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet est placée sur la pile.  
  
2.  La référence d’objet est retirée de la pile ; l’objet référencé est convertie comme spécifié `class`.  
  
3.  En cas de réussite, une nouvelle référence d’objet est placée sur la pile.  
  
 Le `castclass` instruction tente d’effectuer un cast de la référence d’objet (type `O`) située en haut de la pile pour une classe spécifiée. La nouvelle classe est spécifiée par un jeton de métadonnées indiquant la classe souhaitée. Si la classe de l’objet en haut de la pile n’implémente pas la nouvelle classe (en supposant que la nouvelle classe est une interface) et n’est pas une classe dérivée de la nouvelle classe puis un <xref:System.InvalidCastException> est levée. Si la référence d’objet est une référence null, `castclass` réussit et retourne le nouvel objet comme une référence null.  
  
 <xref:System.InvalidCastException> est levé si obj ne peut pas être casté en classe.  
  
 <xref:System.TypeLoadException> est levée si la classe est introuvable. Cela est généralement détecté lorsqu’une instruction de langage MSIL (Microsoft Intermediate Language) est convertie en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `castclass` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compare deux valeurs. Si elles sont égales, la valeur entière 1 (<see langword="(int32" />) fait l'objet d'un push dans la pile d'évaluation ; sinon, le push est exécuté sur la valeur 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 01|ceq|Exécute un push de 1 si `value1` est égal à `value2`; sinon exécute un push de 0.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est comparé à `value2`.  
  
4.  Si `value1` est égal à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.  
  
 Le `ceq` instruction compare `value1` et `value2`. Si `value1` est égal à `value2`, la valeur 1 (de type `int32`) est ajoutée à la pile. Sinon, 0 (de type `int32`) est ajoutée à la pile.  
  
 Pour un nombre à virgule flottante, `ceq` retourne 0 si les nombres ne sont pas ordonnés (ou les deux sont des valeurs NaN). Les valeurs infinies sont égales à eux-mêmes.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ceq` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compare deux valeurs. Si la première valeur est supérieure à la deuxième, la valeur entière 1 (<see langword="(int32" />) fait l'objet d'un push dans la pile d'évaluation ; sinon, le push est exécuté sur la valeur 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 02|cgt|Exécute un push de 1 si `value1` est supérieur à `value2`; sinon exécute un push de 0.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `cgt` teste si `value1` est supérieur à `value2`.  
  
4.  Si `value1` est supérieur à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.  
  
 Le `cgt` instruction compare `value1` et `value2`. Si `value1` est strictement supérieur à `value2`, puis un `int32` la valeur 1 est ajoutée à la pile. Sinon, un `int32` la valeur 0 est ajoutée à la pile.  
  
-   Pour les nombres à virgule flottante, `cgt` retourne 0 si les nombres ne sont pas ordonnés (autrement dit, si un ou les deux arguments sont des valeurs NaN).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cgt` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compare deux valeurs non signées ou non ordonnées. Si la première valeur est supérieure à la deuxième, la valeur entière 1 (<see langword="(int32" />) fait l'objet d'un push dans la pile d'évaluation ; sinon, le push est exécuté sur la valeur 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|Exécute un push de 1 si `value1` est supérieur à `value2`; sinon exécute un push de 0 (valeurs non signées).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `cgt.un` teste si `value1` est supérieur à `value2`.  
  
4.  Si `value1` est supérieur à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.  
  
 Un `int32` la valeur 1 est ajoutée à la pile si une des opérations suivantes est `true` :  
  
 Pour les nombres à virgule flottante, `value1` n’est pas ordonné par rapport à `value2`.  
  
 Pour les valeurs entières, `value1` est strictement supérieur à `value2` lorsqu’elles sont considérées comme des nombres non signés.  
  
 Sinon, un `int32` la valeur 0 est ajoutée à la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cgt.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lève <see cref="T:System.ArithmeticException" /> si la valeur n'est pas un nombre fini.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|C3|ckfinite|lever <xref:System.ArithmeticException> si la valeur n’est pas un nombre fini.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile...  
  
2.  `value` est retirée de la pile et la `ckfinite` instruction est exécutée sur celui-ci.  
  
3.  `value` sont réinsérées dans la pile si aucune exception n’est levée.  
  
 Le `ckfinite instruction` lève <xref:System.ArithmeticException> si `value` (un nombre à virgule flottante) est soit un « not a number » valeur (NaN) ou un `+-` valeur d’infini. `Ckfinite` laisse la valeur dans la pile si aucune exception n’est levée. L’exécution n’est pas spécifiée si `value` n’est pas un nombre à virgule flottante.  
  
 <xref:System.ArithmeticException> est levée si `value` n’est pas un nombre « normal ».  
  
 Notez qu’une exception spécifique ou une classe dérivée de <xref:System.ArithmeticException> peut être plus appropriée, en passant la valeur incorrecte au gestionnaire d’exceptions.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ckfinite` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compare deux valeurs. Si la première valeur est inférieure à la deuxième, la valeur entière 1 (<see langword="(int32" />) fait l'objet d'un push dans la pile d'évaluation ; sinon, le push est exécuté sur la valeur 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 04|clt|Exécute un push de 1 si `value1` est inférieure à `value2`; sinon exécute un push de 0.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est : `value1` est placé sur la pile.  
  
1.  `value2` est placé sur la pile.  
  
2.  `value2` et `value1` sont dépilés de la pile ; `clt` teste si `value1` est inférieure à `value2`.  
  
3.  Si `value1` est inférieure à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.  
  
 Le `clt` instruction compare `value1` et `value2`. Si `value1` est strictement inférieur à `value2`, puis un `int32` la valeur 1 est ajoutée à la pile. Sinon, un `int32` la valeur 0 est ajoutée à la pile.  
  
-   Pour les nombres à virgule flottante, `clt` retourne 0 si les nombres ne sont pas ordonnés (autrement dit, si un ou les deux arguments sont des valeurs NaN).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `clt` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compare les valeurs non signées ou non ordonnées <paramref name="value1" /> et <paramref name="value2" />. Si <paramref name="value1" /> est inférieur à <paramref name="value2" />, la valeur entière 1 (<see langword="(int32" />) fait alors l'objet d'un push dans la pile d'évaluation ; sinon, le push est exécuté sur la valeur 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 05|clt.un|Exécute un push de 1 si `value1` est inférieure à `value2`; sinon exécute un push de 0 (valeurs non signées).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `clt.un` teste si `value1` est inférieure à `value2`.  
  
4.  Si `value1` est inférieure à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.  
  
 Le `clt.un` instruction compare `value1` et `value2`. Un `int32` la valeur 1 est ajoutée à la pile si une des opérations suivantes est vraie :  
  
-   `value1` est strictement inférieur à `value2` (comme pour `clt`).  
  
-   Pour les nombres à virgule flottante, `value1` n’est pas ordonné par rapport à `value2`.  
  
-   Pour les valeurs entières, `value1` est strictement inférieur à `value2` lorsqu’elles sont considérées comme des nombres non signés.  
  
 Sinon, un `int32` la valeur 0 est ajoutée à la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `clt.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contraint le type sur lequel un appel à une méthode virtuelle est effectué.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|contrainte. `thisType`|Appel d’une méthode virtuelle sur un type contraint à être de type `T`.|  
  
 Le `constrained` préfixe est autorisé uniquement sur un `callvirt` instruction.  
  
 L’état de la pile MSIL à ce stade doit être comme suit :  
  
1.  Un pointeur managé, `ptr`, est placé sur la pile. Le type de `ptr` doit être un pointeur managé (`&`) à `thisType`. Notez que cela est différent du cas d’un sans préfixe `callvirt` qui attend une référence de `thisType`.  
  
2.  Arguments de méthode `arg1` via `argN` sont envoyées dans la pile, comme avec un sans préfixe `callvirt` instruction.  
  
 Le `constrained` préfixe est conçu pour permettre `callvirt` instructions effectuées uniforme de façon indépendante si `thisType` est un type valeur ou un type référence.  
  
 Quand un `callvirt` `method` l’instruction a été préfixée par `constrained` `thisType`, l’instruction est exécutée comme suit :  
  
-   Si `thisType` est un type référence (par opposition à un type valeur) puis `ptr` est déréférencé et passé en tant que le pointeur 'this' à la `callvirt` de `method`.  
  
-   Si `thisType` est un type valeur et `thisType` implémente `method` puis `ptr` est passée non modifié comme le pointeur 'this' à un `call` `method` instruction, pour l’implémentation de `method` par `thisType`.  
  
-   Si `thisType` est un type valeur et `thisType` n’implémente pas `method` puis `ptr` est déréférencé, boxed et passé en tant que le pointeur 'this' à la `callvirt` `method` instruction.  
  
 Ce dernier cas peut se produire uniquement lorsque `method` a été définie sur <xref:System.Object>, <xref:System.ValueType>, ou <xref:System.Enum> et ne pas remplacé par `thisType`. Dans ce cas, la conversion boxing entraîne une copie de l’objet d’origine qu’il veut. Toutefois, car aucune des méthodes de <xref:System.Object>, <xref:System.ValueType>, et <xref:System.Enum> modifier l’état de l’objet, cette action ne peut pas être détectée.  
  
 Le `constrained` préfixe prend en charge les générateurs IL qui créent du code générique. Normalement la `callvirt` instruction n’est pas valide sur les types valeur. Au lieu de cela, il est nécessaire que les compilateurs de langage intermédiaire exécutent de manière efficace la transformation « this » décrite ci-dessus au moment de la compilation, selon le type de `ptr` et la méthode appelée. Toutefois, lorsque `ptr` est un type générique qui est inconnu au moment de la compilation, il n’est pas possible d’effectuer cette transformation au moment de la compilation.  
  
 Le `constrained` opcode permet aux compilateurs IL d’effectuer un appel à une fonction virtuelle uniforme façon de s’il `ptr` est un type valeur ou un type référence. Même s’il est destiné à être le cas où `thisType` est une variable de type générique, le `constrained` peut réduire la complexité de la génération d’appels virtuels dans des langages qui masquent la distinction entre les types valeur et utilisez le préfixe également fonctionne pour les types non génériques et types de référence.  
  
 À l’aide de la `constrained` préfixe évite également d’éventuels problèmes de versioning avec les types valeur. Si le `constrained` préfixe n’est pas utilisé, IL différent doit être émis selon ou non un type valeur substitue à une méthode de System.Object. Par exemple, si un type valeur `V` substitue la méthode Object.ToString (), un `call` `V.ToString()` l’instruction est émise ; dans ce cas, un `box` instruction et un `callvirt` `Object.ToString()` instruction sont émis. Un problème de contrôle de version peut se produire dans le premier cas, si la substitution est supprimée ultérieurement et dans ce cas si une substitution est ajoutée ultérieurement.  
  
 Le `constrained` préfixe peut également servir pour l’appel de méthodes d’interface sur des types valeur, car la méthode de type valeur mise en œuvre de la méthode d’interface peut être changée à l’aide un `MethodImpl`. Si le `constrained` préfixe n’est pas utilisé, le compilateur est forcé de choisir les de la valeur de méthodes du type à lier au moment de la compilation. À l’aide de la `constrained` préfixe permet au code MSIL de la lier à la méthode qui implémente la méthode d’interface au moment de l’exécution, plutôt qu’au moment de la compilation.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `constrained` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D3|conv.i|Convertir en `native int`, exécution de type push `native int` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.i` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="int8" /> et l'étend (remplit) à <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|67|conv.i1|Convertir en `int8`, exécution de type push `int32` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.i1` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="int16" /> et l'étend (remplit) à <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|68|conv.i2|Convertir en `int16`, exécution de type push `int32` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.i2` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|69|conv.i4|Convertir en `int32`, exécution de type push `int32` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.i4` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|6 A|conv.i8|Convertir en `int64`, exécution de type push `int64` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.i8` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="native int" /> signé, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Convertir un `native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="native int" /> signé, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|8 A|conv.ovf.i.un|Convertit une valeur non signée à un `native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d’évaluation en <see langword="int8" /> signé et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Convertir un `int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i1` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="int8" /> signé et l'étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Convertit une valeur non signée à un `int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i1.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i1.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="int16" /> signé et l'étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|Convertir un `int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i2` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="int16" /> signé et l'étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Convertit une valeur non signée à un `int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i2.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i2.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="int32" /> signé, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Convertir un `int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i4` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="int32" /> signé, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Convertit une valeur non signée à un `int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i4.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i4.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="int64" /> signé, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|Convertir un `int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i8` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="int64" /> signé, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Convertit une valeur non signée à un `int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.i8.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i8.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="unsigned native int" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Convertir un `unsigned native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="unsigned native int" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|8 B|conv.ovf.u.un|Convertit valeur non signée en une `unsigned native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.uvf.u.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="unsigned int8" /> et l'étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|B4|conv.ovf.U1|Convertir un `unsigned int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u1` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="unsigned int8" /> et l'étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|86|conv.ovf.U1.un|Convertit une valeur non signée à un `unsigned int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u1.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u1.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="unsigned int16" /> et l'étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|B6|conv.ovf.U2|Convertir un `unsigned int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u2` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="unsigned int16" /> et l'étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|87|conv.ovf.U2.un|Convertit une valeur non signée à un `unsigned int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u2.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u2.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="unsigned int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|B8|conv.ovf.U4|Convertir un `unsigned int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u4` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="unsigned int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|88|conv.ovf.U4.un|Convertit une valeur non signée à un `unsigned int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u4.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u4.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur signée située en haut de la pile d'évaluation en <see langword="unsigned int64" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|BA|conv.ovf.U8|Convertir un `unsigned int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u8` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur non signée située en haut de la pile d'évaluation en <see langword="unsigned int64" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|89|conv.ovf.U8.un|Convertit une valeur non signée à un `unsigned int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée. En cas de dépassement de capacité, une exception est levée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.ovf.u8.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie. Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.  
  
 Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro. Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u8.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur entière non signée située en haut de la pile d'évaluation en <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|76|conv.r.un|Convert entier non signé à virgule flottante, en exécutant un push `F` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.r.un` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 Si le dépassement de capacité se produit la conversion d’un type à virgule flottante en entier la `result` retournée n’est pas spécifié. Le `conv.r.un` opération prend un entier de la pile, il interprète comme étant non signés et le remplace par un nombre à virgule flottante pour représenter l’entier : soit un `float32`, si c’est assez large pour représenter l’entier sans perte de précision, sans quoi un `float64`.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.r.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|6 B|conv.r4|Convertir en `float32`, exécution de type push `F` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.r4` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.r4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|6C|conv.r8|Convertir en `float64`, exécution de type push `F` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.r8` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.r8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="unsigned native int" /> et l'étend à <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|E0|conv.u|Convertir en `unsigned native int`, exécution de type push `native int` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.u` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="unsigned int8" /> et l'étend à <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D2|conv.U1|Convertir en `int8`, exécution de type push `int32` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.u1` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="unsigned int16" /> et l'étend à <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D1|conv.U2|Convertir en `int16`, exécution de type push `int32` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.u2` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="unsigned int32" /> et l'étend à <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|6D|conv.U4|Convertir en `unsigned int32`, exécution de type push `int32` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.u4` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la valeur située en haut de la pile d'évaluation en <see langword="unsigned int64" /> et l'étend à <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|6E|conv.U8|Convertir en `int64`, exécution de type push `int64` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et la conversion est tentée.  
  
3.  Si la conversion est réussie, la valeur résultante est placée sur la pile.  
  
 Le `conv.u8` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile. Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`). Les valeurs à virgule flottante sont converties en la `F` type.  
  
 Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro. Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue. Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné. Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués. Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.  
  
 En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.  
  
 Aucune exception n’est levée lors de l’utilisation de ce champ. Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copie un nombre d'octets spécifié d'une adresse source vers une adresse de destination.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Copier des données à partir d’un bloc de mémoire à un autre.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse de destination est placée sur la pile.  
  
2.  L’adresse source est placée sur la pile.  
  
3.  Le nombre d’octets à copier est placé sur la pile.  
  
4.  Le nombre d’octets, l’adresse source et l’adresse de destination est dépilé de la pile ; le nombre spécifié d’octets est copié à partir de l’adresse source à l’adresse de destination.  
  
 Le `cpblk` instruction copie un nombre (type `unsigned int32`) d’octets à partir d’une adresse source (de type `*`, `native int`, ou `&`) à une adresse de destination (de type `*`, `native int`, ou `&`). Le comportement de `cpblk` n’est pas spécifié si les zones source et de destination se chevauchent.  
  
 `cpblk` suppose que la source et la destination traités sont alignées avec la taille naturelle de l’ordinateur. Le `cpblk` instruction peut être immédiatement précédée par le `unaligned.<prefix>` pour indiquer que la source ou la destination n’est pas alignée.  
  
 L’opération de la `cpblk` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cpblk` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copie le type valeur situé à l'adresse d'un objet (type <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />) à l'adresse de l'objet de destination (type <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Copie un type valeur à partir d’un objet source vers un objet de destination.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La référence d’objet de destination est placée sur la pile.  
  
2.  La référence d’objet source est placée sur la pile.  
  
3.  Les deux références d’objet sont dépilés de la pile ; le type de valeur à l’adresse de l’objet source est copié à l’adresse de l’objet de destination.  
  
 Le comportement de `cpobj` n’est pas spécifié si la source et la destination de l’objet références ne sont pas des pointeurs vers des instances de la classe représentée par le jeton de la classe `classTok` (un `typeref` ou `typedef`), ou si `classTok` ne représente pas un type de valeur.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cpobj` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divise une valeur par une autre et exécute un push du résultat en tant que valeur à virgule flottante (type <see langword="F" />) ou quotient (type <see langword="int32" />) dans la pile.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|5 B|div|Divise deux valeurs pour retourner un quotient ou un résultat à virgule flottante.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est divisé par `value2`.  
  
4.  Le résultat est placé sur la pile.  
  
 `result` = `value1` value2 répond aux conditions suivantes :  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, et :  
  
 signe (`result`) = +, if signer (`value1`) = connexion (`value2`), ou-, si l’authentification (`value1`) ~ = connexion (`value2`)  
  
 La `div` instruction calcule le résultat et il exécute un push sur la pile.  
  
 Division d’entier tronque vers zéro.  
  
 Division d’un nombre fini par zéro produit la valeur infinie correctement signée.  
  
 La division de zéro par zéro ou l’infini par l’infini produit la valeur NaN (Not-A-Number). N’importe quel nombre divisé par l’infini produit une valeur de zéro.  
  
 Opérations intégrales lever <xref:System.ArithmeticException> si le résultat ne peut pas être représenté dans le type de résultat. Cela peut se produire si `value1` est la valeur négative maximale, et `value2` est -1.  
  
 Opérations intégrales lever <xref:System.DivideByZeroException> si `value2` est égal à zéro.  
  
 Notez que sur les plateformes Intel un <xref:System.OverflowException> est levée lors du calcul (minint div -1). Opérations à virgule flottante ne lèvent jamais d’exception (elles produisent NaN ou les valeurs infinies).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `div` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divise une valeur entière non signée par une autre et exécute un push du résultat (<see langword="int32" />) dans la pile.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|5C|div.un|Divise deux valeurs, non signés, retournant un quotient.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est divisé par `value2`.  
  
4.  Le résultat est placé sur la pile.  
  
 Le `div.un` instruction calcule `value1` divisé par `value2`, les deux étant pris en tant qu’entiers non signés et exécute un push le `result` sur la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `div.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copie la valeur actuelle la plus haute dans la pile d'évaluation et exécute un push de la copie dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|25|DUP|Duplique la valeur en haut de la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est expulsé de la pile pour la duplication.  
  
3.  `value` sont réinsérées dans la pile.  
  
4.  Une valeur en double est placée sur la pile.  
  
 La `dup` instruction duplique l’élément supérieur de la pile et laisse deux valeurs identiques au-dessus d’elle.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `dup` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère à nouveau le contrôle de la clause <see langword="filter" /> d'une exception au gestionnaire d'exceptions CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 11|endfilter|Clause de filtre de fin de la gestion des exceptions SEH.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est retirée de la pile ; `endfilter` est exécutée et le contrôle est transféré au gestionnaire d’exceptions.  
  
 `Value` (qui doit être de type `int32` et fait partie d’un ensemble spécifique de valeurs) est retournée à partir de la clause de filtre. Il doit s’agir de :  
  
-   `exception_continue_search` (`value` = 0) pour poursuivre la recherche pour un gestionnaire d’exceptions  
  
-   `exception_execute_handler` (`value` = 1) pour lancer la deuxième phase de gestion des exceptions où les blocs finally sont exécutés jusqu'à ce que le gestionnaire associé à cette clause de filtre se trouve. Lors de la découverte, le gestionnaire est exécuté.  
  
 D’autres valeurs entières produira des résultats non spécifiées.  
  
 Le point d’entrée d’un filtre, comme indiqué dans la table d’exceptions de la méthode, doit être la première instruction dans le bloc de code du filtre. Le `endfilter` instruction doit être la dernière instruction dans le bloc de code du filtre (par conséquent, il peut être seulement un `endfilter` pour chaque bloc de filtre). Après avoir exécuté la `endfilter` instruction, logiquement le flux de contrôle au mécanisme de gestion d’exceptions CLI.  
  
 Contrôle ne peut pas être transféré dans un bloc de filtre sauf via le mécanisme d’exception. Le contrôle ne peut pas être transféré en dehors d’un bloc de filtre à l’exception à l’aide d’un `throw` instruction ou en exécutant la dernière `endfilter` instruction. Vous ne pouvez pas incorporer un `try` bloquer dans un `filter` bloc. Si une exception est levée à l’intérieur de la `filter` bloc, elle est interceptée et la valeur 0 (`exception_continue_search`) est retournée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `endfilter` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfère à nouveau le contrôle de la clause <see langword="fault" /> ou <see langword="finally" /> d'un bloc d'exception au gestionnaire d'exceptions CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|Met fin à la `finally` ou `fault` clause d’un bloc d’exception.|  
  
 Il n’existe aucune pile de comportements de transition pour cette instruction.  
  
 `Endfinally` et `endfault` signaler la fin de la `finally` ou `fault` clause afin que le déroulement puisse continuer jusqu'à ce que le Gestionnaire d’exceptions est appelé. Le `endfinally` ou `endfault` instruction transfère le contrôle vers le mécanisme d’exception CLI. La recherche pour le prochain ensuite `finally` clause dans la chaîne si le bloc protégé a été fermé avec une instruction leave. Si le bloc protégé a été fermé avec une exception, l’interface CLI recherchera la prochaine `finally` ou `fault`, ou entrez le Gestionnaire d’exceptions au moment de la première passe de la gestion des exceptions.  
  
 Un `endfinally` instruction peut apparaître uniquement sur le plan lexical dans un `finally` bloc. Contrairement à la `endfilter` obtenir des instructions, il n’est pas nécessaire que le bloc se termine avec un `endfinally` instruction et peut avoir autant `endfinally` instructions au sein du bloc en fonction des besoins. Ces mêmes restrictions s’appliquent à la `endfault` instruction et le `fault` bloc.  
  
 Le contrôle ne peut pas être transféré dans un `finally` (ou `fault`) bloquer, sauf via le mécanisme d’exception. Contrôle ne peut pas être transféré hors d’un `finally` (ou `fault`) bloquer à l’exception à l’aide d’un `throw` instruction ou en exécutant la `endfinally` (ou `endfault`) instruction. En particulier, vous ne pouvez pas » se répartissent » d’un `finally` (ou `fault`) bloc ou d’exécuter un <xref:System.Reflection.Emit.OpCodes.Ret> ou <xref:System.Reflection.Emit.OpCodes.Leave> instruction dans un `finally` (ou `fault`) bloc.  
  
 Notez que le `endfault` et `endfinally` instructions sont des alias : ils correspondent au même opcode.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `endfinally` (`endfault`) opcode, ainsi que le `ILGenerator` méthode <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialise un bloc de mémoire spécifié situé à une adresse spécifique en utilisant une taille et une valeur initiale données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 18|initblk|Définir chaque emplacement dans un bloc de mémoire à une valeur donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse de début est placée sur la pile.  
  
2.  Une valeur d’initialisation est placée sur la pile.  
  
3.  Le nombre d’octets à initialiser est placé sur la pile.  
  
4.  Le nombre d’octets, la valeur d’initialisation et l’adresse de départ est dépilé et l’initialisation est exécutée conformément à leurs valeurs.  
  
 Le `initblk` instruction définit le nombre (`unsigned int32`) d’octets commençant à l’adresse spécifiée (de type `native int`, `&`, ou `*`) à la valeur d’initialisation (de type `unsigned int8`). `initblk` suppose que l’adresse de départ est alignée avec la taille naturelle de l’ordinateur.  
  
 L’opération de la `initblk` instructions peuvent être modifiées par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `initblk` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialise tous les champs du type de valeur figurant à l'adresse spécifiée en utilisant la référence null ou la valeur 0 du type primitif qui convient.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|Initialise un type valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse du type valeur à initialiser est placé sur la pile.  
  
2.  L’adresse est retirée de la pile ; le type de valeur à l’adresse spécifiée est initialisé en tant que type `typeTok`.  
  
 Le `initobj` instruction initialise chaque champ du type valeur spécifié par l’adresse envoyée (de type `native int`, `&`, ou `*`) à une référence null ou une valeur 0 du type primitif qui convient. Une fois que cette méthode est appelée, l’instance est prête pour une méthode de constructeur à appeler. Si `typeTok` est un type référence, cette instruction a le même effet que `ldnull` suivie `stind.ref`.  
  
 Contrairement aux <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` n’appelle pas la méthode de constructeur. `Initobj` est conçu pour l’initialisation des types valeur, tandis que `newobj` est utilisé pour allouer et initialiser des objets.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `initobj` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vérifie si une référence d'objet (type <see langword="O" />) est une instance d'une classe particulière.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Teste si une référence d’objet est une instance de `class`, retournant une référence null ou une instance de cette classe ou interface.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet est placée sur la pile.  
  
2.  La référence d’objet est dépilée et testée pour s’il s’agit d’une instance de la classe passée dans `class`.  
  
3.  Le résultat (une référence d’objet ou une référence null) est placé sur la pile.  
  
 `Class` est un jeton de métadonnées indiquant la classe souhaitée. Si la classe de l’objet en haut de la pile implémente `class` (si `class` est une interface) ou est une classe dérivée de `class` (si `class` est une classe normale), puis elle est convertie en type `class` et le résultat est ajoutée à la pile, exactement comme si <xref:System.Reflection.Emit.OpCodes.Castclass> avait été appelée. Sinon, une référence null est ajoutée à la pile. Si la référence d’objet est une référence null, alors `isinst` même retourne une référence null.  
  
 <xref:System.TypeLoadException> est levée si la classe est introuvable. Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `isinst` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quitte la méthode actuelle et passe à la méthode spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|Quitte la méthode actuelle et passer à la méthode spécifiée.|  
  
 Il n’existe aucune pile de comportements de transition pour cette instruction.  
  
 Le `jmp` (lien) instruction transfère le contrôle à la méthode spécifiée par `method`, qui est un jeton de métadonnées pour une référence de méthode. Les arguments actuels sont transférés à la méthode de destination.  
  
 La pile d’évaluation doit être vide lorsque cette instruction est exécutée. La convention d’appel, le nombre et le type d’arguments à l’adresse de destination doivent correspondre à celui de la méthode actuelle.  
  
 Le `jmp` ne peut pas être utilisée pour transférer le contrôle d’un `try`, `filter`, `catch`, ou `finally` bloc.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `jmp` opcode :  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge un argument (référencé par une valeur d’index spécifiée) dans la pile.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 09 &LT; `unsigned int16` >|ldarg `index`|Charge l’argument à `index` sur pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur d’argument à `index` est placé sur la pile.  
  
 Le `ldarg` push de l’argument indexé à `index`, où les arguments sont indexés à partir de 0, dans la pile d’évaluation. La `ldarg` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant. Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.  
  
 Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, le `ldarg` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature (voir la <xref:System.Reflection.Emit.OpCodes.Arglist> instruction pour plus d’informations).  
  
 Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg` opcode :  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'argument à l'index 0 dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|02|ldarg.0|Charge l’argument 0 dans la pile|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur d’argument à l’index 0 est placée sur la pile.  
  
 La `ldarg.0` instruction est un codage efficace pour charger la valeur d’argument à l’index 0.  
  
 La `ldarg.0` instruction exécute un push de l’argument indexé à 0 dans la pile d’évaluation. La `ldarg.0` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant. Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.  
  
 Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.0` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l’argument à l’index 1 dans la pile d’évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|03|ldarg.1|Charge l’argument 1 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur d’argument à l’index 1 est placée sur la pile.  
  
 La `ldarg.1` instruction est un codage efficace pour charger la valeur d’argument à l’index 1.  
  
 La `ldarg.1` instruction exécute un push de l’argument indexé à 1 dans la pile d’évaluation. La `ldarg.1` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant. Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.  
  
 Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l’argument à l’index 2 dans la pile d’évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|04|ldarg.2|Charge l’argument 2 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur d’argument à l’index 2 est placée sur la pile.  
  
 La `ldarg.2` instruction est un codage efficace pour charger la valeur d’argument à l’index 2.  
  
 La `ldarg.2` instruction exécute un push de l’argument indexé à 2 dans la pile d’évaluation. La `ldarg.2` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant. Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.  
  
 Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l’argument à l’index 3 dans la pile d’évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|05|ldarg.3|Charge l’argument 3 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur d’argument à l’index 3 est placée sur la pile.  
  
 La `ldarg.3` instruction est un codage efficace pour charger la valeur d’argument à l’index 3.  
  
 La `ldarg.3` instruction exécute un push de l’argument indexé à 3 dans la pile d’évaluation. La `ldarg.3` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant. Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.  
  
 Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.3` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'argument (référencé par un index sous la forme abrégée) dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0E &LT; `unsigned int8` >|ldarg.s `index`|Charge l’argument à `index` dans la pile, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur d’argument à `index` est placé sur la pile.  
  
 La `ldarg.s` instruction est un codage efficace pour charger les arguments indexés de 4 à 255.  
  
 Le `ldarg.s` push de l’argument indexé à `index`, où les arguments sont indexés à partir de 0, dans la pile d’évaluation. La `ldarg.s` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant. Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.  
  
 Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, le `ldarg.s` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature (voir la <xref:System.Reflection.Emit.OpCodes.Arglist> instruction pour plus d’informations).  
  
 Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.s` opcode :  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge une adresse d’argument dans la pile d’évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0 A FE &LT; `unsigned int16` >|ldarga `index`|Extrait l’adresse de l’argument indexé par `index`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse `addr` de l’argument indexé par `index` est placé sur la pile.  
  
 Le `ldarga` instruction extrait l’adresse (de type `*`) de l’argument indexé par `index`, où les arguments sont indexés à partir de 0. L’adresse `addr` est toujours aligné sur une frontière naturelle sur l’ordinateur cible.  
  
 Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, la `ldarga` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.  
  
 `ldarga` est utilisé pour le passage de paramètres par référence. Pour les autres cas, <xref:System.Reflection.Emit.OpCodes.Ldarg> et <xref:System.Reflection.Emit.OpCodes.Starg> doit être utilisé.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarga` opcode :  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge une adresse d'argument, sous la forme abrégée, dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|Extrait l’adresse de l’argument indexé par `index`, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse `addr` de l’argument indexé par `index` est placé sur la pile.  
  
 `ldarga.s` (la forme abrégée de `ldarga`) doit être utilisé pour les numéros d’arguments de 0 à 255 et constitue un encodage plus efficace.  
  
 Le `ldarga.s` instruction extrait l’adresse (de type`*`) de l’argument indexé par `index`, où les arguments sont indexés à partir de 0. L’adresse `addr` est toujours aligné sur une frontière naturelle sur l’ordinateur cible.  
  
 Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, la `ldarga.s` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.  
  
 `ldarga.s` est utilisé pour le passage de paramètres par référence. Pour les autres cas, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> et <xref:System.Reflection.Emit.OpCodes.Starg_S> doit être utilisé.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarga.s` opcode :  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'une valeur fournie de type <see langword="int32" /> dans la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|Exécute un push de la valeur `num` dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur `num` est placé sur la pile.  
  
 Notez qu’il n’y a les encodages abrégés (et donc plus efficaces) spéciaux pour les entiers -128 à 127 et particulièrement-1 à 8. Tous les encodages abrégés push des entiers de 4 octets dans la pile. Les codages plus longs sont utilisés pour les entiers de 8 octets et 4 et 8 nombres à virgule flottante octets, ainsi que les valeurs de 4 octets qui ne tiennent pas dans les formes abrégées. Il existe trois façons pour transmettre une constante entière de 8 octets dans la pile  
  
 1. Utilisez la <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction pour les constantes doivent être exprimées en plus de 32 bits.  
  
 2. Utilisez le <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction suivie d’un <xref:System.Reflection.Emit.OpCodes.Conv_I8> pour les constantes qui requièrent de 9 à 32 bits.  
  
 3. Utilisez une instruction de forme abrégée suivie d’un <xref:System.Reflection.Emit.OpCodes.Conv_I8> pour les constantes qui peuvent être exprimées en moins de 8 bits.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4` opcode :  
  
-   ILGenerator.Emit (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push de la valeur entière 0 dans la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Exécute un push de 0 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 0 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.0` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 1 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Exécute un push de 1 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 1 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 2 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Exécute un push de 2 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 2 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 3 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Exécute un push de 3 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 3 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.3` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 4 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|1 A|ldc.i4.4|Exécute un push de 4 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 4 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 5 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|1 B|ldc.i4.5|Exécute un push de 5 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 5 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.5` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 6 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Exécute un push de 6 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 6 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.6` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 7 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Exécute un push de 7 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 7 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.7` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière 8 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Exécute un push de 8 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur 8 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un envoi (push) de la valeur entière -1 dans la pile d’évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|15|ldc.i4.M1|Exécute un push de -1 dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur -1 est placée sur la pile.  
  
 Voici une courte un codage spécial pour le push de la valeur entière 0. Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.m1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push de la valeur fournie <see langword="int8" /> dans la pile d'évaluation en tant que <see langword="int32" /> (forme abrégée).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|Exécute un push `num` dans la pile en tant que `int32`, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur `num` est placé sur la pile.  
  
 `ldc.i4.s` est un encodage plus efficace pour pousser les entiers de -128 à 127 dans la pile d’évaluation.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.s` opcode :  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'une valeur fournie de type <see langword="int64" /> dans la pile d'évaluation en tant que <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|Exécute un push `num` dans la pile en tant que `int64`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur `num` est placé sur la pile.  
  
 Cet encodage exécute un push d’un `int64` valeur sur la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i8` opcode :  
  
-   ILGenerator.Emit (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'une valeur fournie de type <see langword="float32" /> dans la pile d'évaluation en tant que type <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|Exécute un push `num` dans la pile en tant que `F`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur `num` est placé sur la pile.  
  
 Cet encodage exécute un push d’un `float32` valeur sur la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.r4` opcode :  
  
-   ILGenerator.Emit (OpCode, unique)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'une valeur fournie de type <see langword="float64" /> dans la pile d'évaluation en tant que type <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|Exécute un push `num` dans la pile en tant que `F`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur `num` est placé sur la pile.  
  
 Cet encodage exécute un push d’un `float64` valeur sur la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.r8` opcode :  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément à un index de tableau spécifié en haut de la pile d'évaluation en tant que type spécifié par l'instruction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|A3 &LT; `T` >|ldelem `typeTok`|Charge l’élément à `index` en haut de la pile en tant que type `typeTok`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 Le type de la valeur de retour est spécifié par le jeton `typeTok` dans l’instruction.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite supérieure de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="native int" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|97|ldelem.i|Charge l’élément avec le type `native int` à `index` en haut de la pile en tant qu’un `native int`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.i` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.i` est `native int`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="int8" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Charge l’élément avec le type `int8` à `index` en haut de la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.i1` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.i1` est `int8`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="int16" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|92|ldelem.i2|Charge l’élément avec le type `int16` à `index` en haut de la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.i2` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.i2` est `int16`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="int32" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Charge l’élément avec le type `int32` à `index` en haut de la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.i4` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.i4` est `int32`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="int64" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|96|ldelem.i8|Charge l’élément avec le type `int64` à `index` en haut de la pile en tant qu’un `int64`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.i8` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.i8` est `int64`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="float32" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que type <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|98|ldelem.r4|Charge l’élément avec le type `float32` à `index` en haut de la pile en tant que type `F`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.r4` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.r4` est `float32`.  
  
 Valeurs à virgule flottante sont convertis en type `F` lors du chargement dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.r4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="float64" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que type <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|99|ldelem.r8|Charge l’élément avec le type `float64` à `index` en haut de la pile en tant que type `F`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.r8` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.r8` est `float64`.  
  
 Valeurs à virgule flottante sont convertis en type `F` lors du chargement dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.r8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément contenant une référence d'objet à un index de tableau spécifié en haut de la pile d'évaluation en tant que type <see langword="O" /> (référence d'objet).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|9 A|ldelem.ref|Charge l’élément avec une référence d’objet à `index` en haut de la pile en tant que type `O`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.ref` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.ref` est de type `O` (référence d’objet).  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.ref` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="unsigned int8" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|91|ldelem.U1|Charge l’élément avec le type `unsigned int8` à `index` en haut de la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.u1` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.u1` est `int8`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.u1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="unsigned int16" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|93|ldelem.U2|Charge l’élément avec le type `unsigned int16` à index en haut de la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.u2` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.u2` est `int16`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.u2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'élément avec le type <see langword="unsigned int32" /> à un index de tableau spécifié en haut de la pile d'évaluation en tant que <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|95|ldelem.U4|Charge l’élément avec le type `unsigned int32` à index en haut de la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.  
  
4.  La valeur est envoyée à la pile.  
  
 Le `ldelem.u4` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.  
  
 La valeur de retour pour `ldelem.u4` est `int32`.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si le tableau ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.u4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'adresse de l'élément de tableau situé à un index de tableau spécifié en haut de la pile d'évaluation en tant que type <see langword="&amp;" /> (pointeur managé).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|Charge l’adresse de l’élément de tableau à `index` en haut de la pile d’évaluation en tant que type `&` (pointeur managé).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `array` est placé sur la pile.  
  
2.  Une valeur d’index `index` est placé sur la pile.  
  
3.  `index` et `array` sont dépilés ; l’adresse stockée à la position `index` dans `array` est recherché.  
  
4.  L’adresse est placé sur la pile.  
  
 Le `ldelema` est utilisé pour récupérer l’adresse d’un objet à un index particulier dans un tableau d’objets (de type `class`). Le `ldelema` instruction charge l’adresse de la valeur à l’index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile. Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. La valeur doit être de type `class` passé avec l’instruction.  
  
 La valeur de retour pour `ldelema` est un pointeur managé (type `&`).  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelema` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recherche la valeur d'un champ dans l'objet dont la référence est actuellement située dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|7 B &LT; `T` >|ldfld `field`|Exécute un push de la valeur d’un champ dans un objet spécifié dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet (ou pointeur) est placé sur la pile.  
  
2.  La référence d’objet (ou pointeur) est retirée de la pile ; la valeur du champ spécifié dans l’objet est trouvée.  
  
3.  La valeur stockée dans le champ est placée sur la pile.  
  
 La `ldfld` instruction exécute un push de la valeur d’un champ situé dans un objet dans la pile. L’objet doit se trouver sur la pile en tant que référence d’objet (type `O`), un pointeur managé (type `&`), un pointeur non managé (type `native int`), un pointeur transitoire (type `*`), ou une instance d’un type valeur. L’utilisation d’un pointeur non managé n’est pas autorisée dans du code vérifiable. Champ de l’objet est spécifié par un jeton de métadonnées qui doit faire référence à un membre de champ. Le type de retour est identique à celui associé au champ. Le champ peut être un champ d’instance (auquel cas l’objet ne doit pas être une référence null) ou un champ statique.  
  
 Le `ldfld` instruction peut être précédée d’une des deux le <xref:System.Reflection.Emit.OpCodes.Unaligned> et <xref:System.Reflection.Emit.OpCodes.Volatile> préfixes.  
  
 <xref:System.NullReferenceException> est levée si l’objet est null et que le champ n’est pas statique.  
  
 <xref:System.MissingFieldException> est levée si le champ spécifié est introuvable dans les métadonnées. Cette option est généralement activée lorsque des instructions de langage MSIL (Microsoft Intermediate Language) en code natif, pas en cours d’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldfld` opcode :  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recherche l'adresse d'un champ dans l'objet dont la référence est actuellement située dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Exécute un push de l’adresse de `field` dans un objet spécifié dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet (ou pointeur) est placé sur la pile.  
  
2.  La référence d’objet (ou pointeur) est retirée de la pile ; l’adresse du champ spécifié dans l’objet est trouvé.  
  
3.  L’adresse du champ spécifié est placé sur la pile.  
  
 La `ldflda` instruction exécute un push de l’adresse d’un champ situé dans un objet dans la pile. L’objet doit se trouver sur la pile en tant que référence d’objet (type `O`), un pointeur managé (type `&`), un pointeur non managé (type `native int`), un pointeur transitoire (type `*`), ou une instance d’un type valeur. L’utilisation d’un pointeur non managé n’est pas autorisée dans du code vérifiable. Champ de l’objet est spécifié par un jeton de métadonnées qui doit faire référence à un membre de champ.  
  
 La valeur retournée par `ldflda` est un pointeur managé (type `&`), sauf si l’objet est placé sur la pile en tant que pointeur non managé, auquel cas l’adresse de retour est également un pointeur non managé (type `native int`).  
  
 Le `ldflda` instruction peut être précédée d’une des deux le <xref:System.Reflection.Emit.OpCodes.Unaligned> et <xref:System.Reflection.Emit.OpCodes.Volatile> préfixes.  
  
 <xref:System.InvalidOperationException> est levée si l’objet n’est pas dans le domaine d’application à partir de laquelle il est accessible. L’adresse d’un champ qui n’est pas dans le domaine d’application accès ne peut pas être chargé.  
  
 <xref:System.NullReferenceException> est levée si l’objet est null et que le champ n’est pas statique.  
  
 <xref:System.MissingFieldException> est levée si le champ spécifié est introuvable dans les métadonnées. Cette option est généralement activée lorsque des instructions de langage MSIL (Microsoft Intermediate Language) en code natif, pas en cours d’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldflda` opcode :  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'un pointeur non managé (type <see langword="native int" />) sur le code natif implémentant une méthode spécifique dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 06 &LT; `T` >|ldftn `method`|Exécute un push d’un pointeur vers une méthode référencée par `method` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Le pointeur non managé vers une méthode spécifique est envoyé à la pile.  
  
 La méthode spécifique (`method`) peut être appelée à l’aide de la <xref:System.Reflection.Emit.OpCodes.Calli> instruction si elle fait référence à une méthode managée (ou un stub qui effectue la transition à partir de code non managé).  
  
 La valeur retournée de points de code natif à l’aide de la convention d’appel de CLR. Ce pointeur de la méthode ne doit pas être passé au code natif non managé comme une routine de rappel.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldftn` opcode :  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="native int" /> en tant que <see langword="native int" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|4D|ldind.i|Charge le `native int` valeur à l’adresse `addr` dans la pile en tant qu’un `native int`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.i` instruction charge indirectement une `native int` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `native int`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="int8" /> en tant que <see langword="int32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|46|ldind.i1|Charge le `int8` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile...  
  
 Le `ldind.i1` instruction charge indirectement une `int8` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `int32`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="int16" /> en tant que <see langword="int32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|48|ldind.i2|Charge le `int16` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.i2` instruction charge indirectement une `int16` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `int32`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="int32" /> en tant que <see langword="int32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|4 A|ldind.i4|Charge le `int32` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.i4` instruction charge indirectement une `int32` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `int32`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="int64" /> en tant que <see langword="int64" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|4C|ldind.i8|Charge le `int64` valeur à l’adresse `addr` dans la pile en tant qu’un `int64`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.i8` instruction charge indirectement une `int64` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `int64`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="float32" /> en tant que type <see langword="F" /> (float) dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|4E|ldind.r4|Charge le `float32` valeur à l’adresse `addr` dans la pile en tant que type `F`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.r4` instruction charge indirectement une `float32` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant que type `F`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.r4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="float64" /> en tant que type <see langword="F" /> (float) dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|4F|ldind.r8|Charge le `float64` valeur à l’adresse `addr` dans la pile en tant que type `F`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.r8` instruction charge indirectement une `float64` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `float64`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.r8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une référence d'objet en tant que type <see langword="O" /> (référence d'objet) dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|50|ldind.ref|Charge la référence d’objet à l’adresse `addr` dans la pile en tant que type `O`|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la référence d’objet située à l’adresse est extraite.  
  
3.  La référence extraite est placée sur la pile.  
  
 Le `ldind.ref` instruction charge indirectement la référence d’objet l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant que type `O`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.ref` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="unsigned int8" /> en tant que <see langword="int32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|47|ldind.U1|Charge le `unsigned int8` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.u1` instruction charge indirectement une `unsigned int8` valeur à partir de l’adresse spécifiée (de type`native int`, `&`, ou *) dans la pile en tant qu’un `int32`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.u1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="unsigned int16" /> en tant que <see langword="int32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|49|ldind.U2|Charge le `unsigned int16` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.u2` instruction charge indirectement une `unsigned int16` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `int32`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.u2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge indirectement une valeur de type <see langword="unsigned int32" /> en tant que <see langword="int32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|4 B|ldind.U4|Charge le `unsigned int32` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.  
  
3.  La valeur récupérée est placée sur la pile.  
  
 Le `ldind.u4` instruction charge indirectement une `unsigned int32` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou *) dans la pile en tant qu’un `int32`.  
  
 Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.  
  
 Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation. Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.  
  
 Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.  
  
 L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe). Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité. Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible. Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.  
  
 <xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.u4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push du nombre d'éléments d'un tableau unidimensionnel de base zéro dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|8E|ldlen|Exécute un push de la longueur (de type `natural unsigned int`) d’un tableau sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet à un tableau est placée sur la pile.  
  
2.  La référence de tableau est dépilée et la longueur est calculée.  
  
3.  La longueur est placée sur la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. La longueur est retournée en tant qu’un `natural unsigned int`.  
  
 <xref:System.NullReferenceException> est levé si la référence de tableau est une référence null.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldlen` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge la variable locale à un index spécifique dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 0C &LT; `unsigned int16` >|ldloc `index`|Charge la variable locale à l’index `index` sur pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur de variable locale à l’index spécifié est placée sur la pile.  
  
 La `ldloc` instruction exécute un push le contenu de la variable locale à l’index passé dans la pile d’évaluation, où les variables locales sont numérotées à partir de 0. Variables locales sont initialisées à 0 avant d’entrer la méthode uniquement si l’indicateur d’initialisation sur la méthode a la valeur true. Il existe 65 535 (2 ^ 16 - 1) variables locales possibles (0-65 534). L’index 65 535 n’est pas valide, car les implémentations éventuelles utiliseront un entier de 2 octets pour effectuer le suivi à la fois un index de variable locale, ainsi que le nombre total de variables locales pour une méthode donnée. Si un index 65 535 avait été rendu valide, un entier plus large pour suivre le nombre de variables locales dans une telle méthode serait nécessaire.  
  
 Le `ldloc.0`, `ldloc.1`, `ldloc.2`, et `ldloc.3` fournissent un codage efficace pour l’accès aux quatre premières variables locales.  
  
 Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode. Consultez Partition I. Local variables qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `ldloc` opcode :  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge la variable locale à l'index 0 dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|06|ldloc.0|Charge la variable locale à l'index 0 dans la pile d'évaluation.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur de variable locale à l’index 0 est placée sur la pile.  
  
 `ldloc.0` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 0.  
  
 Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode. Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.0` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge la variable locale à l'index 1 dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|07|ldloc.1|Charge la variable locale à l'index 1 dans la pile d'évaluation.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur de variable locale à l’index 1 est placée sur la pile.  
  
 `ldloc.1` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 1.  
  
 Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode. Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge la variable locale à l'index 2 dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|08|ldloc.2|Charge la variable locale à l'index 2 dans la pile d'évaluation.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur de variable locale à l’index 2 est placée sur la pile.  
  
 `ldloc.2` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 2.  
  
 Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode. Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge la variable locale à l'index 3 dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|09|ldloc.3|Charge la variable locale à l'index 3 dans la pile d'évaluation.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur de variable locale à l’index 3 est placée sur la pile.  
  
 `ldloc.3` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 3.  
  
 Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode. Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.3` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge la variable locale à un index spécifique dans la pile d'évaluation (forme abrégée).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Charge la variable locale à l’index `index` dans la pile, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur de variable locale à l’index spécifié est placée sur la pile.  
  
 La `ldloc.s` instruction exécute un push le contenu de la variable locale à l’index passé dans la pile d’évaluation, où les variables locales sont numérotées à partir de 0. Variables locales sont initialisées à 0 avant d’entrer la méthode si l’indicateur d’initialisation sur la méthode a la valeur true. Il existe 256 (2 ^ 8) variables locales possibles (0-255) sous la forme abrégée, qui est un encodage plus efficace que `ldloc`.  
  
 Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode. Consultez Partition I. Local variables qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile. Valeurs à virgule flottante sont étendues à leur taille native (type `F`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `ldloc.s` opcode :  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'adresse de la variable locale à un index spécifique dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Charge l’adresse de la variable locale à `index` dans la pile d’évaluation.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse stockée dans la variable locale à l’index spécifié est placé sur la pile.  
  
 Le `ldloca` push de l’adresse de la variable locale à l’index passé dans la pile, où les variables locales sont numérotées à partir de 0. La valeur ajoutée à la pile est déjà correctement alignée pour une utilisation avec des instructions telles que <xref:System.Reflection.Emit.OpCodes.Ldind_I> et <xref:System.Reflection.Emit.OpCodes.Stind_I>. Le résultat est un pointeur transitoire (type `*`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloca` opcode :  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Charge l'adresse de la variable locale à un index spécifique dans la pile d'évaluation (forme abrégée).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Charge l’adresse de la variable locale à `index` dans la pile d’évaluation, la forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse stockée dans la variable locale à l’index spécifié est placé sur la pile.  
  
 Le `ldloca.s` push de l’adresse de la variable locale à l’index passé dans la pile, où les variables locales sont numérotées à partir de 0. La valeur ajoutée à la pile est déjà correctement alignée pour une utilisation avec des instructions telles que <xref:System.Reflection.Emit.OpCodes.Ldind_I> et <xref:System.Reflection.Emit.OpCodes.Stind_I>. Le résultat est un pointeur transitoire (type `*`).  
  
 La `ldloca.s` instruction fournit un codage efficace pour une utilisation avec les variables locales de 0 à 255.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloca.s` opcode :  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'une référence null (type <see langword="O" />) dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|14|ldnull|transmettre une référence null dans la pile|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet null est placée sur la pile.  
  
 `ldnull` exécute un push d’une référence null (type `O`) sur la pile. Cela est utilisé pour initialiser les emplacements avant de les remplir avec des données, ou lorsqu’ils sont déconseillés.  
  
 `ldnull` Fournit une référence null est indépendante de la taille.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldnull` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copie l'objet de type de valeur sur lequel pointe une adresse en haut de la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Copie une instance du type de valeur `class` à la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse d’un objet de type valeur est envoyée à la pile.  
  
2.  L’adresse est dépilée et l’instance à l’adresse spécifique est recherchée.  
  
3.  La valeur de l’objet stocké à cette adresse est placée sur la pile.  
  
 La `ldobj` instruction est utilisée pour passer un type valeur en tant que paramètre.  
  
 Le `ldobj` instruction copie la valeur vers laquelle pointée `addrOfValObj` (de type `&`, `*`, ou `native int`) vers le haut de la pile. Le nombre d’octets copiés dépend de la taille de la classe (comme spécifié par le `class` paramètre). Le `class` paramètre est un jeton de métadonnées représentant le type de valeur.  
  
 L’opération de la `ldobj` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.TypeLoadException> est levée si la classe est introuvable. Cela est généralement détectée lors de l’instruction de langage MSIL (Microsoft Intermediate Language) est convertie en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldobj` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push de la valeur d’un champ static dans la pile d’évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|7E &LT; `T` >|ldsfld `field`|Exécute un push de `field` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur du champ spécifique est envoyée à la pile.  
  
 La `ldsfld` instruction exécute un push de la valeur de statique (partagé entre toutes les instances d’une classe) champ sur la pile. Le type de retour est celui associé au jeton de métadonnées passé `field`.  
  
 Le `ldsfld` instruction peut avoir un <xref:System.Reflection.Emit.OpCodes.Volatile> préfixe.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldsfld` opcode :  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push de l’adresse d’un champ static dans la pile d’évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|Push de l’adresse de `field` sur la pile|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  L’adresse d’un champ spécifique est envoyée à la pile.  
  
 La `ldsflda` instruction exécute un push de l’adresse de statique (partagé entre toutes les instances d’une classe) champ sur la pile. L’adresse peut être représenté comme un pointeur transitoire (type `*`) si le jeton de métadonnées `field` fait référence à un type dont la mémoire est gérée. Sinon, elle correspond à un pointeur non managé (type `native int`). Notez que `field` peut être de type statique global avec une adresse virtuelle relative assignée (l’offset du champ de l’adresse de base à laquelle le fichier PE conteneur est chargé en mémoire) où la mémoire n’est pas gérée.  
  
 Le `ldsflda` instruction peut avoir un <xref:System.Reflection.Emit.OpCodes.Volatile> préfixe.  
  
 <xref:System.MissingFieldException> est levée si le champ est introuvable dans les métadonnées. Cette option est généralement activée lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, pas lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldsflda` opcode :  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'une nouvelle référence d'objet à un littéral de chaîne stocké dans les métadonnées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Exécute un push d’un objet de chaîne pour le jeton de chaîne de métadonnées `mdToken`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet en une chaîne est placée sur la pile.  
  
 Le `ldstr` instruction exécute un push d’une référence d’objet (type `O`) vers un nouvel objet de chaîne qui représente le littéral de chaîne spécifique stocké dans les métadonnées. La `ldstr` instruction alloue la quantité de mémoire requise et exécute toute conversion de format nécessaire pour convertir le littéral de chaîne du format utilisé dans le fichier au format de chaîne requis lors de l’exécution.  
  
 Le Common Language Infrastructure (CLI) garantit que le résultat de deux `ldstr` instructions faisant référence à deux jetons de métadonnées ayant la même séquence de caractères retournent précisément le même objet chaîne (processus appelé « centralisation des chaînes »).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldstr` opcode :  
  
-   ILGenerator.Emit (OpCode, chaîne)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit un jeton de métadonnées en sa représentation runtime et exécute un push de cette représentation dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D0 &LT; `T` >|ldtoken `token`|Convertit un jeton de métadonnées en sa représentation sous forme de runtime.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Le jeton passé est converti en un `RuntimeHandle` et la pile.  
  
 Le `ldtoken` instruction push un `RuntimeHandle` pour le jeton de métadonnées spécifié. Un `RuntimeHandle` peut être un `fieldref/fielddef`, un `methodref/methoddef`, ou un `typeref/typedef`.  
  
 La valeur ajoutée à la pile peut être utilisée dans les appels à `Reflection` méthodes dans la bibliothèque de classes système.  
  
 Pour plus d’informations sur les handles runtime, consultez les classes suivantes : <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, et <xref:System.RuntimeMethodHandle>.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `ldtoken` opcode :  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'un pointeur non managé (type <see langword="native int" />) sur le code natif implémentant une méthode virtuelle spécifique associée à un objet spécifié dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 07 &LT; `T` >|ldvirtftn `method`|Exécute un push le pointeur à la méthode virtuelle d’un objet `method` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet est placée sur la pile.  
  
2.  La référence d’objet est dépilée de la pile et l’adresse du point d’entrée à la méthode (comme spécifié par le jeton de métadonnées `method`) est recherché.  
  
3.  Le pointeur vers `method` est placé sur la pile.  
  
 Le pointeur non managé qui en résulte est envoyée à la pile par le `ldvirtftn` instruction peut être appelée à l’aide de la <xref:System.Reflection.Emit.OpCodes.Calli> instruction si elle fait référence à une méthode managée (ou un stub qui effectue la transition à partir de code non managé).  
  
 Le pointeur non managé pointe vers le code natif à l’aide de la convention d’appel de CLR. Ce pointeur de la méthode ne doit pas être passé au code natif non managé comme une routine de rappel.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldvirtftn` opcode :  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quitte une région de code protégée, en transférant le contrôle à une instruction cible spécifique de manière non conditionnelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|DD &LT; `int32` >|Laissez le champ `target`|Quitte une région de code protégée.|  
  
 Il n’existe aucun comportement de transition de pile spécifié pour cette instruction.  
  
 La `leave` instruction transfère sans condition le contrôle à l’instruction cible spécifique, représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Le `leave` instruction est identique à la `br` instruction, mais il peut être utilisé pour quitter une `try`, `filter`, ou `catch` bloquer tandis que les instructions de branche ordinaire peuvent uniquement être utilisées dans ce type de bloc pour transférer le contrôle Il. Le `leave` instruction vide la pile d’évaluation et garantit que l’approprié qui entoure `finally` blocs sont exécutés.  
  
 Vous ne pouvez pas utiliser un `leave` instruction pour quitter un `finally` bloc. Pour faciliter la génération de code pour les gestionnaires d’exception qu’il est valide à partir d’un bloc catch à utiliser un `leave` instruction pour transférer le contrôle à une instruction dans associé `try` bloc.  
  
 Si une instruction contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré vers le premier de ces préfixes.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `leave` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quitte une région de code protégée, en transférant le contrôle à une instruction cible (forme abrégée) de manière non conditionnelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|ALLEMAGNE &LT; `int8` >|leave.s `target`|Quitte une région protégée du code, forme abrégée.|  
  
 Il n’existe aucun comportement de transition de pile spécifié pour cette instruction.  
  
 La `leave.s` instruction transfère sans condition le contrôle à l’instruction cible passée, représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.  
  
 Le `leave.s` instruction est identique à la `br` instruction, mais il peut être utilisé pour quitter une `try`, `filter`, ou `catch` bloquer tandis que les instructions de branche ordinaire peuvent uniquement être utilisées dans ce type de bloc pour transférer le contrôle Il. Le `leave.s` instruction vide la pile d’évaluation et garantit que l’approprié qui entoure `finally` blocs sont exécutés.  
  
 Vous ne pouvez pas utiliser un `leave.s` instruction pour quitter un `finally` bloc. Pour faciliter la génération de code pour les gestionnaires d’exception qu’il est valide à partir d’un bloc catch à utiliser un `leave.s` instruction pour transférer le contrôle à une instruction dans associé `try` bloc.  
  
 Si une instruction contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré vers le premier de ces préfixes.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `leave.s` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Alloue un certain nombre d'octets à partir du pool de mémoires dynamique local et exécute un push de l'adresse (pointeur transitoire, type <see langword="*" />) du premier octet alloué dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Allouer de l’espace à partir du tas local.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Le nombre d’octets à allouer est placé sur la pile.  
  
2.  Le nombre d’octets est retirée de la pile ; une quantité de mémoire correspondant à la taille est allouée à partir du tas local.  
  
3.  Un pointeur vers le premier octet de la mémoire allouée est placé sur la pile.  
  
 Le `localloc` alloue de l’instruction `size` (type `natural unsigned int`) octets à partir de la mémoire dynamique locale du pool et retourne l’adresse (pointeur transitoire, type `*`) du premier octet alloué. Le bloc de mémoire retourné est initialisé à 0 uniquement si l’indicateur d’initialisation sur la méthode est `true`. Lorsque la méthode actuelle exécute un <xref:System.Reflection.Emit.OpCodes.Ret>, le pool de mémoire local devient disponible pour une réutilisation.  
  
 L’adresse obtenue est alignée afin que n’importe quel type de données primitif puisse y être stocké à l’aide de la `stind` instructions (comme <xref:System.Reflection.Emit.OpCodes.Stind_I4>) et chargé à l’aide la `ldind` instructions (comme <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 Le `localloc` instruction ne peut pas se produire dans un `filter`, `catch`, `finally`, ou `fault` bloc.  
  
 <xref:System.StackOverflowException> est levée si la mémoire est insuffisante pour traiter la demande.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `localloc` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push d'une référence typée à une instance d'un type spécifique dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|Exécute un push d’une référence typée de type `class` dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Un pointeur vers l’élément de données est placé sur la pile.  
  
2.  Le pointeur est dépilé et converti en une référence typée de type `class`.  
  
3.  La référence typée est placée sur la pile.  
  
 La `mkrefany` instruction prend en charge le passage de références typées dynamiquement. Le pointeur doit être de type `&`, `*`, ou `native int`et contenir l’adresse valide d’un élément de données. `Class` est-ce que le jeton de classe décrivant le type des données référencées par le pointeur. `Mkrefany` exécute un push d’une référence typée dans la pile, en fournissant un descripteur opaque du pointeur et le type `class`.  
  
 L’opération valide uniquement autorisée sur une référence typée consiste à passer à une méthode qui requiert une référence typée en tant que paramètre. L’appelé peut ensuite utiliser le <xref:System.Reflection.Emit.OpCodes.Refanytype> et <xref:System.Reflection.Emit.OpCodes.Refanyval> des instructions pour récupérer respectivement le type (classe) et l’adresse.  
  
 <xref:System.TypeLoadException> est levée si `class` est introuvable. Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mkrefany` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplie deux valeurs et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|5 A|mul|Multiplie deux valeurs sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est multipliée par `value2`.  
  
4.  Le résultat est placé sur la pile.  
  
 Le `mul` instruction multiplie `value1` par `value2` et pousse le résultat sur la pile. Opérations sur les entiers tronquent en silence les bits de poids fort de dépassement de capacité.  
  
 Consultez <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> pour un entier spécifique multiplier opération avec gestion de dépassement de capacité.  
  
 Pour les types à virgule flottante, 0 * infini = NaN.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mul` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplie deux valeurs entières, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Multiplie deux valeurs entières sur la pile avec une vérification de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est multipliée par `value2`, avec une vérification de dépassement de capacité.  
  
4.  Le résultat est placé sur la pile.  
  
 Le `mul.ovf` instruction multiplie entier `value1` par entier `value2` et pousse le résultat sur la pile. Une exception est levée si le résultat ne tient pas dans le type de résultat.  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mul.ovf` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplie deux valeurs entières non signées, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Multiplie deux valeurs non signées sur la pile avec une vérification de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value1` est multipliée par `value2`, avec une vérification de dépassement de capacité.  
  
4.  Le résultat est placé sur la pile.  
  
 Le `mul.ovf.un` instruction multiplie l’entier non signé `value1` en entier non signé `value2` et pousse le résultat sur la pile. Une exception est levée si le résultat ne tient pas dans le type de résultat.  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mul.ovf.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Met en négatif une valeur et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|65|neg|Inverse la valeur actuellement située en haut de la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est envoyée à la pile.  
  
2.  Une valeur est dépilée et négatif.  
  
3.  Le résultat est placé sur la pile.  
  
 La `neg` instruction rend négative la valeur et exécute un push du résultat en haut de la pile. Le type de retour est le même type que l’opérande.  
  
 La négation de valeurs intégrales est standard du complément à deux négation. En particulier, annulant ainsi le plus grand nombre négatif (qui n’a pas un équivalent positif) produit le plus grand nombre négatif. Pour détecter ce dépassement de capacité, utilisez la <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction à la place (autrement dit, la soustraction de 0).  
  
 La négation d’un nombre à virgule flottante ne peut pas dépassement de capacité et la négation NaN retourne NaN.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `neg` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push dans la pile d'évaluation sur une référence d'objet à un nouveau tableau unidimensionnel de base zéro dont les éléments sont d'un type spécifique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|8D &LT; `T` >|newarr `etype`|Crée un nouveau tableau avec des éléments de type `etype`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Le nombre d’éléments dans le tableau est placé sur la pile.  
  
2.  Le nombre d’éléments est retirée de la pile et le tableau est créé.  
  
3.  Une référence d’objet au nouveau groupe est placée sur la pile.  
  
 Le `newarr` instruction exécute un push d’une référence d’objet (type `O`) vers un nouveau tableau unidimensionnel de base zéro dont les éléments sont de type `etype` (un jeton de métadonnées décrivant le type). Le nombre d’éléments dans le nouveau tableau doit être spécifié comme un `native int`. Plage d’index de tableau valide compris entre zéro et le nombre maximal d’éléments moins 1.  
  
 Les éléments d’un tableau peuvent être n’importe quel type, y compris les types de valeur.  
  
 Tableaux unidimensionnels de base zéro de nombres sont créés à l’aide d’un jeton de métadonnées référencent le type de valeur appropriée (<xref:System.Int32>, et ainsi de suite). Éléments du tableau sont initialisés à 0 du type approprié.  
  
 Tableaux unidimensionnels de base et les tableaux multidimensionnels sont créés à l’aide de <xref:System.Reflection.Emit.OpCodes.Newobj> plutôt que `newarr`. En général, ils sont créés à l’aide des méthodes de la <xref:System.Array> classe dans le .NET Framework.  
  
 <xref:System.OutOfMemoryException> est levée si la mémoire est insuffisante pour satisfaire la requête.  
  
 <xref:System.OverflowException> est levée si `numElems` est inférieur à 0.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `newarr` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Crée un nouvel objet ou une nouvelle instance d'un type valeur, en exécutant un push d'une référence d'objet (type <see langword="O" />) dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Alloue un type valeur ou un objet non initialisé et appelle la méthode de constructeur `ctor`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Arguments `arg1` via `argn` sont envoyées sur la pile dans la séquence.  
  
2.  Arguments `argn` via `arg1` sont dépilés et passés à `ctor` pour la création d’objets.  
  
3.  Une référence au nouvel objet est placée sur la pile.  
  
 La `newobj` instruction crée un nouvel objet ou une nouvelle instance d’un type valeur. `Ctor` est un jeton de métadonnées (un `methodref` ou `methoddef` qui doit être marquée en tant que constructeur) qui indique le nom, la classe et la signature du constructeur à appeler.  
  
 Le `newobj` instruction alloue une nouvelle instance de la classe associée `ctor` et initialise tous les champs dans la nouvelle instance de la valeur 0 (du type approprié) ou les références null comme il convient. Il appelle ensuite le constructeur `ctor` avec les arguments donnés, ainsi que l’instance nouvellement créée. Une fois que le constructeur a été appelé, le présent initialisée référence d’objet (type `O`) est ajoutée à la pile.  
  
 À partir du point de vue constructeur, l’objet non initialisé est l’argument 0 et les autres arguments passés à newobj suivent dans l’ordre.  
  
 Tous les tableaux unidimensionnels de base zéro sont créés à l’aide de <xref:System.Reflection.Emit.OpCodes.Newarr>, et non `newobj`. En revanche, tous les autres tableaux (multidimensionnels ou unidimensionnels mais pas de base zéro) sont créés à l’aide de `newobj`.  
  
 Les types valeur ne sont pas généralement créés à l’aide de `newobj`. Ils sont généralement alloués en tant qu’arguments ou variables locales, à l’aide de `newarr` (pour les tableaux unidimensionnels de base zéro) ou en tant que champs d’objets. Une fois allouée, ils sont initialisés à l’aide de <xref:System.Reflection.Emit.OpCodes.Initobj>. Toutefois, la `newobj` instruction peut être utilisée pour créer une nouvelle instance d’un type valeur dans la pile, ce qui peut ensuite être transmise en tant qu’argument, stocké dans une variable locale et ainsi de suite.  
  
 <xref:System.OutOfMemoryException> est levée si la mémoire est insuffisante pour satisfaire la requête.  
  
 <xref:System.MissingMethodException> est levée si une méthode de constructeur `ctor` portant le nom indiqué, classe et la signature est introuvable. Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `newobj` opcode :  
  
-   ILGenerator.Emit (OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplit l’espace si les opcodes sont corrigés. Aucune opération significative n'est exécutée bien qu'un cycle de traitement puisse être utilisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|00|nop|Effectue une opération sans comportement.|  
  
 Il n’existe aucun comportement de transition de pile défini pour cette instruction.  
  
 Le `nop` opération ne fait rien. Il est destiné à remplir l’espace si les opcodes sont corrigés.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `nop` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcule le complément de bits de la valeur entière située en haut de la pile et exécute un push du résultat dans la pile d'évaluation en tant que type identique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|66|not|Calcule le complément de bits d’une valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value` est placé sur la pile.  
  
2.  `value` est dépilée de la pile et sa au niveau du bit complément calculée.  
  
3.  Le résultat est placé sur la pile.  
  
 La `not` instruction le complément de bits d’une valeur entière et exécute un push du résultat dans la pile. Le type de retour est le même type que l’opérande.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `not` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcule le complément de bits de deux valeurs entières situées en haut de la pile et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|60|ou|Calcule l’opérateur de bits ou de deux valeurs entières, retourne un entier.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés à partir de la pile et leur opération de bits OR calculée.  
  
4.  Le résultat est placé sur la pile.  
  
 La `or` instruction calcule l’opération OR au niveau du bit des deux premières valeurs de la pile, en exécutant un push du résultat dans la pile.  
  
 `Or` est une opération spécifique aux entiers.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `or` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Supprime la valeur actuellement située en haut de la pile.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|26|pop|Dépile la valeur de la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur supérieure est retirée de la pile.  
  
 La `pop` instruction supprime l’élément supérieur de la pile.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `pop` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette instruction est réservée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie que l'opération d'adresse de tableau suivante n'exécute aucun contrôle de type au moment de l'exécution et qu'il retourne un pointeur managé dont la mutabilité est restreinte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 1E|en lecture seule.|Spécifier que l’opération d’adresse de tableau suivante n’exécute aucun contrôle de type au moment de l’exécution, et qu’il retourne un pointeur managé avec la mutabilité est restreinte.|  
  
 Ce préfixe ne peut apparaître qu’immédiatement précédent le `ldelema` instruction et les appels à spéciale `Address` (méthode) sur les tableaux. Son effet sur l’opération suivante est double :  
  
1.  Au moment de l’exécution, aucune opération de vérification de type n’est effectuée. Notez qu’il existe normalement une vérification de type implicite pour les `ldelema` et `stelem` instructions lorsqu’il est utilisé sur la référence des tableaux de types. Il n’est jamais une vérification de type au moment de l’exécution pour les classes de valeur, par conséquent, `readonly` est une absence d’opération dans ce cas.  
  
2.  Le vérificateur traite le résultat de l’opération d’adresse comme un pointeur managé avec la mutabilité est restreinte.  
  
 Le pointeur est dite mutabilité est restreinte, car le type de définition contrôle si la valeur peut être MUTÉE. Pour les classes de valeur qui n’exposent aucun champ public ou les méthodes qui mettent à jour la valeur en place, le pointeur est en lecture seule (par conséquent, le nom du préfixe). En particulier, les classes qui représentent des types primitifs (par exemple, System.Int32) n’exposent pas les mutateurs et sont donc en lecture seule.  
  
 Un pointeur managé restreint de cette manière peut être utilisé uniquement dans des manières suivantes :  
  
-   Comme le `object` paramètre pour le `ldfld`, `ldflda`, `stfld`, `call`, ou`constrained callvirt` obtenir des instructions.  
  
-   Comme le `pointer` paramètre à la `ldobj` instruction ou à un de la `ldind` obtenir des instructions.  
  
-   Comme le `source` paramètre à la `cpobj` instruction.  
  
 Toutes les autres opérations interdites, notamment le `stobj`, `initobj`, ou `mkrefany` operations ou l’un de la `stind` obtenir des instructions.  
  
 L’objectif de la `readonly` préfixe est d’éviter une vérification de type lors de l’extraction d’un élément à partir d’un tableau dans le code générique. Par exemple, l’expression `arr[i].m()`, où le type d’élément du tableau `arr` est un type générique qui a été contraint à posséder une interface avec la méthode `m`, peut compiler dans le code MSIL suivant.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Sans le `readonly` préfixe, la `ldelema` instruction effectue une vérification de type dans le cas où ! 0 a un type référence. Non seulement cette vérification de type inefficace, mais il est sémantiquement incorrect. La vérification des types pour `ldelema` est une correspondance exacte qui est trop forte. Si le tableau contenait des sous-classes de type ! 0, le code ci-dessus échoue la vérification de type.  
  
 L’adresse de l’élément de tableau est extraite, au lieu de l’élément lui-même, afin de disposer d’un handle pour `arr[i]` que fonctionne pour les deux types valeur et types référence et peut donc être passé à la `constrained callvirt` instruction.  
  
 En général, il serait risqué d’ignorer la vérification de l’exécution si le tableau contient des éléments d’un type référence. Pour plus de sécurité, il est nécessaire pour s’assurer qu’aucune modification du tableau n’est effectuées via ce pointeur. Les règles de vérificateur Vérifiez cela. Le pointeur managé restreint peut être passé en tant que l’objet d’appels de méthode d’instance, par conséquent, il n’est pas à proprement parler en lecture seule pour les types valeur, mais aucun problème de sécurité de type pour les types valeur.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `readonly` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le jeton de type incorporé dans une référence typée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Exécute un push du jeton de type stocké dans une référence typée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence de type valeur est envoyée à la pile.  
  
2.  La référence typée est dépilée et le type de jeton correspondant est récupéré.  
  
3.  Le jeton du type est placé sur la pile.  
  
 Une référence typée contient un jeton de type et une adresse à une instance d’objet.  
  
 La `refanytype` instruction récupère le jeton de type incorporé dans la référence typée. Consultez le <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction pour plus d’informations sur la création de références typées.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `refanytype` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère l'adresse (type <see langword="&amp;" />) incorporée dans une référence typée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Exécute un push de l’adresse stockée dans une référence typée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence de type valeur est envoyée à la pile.  
  
2.  La référence typée est dépilée et l’adresse correspondante est récupérée.  
  
3.  L’adresse est placé sur la pile.  
  
 Une référence typée contient un jeton de type et une adresse à une instance d’objet.  
  
 La `refanyval` instruction récupère l’adresse incorporée dans la référence typée. Le type incorporé dans la référence typée fournie dans la pile doit correspondre au type spécifié par `type` (jeton de métadonnées, soit un `typedef` ou `typeref`). Consultez le <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction concernant le contenu.  
  
 <xref:System.InvalidCastException> est levée si `type` n’est pas identique au type stocké dans la référence de type (dans ce cas, `type` est la classe fournie à la <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction construit ladite référence typée).  
  
 <xref:System.TypeLoadException> est levée si `type` est introuvable.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `refanyval` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divise une valeur par une autre et exécute un push du reste dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|5D|REM|Exécute un push du reste de la division `value1` par `value2` dans la pile.|  
  
> [!NOTE]
>  ReplaceThisText  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Un `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés à partir de la pile et le reste de `value1` `div` `value2` calculée.  
  
4.  Le résultat est placé sur la pile.  
  
 `result` = `value1` `rem` `value2` satisfait les conditions suivantes :  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), et :  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, signe (`result`) = connexion (`value1`), où `div` est l’instruction de division qui tronque vers zéro.  
  
 Si `value2` est égal à zéro ou `value1` est infini, le résultat est NaN. Si `value2` est l’infini, le résultat est `value1` (exclue pour `-infinity`).  
  
 Opérations intégrales lever <xref:System.DivideByZeroException> si `value2` est égal à zéro.  
  
 Notez que sur les plateformes Intel un <xref:System.OverflowException> est levée lors du calcul (minint `rem` -1).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `rem` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divise une valeur non signée par une autre et exécute un push du reste dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|5E|rem.un|Exécute un push du reste de la division non signé `value1` par non signé `value2` dans la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés à partir de la pile et le reste de `value1` `div` `value2` calculée.  
  
4.  Le résultat est placé sur la pile.  
  
 `result` = `value1` `rem.un` `value2` satisfait les conditions suivantes :  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), et :  
  
 0 = `result`  <  `value2`, où `div.un` est l’instruction de division non signée.  
  
 Le `rem.un` instruction calcule `result` et qu’il exécute un push sur la pile. `Rem.un` traite ses arguments comme des entiers non signés, tandis que <xref:System.Reflection.Emit.OpCodes.Rem> les traite comme des entiers signés.  
  
 `Rem.un` n’est pas spécifié pour les nombres à virgule flottante.  
  
 Opérations intégrales lever <xref:System.DivideByZeroException> si `value2` est égal à zéro.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `rem.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Effectue un retour à partir de la méthode actuelle en exécutant un push d'une valeur de retour (si elle existe) à partir de la pile d'évaluation de l'appelé dans celle de l'appelant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|2 A|RET|Renvoie, à partir de la méthode, éventuellement retournant une valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur de retour est dépilée de la pile d’évaluation appelé.  
  
2.  La valeur de retour obtenue à l’étape 1 est placée sur la pile d’évaluation de l’appelant.  
  
 Si la valeur de retour n’est pas présente sur la pile d’évaluation appelé, aucune valeur n’est retournée (aucun comportement de transition de pile pour la méthode appelant ou appelé).  
  
 Le type de la valeur de retour, le cas échéant, de la méthode actuelle détermine le type de valeur à extraire à partir du haut de la pile et à copier dans la pile de la méthode qui a appelé la méthode actuelle. La pile d’évaluation de la méthode actuelle doit être vide sauf pour la valeur à retourner.  
  
 Le `ret` ne peut pas être utilisée pour transférer le contrôle d’un`try`, `filter`, `catch`, ou `finally` bloc. Depuis un `try` ou `catch`, utiliser le <xref:System.Reflection.Emit.OpCodes.Leave> instruction avec une destination d’un `ret` instruction située en dehors d’englobant tous les blocs d’exception. Étant donné que le `filter` et `finally` blocs font logiquement partie de la gestion des exceptions et pas la méthode dans laquelle leur code est incorporé, les instructions de langage MSIL (Microsoft Intermediate Language) générées correctement n’effectuent pas un retour à partir de la méthode un `filter` ou `finally`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ret` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lève de nouveau l'exception actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|1 A FE|rethrow|Lève à nouveau l’exception actuelle|  
  
 Aucun comportement de transition de pile n’est défini pour cette instruction.  
  
 Le `rethrow` instruction n’est autorisée dans le corps d’un `catch` gestionnaire. Elle lève la même exception qui a été interceptée par ce gestionnaire.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `rethrow` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Déplace une valeur entière vers la gauche (décalage des zéros) d'un nombre de bits spécifié, en exécutant un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|62|shl|Déplace un entier vers la gauche (décalage des zéros).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est envoyée à la pile.  
  
2.  La quantité de bits à décaler est placée sur la pile.  
  
3.  Le nombre de bits à décaler et la valeur sont dépilés de la pile ; la valeur est déplacée vers la gauche du nombre spécifié de bits.  
  
4.  Le résultat est placé sur la pile.  
  
 Le `shl` instruction décale la valeur (type `int32`, `int64` ou `native int`) gauche du nombre spécifié de bits. Le nombre de bits est une valeur de type `int32` ou `native int`. La valeur de retour n’est pas spécifiée si le nombre de bits de décalage est supérieur ou égal à la largeur (en bits) de la valeur fournie.  
  
 `Shl` Insère un bit zéro dans la position la plus basse sur chaque décalage.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `shl` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Déplace une valeur entière (dans le signe) vers la droite d'un nombre de bits spécifié, en exécutant un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|63|shr|Déplace un entier vers la droite (décalage des connexion).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est envoyée à la pile.  
  
2.  La quantité de bits à décaler est placée sur la pile.  
  
3.  Le nombre de bits à décaler et la valeur sont dépilés de la pile ; la valeur est décalée vers la droite du nombre de bits spécifié.  
  
4.  Le résultat est placé sur la pile.  
  
 Le `shr.un` instruction décale la valeur (type `int32`, `int64` ou `native int`) directement par le nombre de bits spécifié. Le nombre de bits est une valeur de type `int32` ou `native int`. La valeur de retour n’est pas spécifiée si le nombre de bits de décalage est supérieur ou égal à la largeur (en bits) de la valeur fournie.  
  
 `Shr` réplique l’ordre élevé bit sur chaque décalage, en conservant le signe de la valeur d’origine dans le `result`.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `shr` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Déplace une valeur entière non signée (décalage des zéros) vers la droite d'un nombre de bits spécifié, en exécutant un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|64|shr.un|Déplace un entier vers la droite (décalage des zéros).|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est envoyée à la pile.  
  
2.  La quantité de bits à décaler est placée sur la pile.  
  
3.  Le nombre de bits à décaler et la valeur sont dépilés de la pile ; la valeur est décalée vers la droite du nombre de bits spécifié.  
  
4.  Le résultat est placé sur la pile.  
  
 Le `shr.un` instruction décale la valeur (type `int32`, `int64` ou `native int`) directement par le nombre de bits spécifié. Le nombre de bits est une valeur de type `int32`, `int64` ou `native int`. La valeur de retour n’est pas spécifiée si le nombre de bits de décalage est supérieur ou égal à la largeur (en bits) de la valeur fournie.  
  
 `Shr.un` Insère un bit zéro dans la position la plus élevée sur chaque décalage.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `shr.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute un push de la taille (en octets) d'un type de valeur fourni dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 1C &LT; `T` >|sizeof `valType`|Push de la taille, en octets, d’un type valeur comme un `unsigned int32`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La taille (en octets) du type de valeur fourni (`valType`) est placé sur la pile.  
  
 `valType` doit être un jeton de métadonnées (un `typeref` ou `typedef`) qui spécifie un type valeur, un type référence ou un paramètre de type générique.  
  
 Pour un type référence, la taille retournée est la taille d’une valeur de référence correspondante tapez (4 octets sur les systèmes 32 bits), pas la taille des données stockées dans les objets référencés par la valeur de référence. Un paramètre de type générique peut être utilisé uniquement dans le corps du type ou de méthode qui le définit. Lorsque ce type ou cette méthode est instancié, le paramètre de type générique est remplacé par un type valeur ou un type référence.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sizeof` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke la valeur en haut de la pile d’évaluation à l’emplacement d’argument situé à un index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0 B FE &LT; `unsigned int16` >|starg `num`|Dépile la valeur de la pile et la stocke dans l’emplacement d’argument `num`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur actuellement située en haut de la pile est dépilée et placée dans l’emplacement d’argument `num`.  
  
 Le `starg` instruction Dépile une valeur de la pile et la place dans l’emplacement d’argument `num`. Le type de la valeur doit correspondre au type de l’argument, comme spécifié dans la signature de la méthode actuelle.  
  
 Pour connaître les procédures qui acceptent une liste d’arguments variable, la `starg` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.  
  
 Stocker dans les arguments qui contiennent une valeur entière inférieure à 4 octets tronque la valeur lorsqu’il passe à partir de la pile à l’argument. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `starg` opcode :  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke la valeur en haut de la pile d’évaluation à l’emplacement d’argument situé à un index spécifié (forme abrégée).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|Dépile la valeur de la pile et la stocke dans l’emplacement de l’argument `num`, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  La valeur actuellement située en haut de la pile est dépilée et placée dans l’emplacement d’argument `num`.  
  
 Le `starg.s` instruction Dépile une valeur de la pile et la place dans l’emplacement d’argument `num`. Le type de la valeur doit correspondre au type de l’argument, comme spécifié dans la signature de la méthode actuelle.  
  
 La `starg.s` instruction fournit un codage efficace pour une utilisation avec les 256 premiers arguments.  
  
 Pour connaître les procédures qui acceptent une liste d’arguments variable, la `starg.s` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.  
  
 Stocker dans les arguments qui contiennent une valeur entière inférieure à 4 octets tronque la valeur lorsqu’il passe à partir de la pile à l’argument. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `starg.s` opcode :  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau à un index donné par la valeur de la pile d'évaluation dont le type est spécifié dans l'instruction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|A4 &LT; `T` >|stelem `typeTok`|Remplace l’élément de tableau à l’index fourni par une valeur de type `typeTok` sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Une valeur d’index, `index`, à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur du type spécifié dans l’instruction est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem` instruction remplace la valeur de l’élément à l’index de base zéro fourni dans le tableau unidimensionnel `array` avec la valeur. La valeur a le type spécifié par le jeton `typeTok` dans l’instruction.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur <see langword="native int" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|9 B|stelem.i|Remplace un élément de tableau à l’index fourni avec le `native int` valeur sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.i` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `native int` valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur <see langword="int8" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Remplace un élément de tableau à l’index fourni avec le `int8` valeur sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.i1` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int8` valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur <see langword="int16" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Remplace un élément de tableau à l’index fourni avec le `int16` valeur sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.i2` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int16` valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur <see langword="int32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|9 E|stelem.i4|Remplace un élément de tableau à l’index fourni avec le `int32` valeur sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.i4` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int32` valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur <see langword="int64" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|9F|stelem.i8|Remplace un élément de tableau à l’index fourni avec le `int64` valeur sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.i8` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int64` valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur <see langword="float32" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|A0|stelem.r4|Remplace un élément de tableau à l’index fourni avec le `float32` valeur sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.r4` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `float32` valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.r4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur <see langword="float64" /> dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|A1|stelem.r8|Remplace un élément de tableau à l’index fourni avec le `float64` valeur sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.r8` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `float64` valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.r8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace l'élément de tableau situé à un index donné par la valeur de référence d'objet (type <see langword="O" />) dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Remplace un élément de tableau à l’index fourni avec le `ref` valeur (type `O`) sur la pile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet dans un tableau, `array`, est placé sur la pile.  
  
2.  Un index valide à un élément dans `array` est placé sur la pile.  
  
3.  Une valeur est envoyée à la pile.  
  
4.  La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.  
  
 Le `stelem.ref` instruction remplace la valeur de l’élément à l’index fourni dans le tableau unidimensionnel `array` avec la `ref` (type `O`) valeur envoyée à la pile.  
  
 Les tableaux sont des objets et sont donc représentés par une valeur de type `O`. L’index est de type `native int`.  
  
 Notez que `stelem.ref` convertit implicitement la valeur fournie pour le type d’élément de `array` avant d’affecter la valeur à l’élément de tableau. Cette conversion peut échouer, même pour le code vérifié. Par conséquent, le `stelem.ref` instruction peut lever <xref:System.InvalidCastException>. Pour les tableaux unidimensionnels qui ne sont pas de base zéro et pour les tableaux multidimensionnels, le <xref:System.Array> classe fournit un <xref:System.Array.SetValue%2A> (méthode).  
  
 <xref:System.NullReferenceException> est levée si `array` est une référence null.  
  
 <xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.ref` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace la valeur stockée dans le champ d'une référence d'objet ou d'un pointeur par une nouvelle valeur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|7D &LT; `T` >|stfld `field`|Remplace la valeur de `field` de l’objet avec une nouvelle valeur.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet ou le pointeur est placé sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et la référence d’objet/pointeur sont dépilés de la pile ; la valeur de `field` dans l’objet est remplacé par la valeur fournie.  
  
 Le `stfld` instruction remplace la valeur d’un champ d’un objet (type `O`) ou via un pointeur (type `native int`, `&`, ou `*`) avec une valeur donnée. `Field` est un jeton de métadonnées qui fait référence à une référence de membre de champ. Le `stfld` instruction peut avoir un préfixe d’une des deux <xref:System.Reflection.Emit.OpCodes.Unaligned> et <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> est levée si la référence d’objet ou le pointeur est une référence null et que le champ n’est pas statique.  
  
 <xref:System.MissingFieldException> est levée si `field` est introuvable dans les métadonnées. Cette option est généralement activée quand l’instruction de langage MSIL (Microsoft Intermediate Language) est convertie en code natif, pas lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stfld` opcode :  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de type <see langword="native int" /> à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|DF|stind.i|Stocke un `native int` valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.i` instruction stocke un `native int` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.i` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.i` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de type <see langword="int8" /> à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|52|stind.i1|Stocke un `int8` valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.i1` instruction stocke un `int8` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.i1` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.i1` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de type <see langword="int16" /> à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|53|stind.i2|Stocke un `int16` valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.i2` instruction stocke un `int16` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.2i` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.i2` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de type <see langword="int32" /> à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|54|stind.i4|Stocke un `int32` valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.i4` instruction stocke un `int32` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.i4` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.i4` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de type <see langword="int64" /> à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|55|stind.i8|Stocke un `int64` valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.i8` instruction stocke un `int64` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.i8` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.i` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de type <see langword="float32" /> à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|56|stind.r4|Stocke un `float32` valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.r4` instruction stocke un `float32` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.r4` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.r4` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.r4` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de type <see langword="float64" /> à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|57|stind.r8|Stocke un `float64` valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.r8` instruction stocke un `float64` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.r8` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.r8` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.r8` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stocke une valeur de référence d'objet à une adresse fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|51|stind.ref|Stocke une référence d’objet (type `O`) valeur à une adresse donnée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Une valeur est envoyée à la pile.  
  
3.  La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.  
  
 Le `stind.ref` instruction stocke une valeur de référence d’objet à l’adresse fournie (type `native int`, `*`, ou `&`).  
  
 Opération de type sécurisé requiert que le `stind.ref` instruction soit utilisée de manière cohérente avec le type du pointeur. L’opération de la `stind.ref` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.ref` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à un index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 0E &LT; `unsigned int16` >|stloc `index`|Dépile une valeur de la pile et la stocke dans la variable locale `index`.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est dépilée et placée dans la variable locale `index`.  
  
 Le `stloc` instruction dépile la valeur la pile d’évaluation et la déplace dans le numéro de variable locale `index`, où les variables locales sont numérotées à partir de 0. Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.  
  
 Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Les instructions de langage MSIL (Microsoft Intermediate Language) correctes requièrent que `index` soit un index local valid. Pour le `stloc` instruction, `index` doit être compris entre 0 et 65534 inclus (spécifiquement, 65535 n’est pas valide). La raison de l’exclusion de 65535 est pragmatique : susceptibles d’implémentations utilisent un entier de 2 octets pour effectuer le suivi d’un index de variable locale, ainsi que le nombre total de variables locales pour une méthode donnée. Si un index 65 535 avait été rendu valide, un entier plus large pour suivre le nombre de variables locales dans une telle méthode serait nécessaire.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `stloc` opcode :  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à l'index 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0 A|stloc.0|Dépile une valeur de la pile dans la variable locale 0.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est dépilée et placée dans la variable locale indexée par 0.  
  
 La `stloc.0` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 0. Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.  
  
 `stloc.0` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 0.  
  
 Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.0` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à l'index 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0 B|stloc.1|Dépile une valeur de la pile dans la variable locale 1.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est dépilée et placée dans la variable locale indexée par 1.  
  
 La `stloc.1` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 1. Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.  
  
 `stloc.1` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 1.  
  
 Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.1` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à l'index 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0C|stloc.2|Dépile une valeur de la pile dans la variable locale 2|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est dépilée et placée dans la variable locale indexée par 2.  
  
 La `stloc.2` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 2. Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.  
  
 `stloc.2` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 2.  
  
 Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.2` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à l'index 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|0D|stloc.3|Dépile une valeur de la pile dans la variable locale 3|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est dépilée et placée dans la variable locale indexée par 3.  
  
 La `stloc.3` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 3. Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.  
  
 `stloc.3` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 3.  
  
 Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.3` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à <paramref name="index" /> (forme abrégée).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Dépile une valeur de la pile et la stocke dans la variable locale `index`, forme abrégée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est dépilée et placée dans la variable locale `index`.  
  
 Le `stloc.s` instruction dépile la valeur la pile d’évaluation et la déplace dans le numéro de variable locale `index`, où les variables locales sont numérotées à partir de 0. Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.  
  
 La `stloc.s` instruction fournit un codage efficace pour les variables locales de 0 à 255.  
  
 Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale. Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `stloc.s` opcode :  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copie une valeur d'un type spécifié de la pile d'évaluation vers une adresse mémoire fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Stocke une valeur de type `class` à partir de la pile en mémoire.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
2.  Un objet de type de valeur de type `class` est placé sur la pile.  
  
3.  L’objet et l’adresse sont dépilés de la pile ; l’objet de type valeur est stocké à l’adresse.  
  
 Le `stobj` instruction copie l’objet de type valeur vers l’adresse spécifiée par l’adresse (un pointeur de type `native int`, `*`, ou `&`). Le nombre d’octets copiés dépend de la taille de la classe représentée par `class`, un jeton de métadonnées représentant un type valeur.  
  
 L’opération de la `stobj` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.  
  
 <xref:System.TypeLoadException> est levée si la classe est introuvable. Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif plutôt qu’au moment de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stobj` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remplace la valeur d'un champ statique par une valeur de la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Remplace la valeur dans `field` avec une valeur fournie.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est envoyée à la pile.  
  
2.  Une valeur est dépilée et stockée dans `field`.  
  
 La `stsfld` instruction remplace la valeur d’un champ statique avec une valeur de la pile. `field` est un jeton de métadonnées qui doit faire référence à un membre de champ statique.  
  
 Le `stsfld` instruction peut-être être précédée <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> est levée si le champ est introuvable dans les métadonnées. Cette option est généralement activée lorsque des instructions de langage MSIL (Microsoft Intermediate Language) en code natif, pas en cours d’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stsfld` opcode :  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Soustrait une valeur d'une autre et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|59|sub|Soustrait une valeur d’un autre, en retournant une nouvelle valeur numérique.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value2` est soustraite de `value1`.  
  
4.  Le résultat est placé sur la pile.  
  
 Dépassement de capacité n’est pas détecté pour les opérations sur les entiers (pour la gestion du dépassement de capacité, consultez <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Soustraction de nombres entiers encapsule, au lieu de saturer. Par exemple : entiers 8 bits, où `value1` est définie sur 0 et `value2` est définie sur 1, le résultat « encapsulé » sera 255.  
  
 Dépassement de capacité à virgule flottante retourne `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sub` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Soustrait une valeur entière d'une autre, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|DA|sub.ovf|Soustrait une valeur entière d’un autre avec une vérification de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value2` est soustraite de `value1` avec une vérification de dépassement de capacité.  
  
4.  Le résultat est placé sur la pile.  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Cette opération est effectuée sur les entiers signés ; pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sub.ovf` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Soustrait une valeur entière non signée d'une autre, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|DB|Sub.ovf.un|Soustrait une valeur d’entier non signé à partir d’un autre avec une vérification de dépassement de capacité.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés de la pile ; `value2` est soustraite de `value1` avec une vérification de dépassement de capacité.  
  
4.  Le résultat est placé sur la pile.  
  
 <xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.  
  
 Cette opération est effectuée sur les entiers signés ; pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sub.ovf.un` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implémente un tableau de saut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` >< `int32` >... < `int32` >|Basculer (`N`, `t1`, `t2`... `tN`)|Accède à un des `N` valeurs.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une valeur est envoyée à la pile.  
  
2.  La valeur est dépilée et l’exécution est transférée à l’instruction à l’offset indexé par la valeur, où la valeur est inférieure à `N`.  
  
 La `switch` instruction implémente un tableau de saut. Le format de l’instruction est une `unsigned int32` représentant le nombre de cibles `N`, suivi par `N` valeurs int32 qui spécifient les cibles de saut. Ces cibles sont représentées en tant qu’offsets (positifs ou négatifs) à partir du début de l’instruction suivant ce `switch` instruction.  
  
 Le `switch` instruction Dépile une valeur de la pile et la compare, comme un entier non signé, à `N`. Si la valeur est inférieure à `N`, l’exécution est transférée à la cible indexée par valeur, où les cibles sont numérotés de 0 (par exemple, une valeur de 0 est la première cible, une valeur de 1 est la deuxième cible et ainsi de suite). Si la valeur est supérieure ou égale à `N`, l’exécution se poursuit à l’instruction suivante (passage).  
  
 Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.  
  
 Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction. (Ces transferts sont strictement limités et doivent plutôt utiliser l’instruction leave).  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `switch` opcode. Le `Label[]` argument est un tableau d’étiquettes représentant des offsets de 32 bits.  
  
-   ILGenerator.Emit (OpCode, Label[])  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la `Switch` opcode pour générer un tableau de saut à l’aide d’un tableau de <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exécute une instruction d'appel de méthode suffixée afin que le frame de pile de la méthode actuelle soit supprimé avant cette exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 14|tail.|L’appel suivant met fin à des méthodes actuelles|  
  
 Il n’existe aucun comportement de transition de pile défini pour cette instruction.  
  
 Le `tail` instruction de préfixe doit précéder immédiatement un <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, ou <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction. Il indique que le frame de pile de la méthode actuelle doit être supprimé avant l’exécution de l’instruction d’appel. Il implique également que la valeur retournée par l’appel suivant est également la valeur retournée par la méthode actuelle, et l’appel peut donc être convertie en un saut croisé-method.  
  
 La pile doit être vide sauf pour les arguments transférés par l’appel suivant. L’instruction qui suit l’instruction d’appel doit être un ret. Par conséquent, la séquence de code valide uniquement est `tail. call` (ou `calli` ou `callvirt`). Les instructions de langage MSIL (Microsoft Intermediate Language) correctes ne doivent pas créer de branche à la `call` instruction, mais ils peuvent créer une branche à le <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Le frame actuel ne peut pas être ignoré lorsque le contrôle est transféré à partir du code non approuvé à code de confiance, car cela compromettrait la sécurité d’identité du code. Vérifications de la sécurité de .NET Framework peuvent donc entraîner la `tail` doivent être ignorés, en laissant une norme <xref:System.Reflection.Emit.OpCodes.Call> instruction. De même, dans l’ordre pour autoriser la sortie d’une région synchronisée après le retour de l’appel, le `tail` est ignoré lorsqu’il est utilisé pour quitter une méthode marquée comme synchronisée.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `tail` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Instance d'un objet Opcode.</param>
        <summary>Retourne true ou false si l’opcode fourni utilise un argument à octet unique.</summary>
        <returns>
          <see langword="True" /> ou <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour rechercher les opcodes MSIL qui constituent « court », pour une utilisation dans le code optimisé.  
  
 `TakesSingleByteArgument` Retourne `true` si le <xref:System.Reflection.Emit.OpCode> instance accepte un argument à octet unique dans les cas suivants :  
  
-   L’opcode exécute une instruction de branchement à une adresse en octets (par exemple, <xref:System.Reflection.Emit.OpCodes.Br_S> et <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   L’opcode exécute un push d’une valeur d’octet dans la pile (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   L’opcode fait référence à une variable ou un argument via la « forme abrégée » en octets (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> et <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 Sinon, il retourne `false`.  
  
 L’exemple ci-dessous illustre l’utilisation de `TakesSingleByteArgument` en réfléchissant le `OpCodes` classe et test pour voir si chaque `OpCode` champ prend un argument à octet unique.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lève l'objet exception actuellement situé dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|7 A|throw|Lève une exception.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet (une exception) est placée sur la pile.  
  
2.  La référence d’objet est dépilée de la pile et l’exception levée.  
  
 Le `throw` instruction lève l’objet exception (type `O`) actuellement sur la pile.  
  
 <xref:System.NullReferenceException> est levé si la référence d’objet est une référence null.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `throw` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique qu'une adresse actuellement située en haut de la pile d'évaluation peut ne pas être alignée avec la taille naturelle de l'instruction <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> ou <see langword="cpblk" /> qui suit immédiatement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|non alignés. `alignment`|Indique que l’instruction de pointeur suivantes peut-être ne pas être alignée.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
 `Unaligned` Spécifie que l’adresse (un pointeur non managé, `native int`) sur la pile peut ne pas être alignée avec la taille naturelle de la suite des `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instruction. Autrement dit, pour un <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction l’alignement de l’adresse ne peut pas être à une limite de 4 octets. Pour `initblk` et `cpblk` l’alignement par défaut est dépend de l’architecture (4 octets sur les processeurs 32 bits, 8 octets sur les unités centrales 64 bits). Les générateurs de code qui ne limitent pas leur sortie à une taille de mot de 32 bits doivent utiliser `unaligned` si l’alignement n’est pas connu au moment de la compilation à 8 octets.  
  
 La valeur de l’alignement doit être 1, 2 ou 4 et signifie que le code généré doit supposer que l’adresse est l’octet, deux octets, ou à quatre octets, respectivement. Notez que temporaire des pointeurs (type `*`) sont toujours alignés.  
  
 Tandis que l’alignement d’un `cpblk` instruction nécessite logiquement deux nombres (un pour la source) et l’autre pour la destination, il n’existe aucun impact significatif sur les performances si seul le nombre inférieur est spécifié.  
  
 Le `unaligned` et `volatile` préfixes peuvent être combinées dans les deux sens. Ils doivent précéder immédiatement un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instruction. Uniquement les <xref:System.Reflection.Emit.OpCodes.Volatile> est autorisé pour le <xref:System.Reflection.Emit.OpCodes.Ldsfld> et <xref:System.Reflection.Emit.OpCodes.Stsfld> obtenir des instructions.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `unaligned` opcode :  
  
-   ILGenerator.Emit (OpCode, étiquette)  
  
-   ILGenerator.Emit (Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la représentation boxed d'un type de valeur dans sa forme unboxed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|79 < `T` >|effectuer une conversion unboxing `valType`|Extrait les données de type valeur à partir de `obj`, ses boxed de représentation.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet est placée sur la pile.  
  
2.  La référence d’objet est dépilée et unboxed en un pointeur de type valeur.  
  
3.  Le pointeur de type valeur est envoyé à la pile.  
  
 Un type valeur a deux représentations distinctes au sein de l’Infrastructure (CLI) :  
  
-   Un formulaire « brut » utilisé lorsqu’un type valeur est incorporé dans un autre objet.  
  
-   Un formulaire « boxed », où les données dans le type de valeur sont encapsulées (boxed) dans un objet afin qu’il peut exister une entité indépendante.  
  
 Le `unbox` instruction convertit la référence d’objet (type `O`), le boxed de représentation d’un type valeur, un pointeur de type valeur (un pointeur managé, type `&`), sa forme unboxed. Le type de valeur fourni (`valType`) est un jeton de métadonnées indiquant le type du type de valeur contenue dans l’objet converti.  
  
 Contrairement aux <xref:System.Reflection.Emit.OpCodes.Box>, qui est nécessaire pour effectuer une copie d’un type de valeur pour une utilisation dans l’objet, `unbox` n’est pas nécessaire pour copier le type de valeur à partir de l’objet. En règle générale, il calcule simplement l’adresse du type valeur qui est déjà présent dans l’objet converti.  
  
 <xref:System.InvalidCastException> est levée si l’objet n’est pas converti (boxed) en tant que `valType`.  
  
 <xref:System.NullReferenceException> est levé si la référence d’objet est une référence null.  
  
 <xref:System.TypeLoadException> est levée si la valeur de type `valType` est introuvable. Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `unbox` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convertit la représentation boxed d'un type spécifié dans l'instruction en forme unboxed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|A5 &LT; `T` >|unbox.Any `typeTok`|Extraire les données à partir de `obj`, ses boxed de représentation.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une référence d’objet `obj` est placé sur la pile.  
  
2.  La référence d’objet est dépilée et unboxed au type spécifié dans l’instruction.  
  
3.  Le type de référence ou valeur d’objet qui en résulte est placé sur la pile.  
  
 Lorsqu’il est appliqué à la forme boxed d’un type valeur, le `unbox.any` instruction extrait la valeur contenue dans `obj` (de type `O`) et n’est donc équivalent à `unbox` suivie `ldobj`.  
  
 Lorsqu’il est appliqué à un type référence, le `unbox.any` instruction a le même effet que `castclass` `typeTok`.  
  
 Si l’opérande `typeTok` est un paramètre de type générique, puis le comportement d’exécution est déterminé par le type qui est spécifié pour ce paramètre de type générique.  
  
 <xref:System.InvalidCastException> est levée si `obj` n’est pas un type boxed.  
  
 <xref:System.NullReferenceException> est levée si `obj` est une référence null.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `unbox.any` opcode :  
  
-   ILGenerator.Emit (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie qu'une adresse actuellement située en haut de la pile d'évaluation peut être volatile et que les résultats de la lecture de cet emplacement ne peuvent pas être mis en cache ou que plusieurs magasins situés à cet emplacement ne peuvent pas être supprimés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Indique que la référence de pointeur suivante est volatile.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  Une adresse est placée sur la pile.  
  
 `volatile`. Spécifie que l’adresse est une adresse volatile (en d’autrement dit, il peut être référencé d’en externe pour le thread en cours d’exécution) et les résultats de la lecture qu’emplacement ne peut pas être mis en cache ou que plusieurs magasins situés à cet emplacement ne peut pas être supprimées. Marquer un accès en tant que `volatile` n’affecte que cet accès unique ; d’autres accès au même emplacement doivent être marqués séparément. Accès aux emplacements volatiles ne doivent pas être effectuée atomiquement.  
  
 Le <xref:System.Reflection.Emit.OpCodes.Unaligned> et `volatile` préfixes peuvent être combinées dans les deux sens. Ils doivent précéder immédiatement un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instruction. Uniquement les `volatile` est autorisé pour le <xref:System.Reflection.Emit.OpCodes.Ldsfld> et <xref:System.Reflection.Emit.OpCodes.Stsfld> obtenir des instructions.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `volatile` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcule l'opération de bits XOR des deux premières valeurs de la pile d'évaluation en exécutant un push du résultat dans la pile d'évaluation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :  
  
|Format|Format d’assembly|Description |  
|------------|---------------------|-----------------|  
|61|xor|Calcule l’opération de bits XOR des deux valeurs entières et retourne un entier.|  
  
 Le comportement de transition de pile, dans un ordre séquentiel, est :  
  
1.  `value1` est placé sur la pile.  
  
2.  `value2` est placé sur la pile.  
  
3.  `value2` et `value1` sont dépilés à partir de la pile et leurs opérations de bits XOR est calculée.  
  
4.  L’opération de bits XOR de `value2` et `value1` est placé sur la pile.  
  
 La `xor` instruction calcule l’opération de bits XOR des deux premières valeurs de la pile et laisse le résultat dans la pile.  
  
 `Xor` est une opération spécifique aux entiers.  
  
 Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `xor` opcode :  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>