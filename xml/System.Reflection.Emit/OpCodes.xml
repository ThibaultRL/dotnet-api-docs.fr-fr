<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="22b85af836552ccbbe3eee4a23c0f8e2510b9978" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65013635" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5c64e-101">Fournit les représentations des champs des instructions de langage MSIL (Microsoft Intermediate Language) pour l’émission par le <see cref="T:System.Reflection.Emit.ILGenerator" /> membres de classe (tel que <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span><span class="sxs-lookup"><span data-stu-id="5c64e-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-102">Pour obtenir une description détaillée des codes de membre d’une opération de données, consultez la documentation de Common Language Infrastructure (CLI), en particulier « Partition III : CIL Instruction Set » et « Partition II : Metadata Definition and Semantics ».</span><span class="sxs-lookup"><span data-stu-id="5c64e-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="5c64e-103">La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.</span><span class="sxs-lookup"><span data-stu-id="5c64e-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c64e-104">L’exemple suivant illustre la construction d’une méthode dynamique à l’aide <xref:System.Reflection.Emit.ILGenerator> à émettre `OpCodes` dans un <xref:System.Reflection.Emit.MethodBuilder>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-105">Ajoute deux valeurs et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-105">Adds two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-106">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-107">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-107">Format</span></span>|<span data-ttu-id="5c64e-108">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-108">Assembly Format</span></span>|<span data-ttu-id="5c64e-109">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-110">58</span><span class="sxs-lookup"><span data-stu-id="5c64e-110">58</span></span>|<span data-ttu-id="5c64e-111">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-111">add</span></span>|<span data-ttu-id="5c64e-112">Ajoute deux valeurs numériques, retournant une nouvelle valeur numérique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="5c64e-113">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-114">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-115">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-116">`value2` et `value1` sont dépilés de la pile ; `value1` est ajouté à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-117">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-118">Dépassement de capacité n’est pas détecté pour les opérations sur les entiers (pour la gestion du dépassement de capacité, consultez <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="5c64e-119">Ajout de l’entier encapsule, au lieu de saturer.</span><span class="sxs-lookup"><span data-stu-id="5c64e-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="5c64e-120">Par exemple, en supposant que des entiers 8 bits où `value1` a la valeur 255 et `value2` est définie sur 1, le résultat renvoyé à la ligne est 0 au lieu de 256.</span><span class="sxs-lookup"><span data-stu-id="5c64e-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="5c64e-121">Dépassement de capacité à virgule flottante retourne `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="5c64e-122">Les types d’opérande acceptables et leur type de données de résultat correspondant sont répertoriés dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="5c64e-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="5c64e-123">S’il n’existe aucune entrée pour une combinaison de type particulier (par exemple, `int32` et `float`; `int32` et `int64`), il est un non valide langage MSIL (Microsoft Intermediate) et génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="5c64e-124">opérande</span><span class="sxs-lookup"><span data-stu-id="5c64e-124">operand</span></span>|<span data-ttu-id="5c64e-125">type valeur 1</span><span class="sxs-lookup"><span data-stu-id="5c64e-125">value1 type</span></span>|<span data-ttu-id="5c64e-126">type valeur 2</span><span class="sxs-lookup"><span data-stu-id="5c64e-126">value2 type</span></span>|<span data-ttu-id="5c64e-127">type de résultat</span><span class="sxs-lookup"><span data-stu-id="5c64e-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="5c64e-128">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="5c64e-129">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="5c64e-130">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="5c64e-131">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="5c64e-132">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="5c64e-133">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="5c64e-134">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="5c64e-135">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="5c64e-136">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="5c64e-137">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="5c64e-138">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="5c64e-139">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="5c64e-140">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="5c64e-141">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="5c64e-142">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `add` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-144">Ajoute deux entiers, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-145">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-146">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-146">Format</span></span>|<span data-ttu-id="5c64e-147">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-147">Assembly Format</span></span>|<span data-ttu-id="5c64e-148">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-149">D6</span><span class="sxs-lookup"><span data-stu-id="5c64e-149">D6</span></span>|<span data-ttu-id="5c64e-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="5c64e-150">add.ovf</span></span>|<span data-ttu-id="5c64e-151">Ajoute deux valeurs entières signées avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="5c64e-152">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-153">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-154">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-155">`value2` et `value1` sont dépilés de la pile ; `value1` est ajouté à `value2` avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="5c64e-156">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-157"><xref:System.OverflowException> est levée si le résultat n’est pas représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-158">Vous pouvez effectuer cette opération sur les entiers signés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="5c64e-159">Pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="5c64e-160">Les types d’opérande acceptables et leur type de données de résultat correspondant sont répertoriés dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="5c64e-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="5c64e-161">S’il n’existe aucune entrée pour une combinaison de type particulier (par exemple, `int32` et `float`; `int32` et `int64`), il est une instruction de langage MSIL (Microsoft Intermediate Language) non valide et génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="5c64e-162">opérande</span><span class="sxs-lookup"><span data-stu-id="5c64e-162">operand</span></span>|<span data-ttu-id="5c64e-163">type valeur 1</span><span class="sxs-lookup"><span data-stu-id="5c64e-163">value1 type</span></span>|<span data-ttu-id="5c64e-164">type valeur 2</span><span class="sxs-lookup"><span data-stu-id="5c64e-164">value2 type</span></span>|<span data-ttu-id="5c64e-165">type de résultat</span><span class="sxs-lookup"><span data-stu-id="5c64e-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="5c64e-166">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="5c64e-167">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="5c64e-168">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="5c64e-169">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="5c64e-170">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="5c64e-171">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="5c64e-172">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="5c64e-173">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="5c64e-174">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="5c64e-175">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="5c64e-176">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="5c64e-177">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="5c64e-178">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="5c64e-179">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="5c64e-180">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `add.ovf` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-182">Ajoute deux valeurs entières non signées, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-183">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-184">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-184">Format</span></span>|<span data-ttu-id="5c64e-185">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-185">Assembly Format</span></span>|<span data-ttu-id="5c64e-186">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-187">D7</span><span class="sxs-lookup"><span data-stu-id="5c64e-187">D7</span></span>|<span data-ttu-id="5c64e-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-188">add.ovf.un</span></span>|<span data-ttu-id="5c64e-189">Ajoute deux valeurs entières non signées avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="5c64e-190">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-191">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-192">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-193">`value2` et `value1` sont dépilés de la pile ; `value1` est ajouté à `value2` avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="5c64e-194">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-195"><xref:System.OverflowException> est levée si le résultat n’est pas représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-196">Vous pouvez effectuer cette opération sur les entiers signés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="5c64e-197">Pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="5c64e-198">Les types d’opérande acceptables et leur type de données de résultat correspondant sont répertoriés dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="5c64e-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="5c64e-199">S’il n’existe aucune entrée pour une combinaison de type particulier (par exemple, `int32` et `float`; `int32` et `int64`), il est une instruction de langage MSIL (Microsoft Intermediate Language) non valide et génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="5c64e-200">opérande</span><span class="sxs-lookup"><span data-stu-id="5c64e-200">operand</span></span>|<span data-ttu-id="5c64e-201">type valeur 1</span><span class="sxs-lookup"><span data-stu-id="5c64e-201">value1 type</span></span>|<span data-ttu-id="5c64e-202">type valeur 2</span><span class="sxs-lookup"><span data-stu-id="5c64e-202">value2 type</span></span>|<span data-ttu-id="5c64e-203">type de résultat</span><span class="sxs-lookup"><span data-stu-id="5c64e-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="5c64e-204">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="5c64e-205">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="5c64e-206">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="5c64e-207">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="5c64e-208">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="5c64e-209">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="5c64e-210">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="5c64e-211">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="5c64e-212">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="5c64e-213">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="5c64e-214">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="5c64e-215">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="5c64e-216">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="5c64e-217">add</span><span class="sxs-lookup"><span data-stu-id="5c64e-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="5c64e-218">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `add.ovf.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-220">Calcule l'opération de bits AND de deux valeurs et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-221">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-222">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-222">Format</span></span>|<span data-ttu-id="5c64e-223">Instruction</span><span class="sxs-lookup"><span data-stu-id="5c64e-223">Instruction</span></span>|<span data-ttu-id="5c64e-224">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="5c64e-225">5F</span><span class="sxs-lookup"><span data-stu-id="5c64e-225">5F</span></span>|<span data-ttu-id="5c64e-226">et</span><span class="sxs-lookup"><span data-stu-id="5c64e-226">and</span></span>|<span data-ttu-id="5c64e-227">Détermine l’opération de bits AND de deux valeurs entières.</span><span class="sxs-lookup"><span data-stu-id="5c64e-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="5c64e-228">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-229">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-230">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-231">`value1` et `value2` sont dépilés ; l’opération de bits AND de deux valeurs est calculée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="5c64e-232">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-233">La `and` instruction calcule le AND au niveau du bit des valeurs des deux premiers sur la pile et laisse le résultat dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-234">`And` est une opération spécifique aux entiers.</span><span class="sxs-lookup"><span data-stu-id="5c64e-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="5c64e-235">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `and` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-237">Retourne un pointeur non managé vers la liste d'arguments de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-237">Returns an unmanaged pointer to the argument list of the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-238">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-239">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-239">Format</span></span>|<span data-ttu-id="5c64e-240">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-240">Assembly Format</span></span>|<span data-ttu-id="5c64e-241">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="5c64e-242">FE 00</span></span>|<span data-ttu-id="5c64e-243">arglist</span><span class="sxs-lookup"><span data-stu-id="5c64e-243">arglist</span></span>|<span data-ttu-id="5c64e-244">Retourne un handle de liste d’arguments pour la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="5c64e-245">Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.</span><span class="sxs-lookup"><span data-stu-id="5c64e-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="5c64e-246">Le `arglist` instruction retourne un handle opaque (un pointeur non managé, de type `native int`) qui représente la liste d’arguments de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="5c64e-247">Ce handle est uniquement valide pendant la durée de vie de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="5c64e-248">Vous pouvez, toutefois, passez le handle à d’autres méthodes tant que la méthode actuelle est sur le thread de contrôle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="5c64e-249">Vous pouvez uniquement exécuter la `arglist` instruction dans une méthode qui accepte un nombre variable d’arguments.</span><span class="sxs-lookup"><span data-stu-id="5c64e-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="5c64e-250">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `arglist` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-252">Transfère le contrôle à une instruction cible si les deux valeurs sont égales.</span><span class="sxs-lookup"><span data-stu-id="5c64e-252">Transfers control to a target instruction if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-253">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-254">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-254">Format</span></span>|<span data-ttu-id="5c64e-255">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-255">Assembly Format</span></span>|<span data-ttu-id="5c64e-256">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-257">3B < `int32` ></span></span>|<span data-ttu-id="5c64e-258">beq `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-258">beq `target`</span></span>|<span data-ttu-id="5c64e-259">Branche à l’instruction cible à l’offset `target` si les deux valeurs sont égales.</span><span class="sxs-lookup"><span data-stu-id="5c64e-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="5c64e-260">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-261">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-262">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-263">`value2` et `value1` sont dépilés ; si `value1` est égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-264">Le `beq` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est égal à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="5c64e-265">L’effet est le même résultat qu’un `ceq` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-266">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-267">Les types d’opérande acceptables sont encapsulés ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="5c64e-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="5c64e-268">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="5c64e-269">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction (ces transferts sont strictement limités et devez utiliser la <xref:System.Reflection.Emit.OpCodes.Leave> instruction à la place).</span><span class="sxs-lookup"><span data-stu-id="5c64e-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="5c64e-270">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `beq` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-271">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-272">Transfère le contrôle à une instruction cible (forme abrégée) si les deux valeurs sont égales.</span><span class="sxs-lookup"><span data-stu-id="5c64e-272">Transfers control to a target instruction (short form) if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-273">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-274">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-274">Format</span></span>|<span data-ttu-id="5c64e-275">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-275">Assembly Format</span></span>|<span data-ttu-id="5c64e-276">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-277">2E < `int8` ></span></span>|<span data-ttu-id="5c64e-278">beq.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-278">beq.s `target`</span></span>|<span data-ttu-id="5c64e-279">Branche à l’instruction cible à l’offset `target` Si égal, forme abrégée</span><span class="sxs-lookup"><span data-stu-id="5c64e-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="5c64e-280">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-281">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-282">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-283">`value2` et `value1` sont dépilés ; si `value1` est égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-284">Le `beq.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est égal à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="5c64e-285">L’effet est le même résultat qu’un `ceq` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-286">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-287">Les types d’opérande acceptables sont encapsulés ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="5c64e-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="5c64e-288">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="5c64e-289">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction (ces transferts sont strictement limités et devez utiliser la <xref:System.Reflection.Emit.OpCodes.Leave> instruction à la place).</span><span class="sxs-lookup"><span data-stu-id="5c64e-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="5c64e-290">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `beq.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-291">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-292">Transfère le contrôle à une instruction cible si la première valeur est supérieure ou égale à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-293">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-294">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-294">Format</span></span>|<span data-ttu-id="5c64e-295">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-295">Assembly Format</span></span>|<span data-ttu-id="5c64e-296">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="5c64e-297">3C `<int32>`</span></span>|<span data-ttu-id="5c64e-298">bge `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-298">bge `target`</span></span>|<span data-ttu-id="5c64e-299">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="5c64e-300">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-301">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-302">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-303">`value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-304">Le `bge` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="5c64e-305">L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-306">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-307">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-308">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-309">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-310">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-311">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure ou égale à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-312">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-313">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-313">Format</span></span>|<span data-ttu-id="5c64e-314">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-314">Assembly Format</span></span>|<span data-ttu-id="5c64e-315">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="5c64e-316">2F `<int8>`</span></span>|<span data-ttu-id="5c64e-317">bge.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-317">bge.s `target`</span></span>|<span data-ttu-id="5c64e-318">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-319">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-320">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-321">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-322">`value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-323">Le `bge.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="5c64e-324">L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-325">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-326">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-327">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-328">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-329">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-330">Transfère le contrôle à une instruction cible si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-331">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-332">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-332">Format</span></span>|<span data-ttu-id="5c64e-333">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-333">Assembly Format</span></span>|<span data-ttu-id="5c64e-334">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="5c64e-335">41 `<int32>`</span></span>|<span data-ttu-id="5c64e-336">bge.un `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-336">bge.un `target`</span></span>|<span data-ttu-id="5c64e-337">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième valeur (valeurs non signées).</span><span class="sxs-lookup"><span data-stu-id="5c64e-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="5c64e-338">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-339">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-340">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-341">`value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-342">Le `bge.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-343">L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-344">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-345">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-346">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-347">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-348">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-349">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-350">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-351">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-351">Format</span></span>|<span data-ttu-id="5c64e-352">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-352">Assembly Format</span></span>|<span data-ttu-id="5c64e-353">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-354">34 < `int8` ></span></span>|<span data-ttu-id="5c64e-355">bge.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-355">bge.un.s `target`</span></span>|<span data-ttu-id="5c64e-356">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure ou égale à la deuxième valeur (valeurs non signées), forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="5c64e-357">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-358">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-359">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-360">`value2` et `value1` sont dépilés ; si `value1` est supérieur ou égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-361">Le `bge.un.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur ou égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-362">L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-363">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-364">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-365">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-366">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bge.un.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-367">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-368">Transfère le contrôle à une instruction cible si la première valeur est supérieure à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-368">Transfers control to a target instruction if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-369">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-370">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-370">Format</span></span>|<span data-ttu-id="5c64e-371">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-371">Assembly Format</span></span>|<span data-ttu-id="5c64e-372">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-373">3D < `int32` ></span></span>|<span data-ttu-id="5c64e-374">bgt `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-374">bgt `target`</span></span>|<span data-ttu-id="5c64e-375">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="5c64e-376">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-377">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-378">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-379">`value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-380">Le `bgt` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="5c64e-381">L’effet est identique à l’exécution d’un `cgt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-382">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-383">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-384">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-385">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-386">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-387">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-388">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-389">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-389">Format</span></span>|<span data-ttu-id="5c64e-390">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-390">Assembly Format</span></span>|<span data-ttu-id="5c64e-391">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-392">30 < `int8` ></span></span>|<span data-ttu-id="5c64e-393">bgt.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-393">bgt.s `target`</span></span>|<span data-ttu-id="5c64e-394">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-395">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-396">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-397">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-398">`value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-399">Le `bgt.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="5c64e-400">L’effet est identique à l’exécution d’un `cgt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-401">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-402">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-403">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-404">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-405">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-406">Transfère le contrôle à une instruction cible si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-407">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-408">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-408">Format</span></span>|<span data-ttu-id="5c64e-409">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-409">Assembly Format</span></span>|<span data-ttu-id="5c64e-410">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-411">42 < `int32` ></span></span>|<span data-ttu-id="5c64e-412">bgt.un `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-412">bgt.un `target`</span></span>|<span data-ttu-id="5c64e-413">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur (valeurs non signées).</span><span class="sxs-lookup"><span data-stu-id="5c64e-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="5c64e-414">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-415">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-416">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-417">`value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-418">Le `bgt.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-419">L’effet est identique à l’exécution d’un `cgt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-420">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-421">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-422">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-423">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-424">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-425">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est supérieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-426">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-427">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-427">Format</span></span>|<span data-ttu-id="5c64e-428">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-428">Assembly Format</span></span>|<span data-ttu-id="5c64e-429">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-430">35 < `int8` ></span></span>|<span data-ttu-id="5c64e-431">bgt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-431">bgt.un.s `target`</span></span>|<span data-ttu-id="5c64e-432">Branche à l’instruction cible à l’offset spécifié si la première valeur est supérieure à la deuxième valeur (valeurs non signées), forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="5c64e-433">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-434">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-435">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-436">`value2` et `value1` sont dépilés ; si `value1` est supérieur à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-437">Le `bgt.un.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est supérieur à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-438">L’effet est identique à l’exécution d’un `cgt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-439">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-440">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-441">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-442">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bgt.un.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-443">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-444">Transfère le contrôle à une instruction cible si la première valeur est inférieure ou égale à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-445">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-446">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-446">Format</span></span>|<span data-ttu-id="5c64e-447">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-447">Assembly Format</span></span>|<span data-ttu-id="5c64e-448">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="5c64e-449">3E `<int32>`</span></span>|<span data-ttu-id="5c64e-450">bLe `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-450">ble `target`</span></span>|<span data-ttu-id="5c64e-451">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="5c64e-452">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-453">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-454">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-455">`value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-456">Le `ble` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="5c64e-457">L’effet est identique à l’exécution d’un `cgt` instruction (`cgt.un` à virgule flottante) suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-458">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-459">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-460">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-461">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-462">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-463">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure ou égale à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-464">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-465">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-465">Format</span></span>|<span data-ttu-id="5c64e-466">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-466">Assembly Format</span></span>|<span data-ttu-id="5c64e-467">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="5c64e-468">31 `<int8>`</span></span>|<span data-ttu-id="5c64e-469">bLe.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-469">ble.s `target`</span></span>|<span data-ttu-id="5c64e-470">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-471">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-472">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-473">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-474">`value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-475">Le `ble.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="5c64e-476">L’effet est identique à l’exécution d’un `cgt` instruction (`cgt.un` à virgule flottante) instruction suivie d’un`brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-477">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-478">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-479">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-480">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-481">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-482">Transfère le contrôle à une instruction cible si la première valeur est inférieure ou égale à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-483">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-484">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-484">Format</span></span>|<span data-ttu-id="5c64e-485">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-485">Assembly Format</span></span>|<span data-ttu-id="5c64e-486">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="5c64e-487">43 `<int32>`</span></span>|<span data-ttu-id="5c64e-488">bLe.un `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-488">ble.un `target`</span></span>|<span data-ttu-id="5c64e-489">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième valeur (valeurs non signées).</span><span class="sxs-lookup"><span data-stu-id="5c64e-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="5c64e-490">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-491">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-492">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-493">`value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-494">Le `ble.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-495">L’effet est identique à l’exécution d’un `cgt.un` instruction (`cgt` à virgule flottante) suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-496">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-497">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-498">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-499">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-500">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-501">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure ou égale à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-502">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-503">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-503">Format</span></span>|<span data-ttu-id="5c64e-504">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-504">Assembly Format</span></span>|<span data-ttu-id="5c64e-505">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="5c64e-506">36 `<int8>`</span></span>|<span data-ttu-id="5c64e-507">bLe.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-507">ble.un.s `target`</span></span>|<span data-ttu-id="5c64e-508">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure ou égale à la deuxième valeur (valeurs non signées), forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="5c64e-509">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-510">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-511">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-512">`value2` et `value1` sont dépilés ; si `value1` est inférieure ou égale à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-513">Le `ble.un.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-514">L’effet est identique à l’exécution d’un `cgt.un` instruction (`cgt` à virgule flottante) suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-515">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-516">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-517">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-518">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ble.un.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-519">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-520">Transfère le contrôle à une instruction cible si la première valeur est inférieure à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-520">Transfers control to a target instruction if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-521">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-522">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-522">Format</span></span>|<span data-ttu-id="5c64e-523">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-523">Assembly Format</span></span>|<span data-ttu-id="5c64e-524">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-525">3F < `int32` ></span></span>|<span data-ttu-id="5c64e-526">blt `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-526">blt `target`</span></span>|<span data-ttu-id="5c64e-527">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="5c64e-528">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-529">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-530">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-531">`value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-532">Le `blt` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure ou égale à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="5c64e-533">L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-534">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-535">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-536">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-537">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-538">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-539">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure à la deuxième.</span><span class="sxs-lookup"><span data-stu-id="5c64e-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-540">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-541">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-541">Format</span></span>|<span data-ttu-id="5c64e-542">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-542">Assembly Format</span></span>|<span data-ttu-id="5c64e-543">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-544">32 < `int8` ></span></span>|<span data-ttu-id="5c64e-545">blt.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-545">blt.s `target`</span></span>|<span data-ttu-id="5c64e-546">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-547">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-548">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-549">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-550">`value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-551">Le `blt.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="5c64e-552">L’effet est identique à l’exécution d’un `clt` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-553">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-554">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-555">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-556">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-557">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-558">Transfère le contrôle à une instruction cible si la première valeur est inférieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-559">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-560">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-560">Format</span></span>|<span data-ttu-id="5c64e-561">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-561">Assembly Format</span></span>|<span data-ttu-id="5c64e-562">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-563">44 < `int32` ></span></span>|<span data-ttu-id="5c64e-564">blt.un `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-564">blt.un `target`</span></span>|<span data-ttu-id="5c64e-565">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième valeur (valeurs non signées).</span><span class="sxs-lookup"><span data-stu-id="5c64e-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="5c64e-566">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-567">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-568">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-569">`value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-570">Le `blt.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-571">L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-572">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-573">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-574">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-575">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-576">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-577">Transfère le contrôle à une instruction cible (forme abrégée) si la première valeur est inférieure à la deuxième lors de la comparaison des valeurs entières non signées ou des valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-578">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-579">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-579">Format</span></span>|<span data-ttu-id="5c64e-580">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-580">Assembly Format</span></span>|<span data-ttu-id="5c64e-581">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-582">37 < `int8` ></span></span>|<span data-ttu-id="5c64e-583">blt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-583">blt.un.s `target`</span></span>|<span data-ttu-id="5c64e-584">Branche à l’instruction cible à l’offset spécifié si la première valeur est inférieure à la deuxième valeur (valeurs non signées), forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="5c64e-585">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-586">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-587">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-588">`value2` et `value1` sont dépilés ; si `value1` est inférieure à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-589">Le `blt.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` est inférieure à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-590">L’effet est identique à l’exécution d’un `clt.un` instruction suivie d’un `brtrue` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-591">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-592">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-593">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-594">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `blt.un.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-595">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-596">Transfère le contrôle à une instruction cible lorsque deux valeurs entières non signées ou valeurs float non ordonnées ne sont pas égales.</span><span class="sxs-lookup"><span data-stu-id="5c64e-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-597">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-598">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-598">Format</span></span>|<span data-ttu-id="5c64e-599">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-599">Assembly Format</span></span>|<span data-ttu-id="5c64e-600">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-601">40 < `int32` ></span></span>|<span data-ttu-id="5c64e-602">bne.un `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-602">bne.un `target`</span></span>|<span data-ttu-id="5c64e-603">Branche à la cible instruction à l’offset spécifié si les deux valeurs entières non signées ne sont ne pas égales (valeurs non signées).</span><span class="sxs-lookup"><span data-stu-id="5c64e-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="5c64e-604">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-605">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-606">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-607">`value2` et `value1` sont dépilés ; si `value1` n’est pas égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-608">Le `bne.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` n’est pas égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-609">L’effet est identique à l’exécution d’un `ceq` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-610">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-611">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-612">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-613">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bne.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-614">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-615">Transfère le contrôle à une instruction cible lorsque deux valeurs entières non signées ou valeurs float non ordonnées ne sont pas égales.</span><span class="sxs-lookup"><span data-stu-id="5c64e-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-616">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-617">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-617">Format</span></span>|<span data-ttu-id="5c64e-618">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-618">Assembly Format</span></span>|<span data-ttu-id="5c64e-619">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-620">33 < `int8` ></span></span>|<span data-ttu-id="5c64e-621">bne.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-621">bne.un.s `target`</span></span>|<span data-ttu-id="5c64e-622">Branche à la cible instruction à l’offset spécifié si les deux valeurs entières non signées ne sont pas égales (valeurs non signées), forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="5c64e-623">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-624">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-625">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-626">`value2` et `value1` sont dépilés ; si `value1` n’est pas égal à `value2`, cette opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="5c64e-627">Le `bne.un` instruction transfère le contrôle à l’instruction cible spécifiée si `value1` n’est pas égal à `value2`, par rapport à l’aide d’entières non signées ou valeurs float non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="5c64e-628">L’effet est identique à l’exécution d’un `ceq` instruction suivie d’un `brfalse` branche à l’instruction cible spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="5c64e-629">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-630">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-631">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-632">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `bne.un.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-633">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-634">Convertit un type valeur en une référence d’objet (type <see langword="O" />).</span><span class="sxs-lookup"><span data-stu-id="5c64e-634">Converts a value type to an object reference (type <see langword="O" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-635">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-636">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-636">Format</span></span>|<span data-ttu-id="5c64e-637">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-637">Assembly Format</span></span>|<span data-ttu-id="5c64e-638">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-639">8C < `T` ></span></span>|<span data-ttu-id="5c64e-640">zone `valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="5c64e-640">box `valTypeToken`</span></span>|<span data-ttu-id="5c64e-641">Convertir un type valeur (du type spécifié dans `valTypeToken`) à une référence d’objet true.</span><span class="sxs-lookup"><span data-stu-id="5c64e-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="5c64e-642">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-643">Un type valeur est envoyé à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-644">Le type de valeur est retirée de la pile ; le `box` opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="5c64e-645">Une référence d’objet pour le type de valeur « boxed » qui en résulte est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-646">Un type valeur a deux représentations distinctes au sein de l’Infrastructure (CLI) :</span><span class="sxs-lookup"><span data-stu-id="5c64e-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="5c64e-647">Un formulaire « brut » utilisé lorsqu’un type valeur est incorporé au sein d’un autre objet ou sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="5c64e-648">Un formulaire « boxed », où les données dans le type de valeur sont encapsulées (boxed) dans un objet afin qu’il peut exister une entité indépendante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="5c64e-649">Le `box` instruction convertit le type de valeur « brut » (unboxed) en une référence d’objet (type `O`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="5c64e-650">Cela s’effectue en créant un nouvel objet et de copie des données à partir du type de valeur dans l’objet nouvellement alloué.</span><span class="sxs-lookup"><span data-stu-id="5c64e-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="5c64e-651">`valTypeToken` est un jeton de métadonnées indiquant le type du type de valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-652"><xref:System.OutOfMemoryException> est levée si la mémoire est insuffisante pour satisfaire la requête.</span><span class="sxs-lookup"><span data-stu-id="5c64e-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="5c64e-653"><xref:System.TypeLoadException> est levée si la classe est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="5c64e-654">Cela est généralement détecté lorsque le langage MSIL (Microsoft Intermediate Language) est converti en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-655">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `box` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-656">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-657">Transfère le contrôle à une instruction cible de manière non conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-657">Unconditionally transfers control to a target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-658">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-659">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-659">Format</span></span>|<span data-ttu-id="5c64e-660">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-660">Assembly Format</span></span>|<span data-ttu-id="5c64e-661">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-662">38 < `int32` ></span></span>|<span data-ttu-id="5c64e-663">br `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-663">br `target`</span></span>|<span data-ttu-id="5c64e-664">Branches à une instruction cible à l’offset spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="5c64e-665">Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.</span><span class="sxs-lookup"><span data-stu-id="5c64e-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="5c64e-666">La `br` instruction transfère sans condition le contrôle à une instruction cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="5c64e-667">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-668">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-669">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-670">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `br` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-671">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-672">Transfère le contrôle à une instruction cible de manière non conditionnelle (forme abrégée).</span><span class="sxs-lookup"><span data-stu-id="5c64e-672">Unconditionally transfers control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-673">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-674">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-674">Format</span></span>|<span data-ttu-id="5c64e-675">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-675">Assembly Format</span></span>|<span data-ttu-id="5c64e-676">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-677">2B < `int8` ></span></span>|<span data-ttu-id="5c64e-678">br.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-678">br.s `target`</span></span>|<span data-ttu-id="5c64e-679">Branches à une instruction cible à l’offset spécifié, la forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-680">Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.</span><span class="sxs-lookup"><span data-stu-id="5c64e-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="5c64e-681">La `br.s` instruction transfère sans condition le contrôle à une instruction cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="5c64e-682">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-683">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-684">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-685">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `br.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-686">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-687">Active l'infrastructure CLI de façon à informer le débogueur qu'un point d'arrêt a été dépassé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-688">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-689">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-689">Format</span></span>|<span data-ttu-id="5c64e-690">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-690">Assembly Format</span></span>|<span data-ttu-id="5c64e-691">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-692">01</span><span class="sxs-lookup"><span data-stu-id="5c64e-692">01</span></span>|<span data-ttu-id="5c64e-693">break</span><span class="sxs-lookup"><span data-stu-id="5c64e-693">break</span></span>|<span data-ttu-id="5c64e-694">signale à un débogueur qu’un point d’arrêt a été atteint.</span><span class="sxs-lookup"><span data-stu-id="5c64e-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="5c64e-695">Aucun comportement de la pile d’évaluation n’est effectuées par cette opération.</span><span class="sxs-lookup"><span data-stu-id="5c64e-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="5c64e-696">La `break` instruction est prise en charge de débogage.</span><span class="sxs-lookup"><span data-stu-id="5c64e-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="5c64e-697">Il signale l’interface CLI pour informer le débogueur qu’un point d’arrêt a été dépassé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="5c64e-698">Il n’a aucun autre effet sur l’état de l’interpréteur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="5c64e-699">La `break` instruction a le plus petit possible taille activation code instructions mise à jour corrective avec un point d’arrêt et d’affecter le code environnant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="5c64e-700">La `break` instruction peut intercepter un débogueur, ne rien faire ou lever une exception de sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="5c64e-701">Le comportement exact est défini par l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="5c64e-702">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `break` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-704">Transfère le contrôle à une instruction cible si <paramref name="value" /> est <see langword="false" />, une référence null (<see langword="Nothing" /> en Visual Basic), ou zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-705">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-706">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-706">Format</span></span>|<span data-ttu-id="5c64e-707">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-707">Assembly Format</span></span>|<span data-ttu-id="5c64e-708">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-709">39 < `int32` ></span></span>|<span data-ttu-id="5c64e-710">brfalse `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="5c64e-711">brnull `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="5c64e-712">brzero correspondants `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-712">brzero `target`</span></span>|<span data-ttu-id="5c64e-713">Branches à une instruction cible à l’offset spécifié si `false`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="5c64e-714">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-715">`value` est placé sur la pile par une opération précédente.</span><span class="sxs-lookup"><span data-stu-id="5c64e-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="5c64e-716">`value` est retirée de la pile ; Si `value` est `false`, créer une branche vers `target`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="5c64e-717">Le `brfalse` instruction (et ses alias `brnull` et `brzero`) transfère le contrôle à l’instruction cible spécifiée si `value` (de type `int32`, `int64`, référence d’objet `O`managé pointeur `&`, pointeur transitoire `*`, `native int`) est égal à zéro (`false`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="5c64e-718">Si `value` est différente de zéro (`true`) l’exécution se poursuit à l’instruction suivante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="5c64e-719">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-720">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-721">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-722">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brfalse` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-723">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-724">Transfère le contrôle à une instruction cible si <paramref name="value" /> est <see langword="false" />, une référence null ou zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-725">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-726">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-726">Format</span></span>|<span data-ttu-id="5c64e-727">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-727">Assembly Format</span></span>|<span data-ttu-id="5c64e-728">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-729">2C <`int8` ></span></span>|<span data-ttu-id="5c64e-730">brfalse.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="5c64e-731">brnull.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="5c64e-732">brzero.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-732">brzero.s `target`</span></span>|<span data-ttu-id="5c64e-733">Branches à une instruction cible à l’offset spécifié si `false`, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-734">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-735">`value` est placé sur la pile par une opération précédente.</span><span class="sxs-lookup"><span data-stu-id="5c64e-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="5c64e-736">`value` est retirée de la pile ; Si `value` est `false`, créer une branche vers `target`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="5c64e-737">Le `brfalse.s` instruction (et ses alias `brnull` et `brzero`) transfère le contrôle à l’instruction cible spécifiée si `value` (de type `int32`, `int64`, référence d’objet `O`managé pointeur `&`, pointeur transitoire `*`, `native int`) est égal à zéro (`false`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="5c64e-738">Si `value` est différente de zéro (`true`) l’exécution se poursuit à l’instruction suivante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="5c64e-739">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-740">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-741">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-742">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brfalse.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-743">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-744">Transfère le contrôle à une instruction cible si <paramref name="value" /> est <see langword="true" />, non null ou différent de zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-745">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-746">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-746">Format</span></span>|<span data-ttu-id="5c64e-747">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-747">Assembly Format</span></span>|<span data-ttu-id="5c64e-748">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-749">3A < `int32` ></span></span>|<span data-ttu-id="5c64e-750">brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="5c64e-751">brinst `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-751">brinst `target`</span></span>|<span data-ttu-id="5c64e-752">Créer une branche vers une instruction cible à l’offset spécifié si différente de zéro (`true`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="5c64e-753">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-754">`value` est placé sur la pile par une opération précédente.</span><span class="sxs-lookup"><span data-stu-id="5c64e-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="5c64e-755">`value` est retirée de la pile ; Si `value` est `true`, créer une branche vers `target`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="5c64e-756">Le `brtrue` instruction transfère le contrôle à l’instruction cible spécifiée si `value` (type `native int`) est différent de zéro (`true`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="5c64e-757">Si `value` est égal à zéro (`false`) l’exécution se poursuit à l’instruction suivante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="5c64e-758">Si `value` est une référence d’objet (type `O`) puis `brinst` (un alias pour `brtrue`) transfère le contrôle s’il représente une instance d’un objet (par exemple, si elle n’est pas la référence d’objet null ; consultez <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="5c64e-759">L’instruction de la cible est représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-760">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-761">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-762">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brtrue` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-763">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-764">Transfère le contrôle à une instruction cible (forme abrégée) si <paramref name="value" /> est <see langword="true" />, non null ou différent de zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-765">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-766">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-766">Format</span></span>|<span data-ttu-id="5c64e-767">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-767">Assembly Format</span></span>|<span data-ttu-id="5c64e-768">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-769">2D < `int8` ></span></span>|<span data-ttu-id="5c64e-770">brtrue.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="5c64e-771">brinst.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-771">brinst.s `target`</span></span>|<span data-ttu-id="5c64e-772">Créer une branche vers une instruction cible à l’offset spécifié si différente de zéro (`true`), forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="5c64e-773">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-774">`value` est placé sur la pile par une opération précédente.</span><span class="sxs-lookup"><span data-stu-id="5c64e-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="5c64e-775">`value` est retirée de la pile ; Si `value` est `true`, créer une branche vers `target`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="5c64e-776">Le `brtrue.s` instruction transfère le contrôle à l’instruction cible spécifiée si `value` (type `native int`) est différent de zéro (`true`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="5c64e-777">Si `value` est égal à zéro (`false`) l’exécution se poursuit à l’instruction suivante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="5c64e-778">Si `value` est une référence d’objet (type `O`) puis `brinst` (un alias pour `brtrue`) transfère le contrôle s’il représente une instance d’un objet (par exemple, si elle n’est pas la référence d’objet null ; consultez <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="5c64e-779">L’instruction de la cible est représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-780">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="5c64e-781">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-782">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `brtrue.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-783">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-784">Appelle la méthode indiquée par le descripteur de méthode passé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-784">Calls the method indicated by the passed method descriptor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-785">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-786">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-786">Format</span></span>|<span data-ttu-id="5c64e-787">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-787">Assembly Format</span></span>|<span data-ttu-id="5c64e-788">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-789">28 < `T` ></span></span>|<span data-ttu-id="5c64e-790">Appel `methodDesc`</span><span class="sxs-lookup"><span data-stu-id="5c64e-790">call `methodDesc`</span></span>|<span data-ttu-id="5c64e-791">Appelez la méthode décrite par `methodDesc`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="5c64e-792">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-793">Arguments de méthode `arg1` via `argN` sont envoyées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-794">Arguments de méthode `arg1` via `argN` sont dépilés ; l’appel de méthode est effectué avec ces arguments et le contrôle est transféré à la méthode référencée par le descripteur de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="5c64e-795">Lorsque vous avez terminé, une valeur de retour est générée par la méthode de l’appelé et envoyée à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="5c64e-796">La valeur de retour est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-797">La `call` instruction appelle la méthode indiquée par le descripteur de méthode passé avec l’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="5c64e-798">Le descripteur de méthode est un jeton de métadonnées qui indique la méthode à l’appel et le nombre, le type et l’ordre des arguments qui ont été placés sur la pile à passer à cette méthode, ainsi que la convention d’appel à utiliser.</span><span class="sxs-lookup"><span data-stu-id="5c64e-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="5c64e-799">Le `call` instruction peut être immédiatement précédée d’un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) instruction pour spécifier que l’état actuel de la méthode doit être libéré avant le transfert du contrôle du préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="5c64e-800">Si l’appel transfère le contrôle à une méthode de confiance plus élevé que la méthode d’origine, le frame de pile n’est pas libéré.</span><span class="sxs-lookup"><span data-stu-id="5c64e-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="5c64e-801">Au lieu de cela, l’exécution se poursuit en mode silencieux comme si le `tail` n’avait pas été fourni.</span><span class="sxs-lookup"><span data-stu-id="5c64e-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="5c64e-802">Le jeton de métadonnées transporte des informations suffisantes pour déterminer si l’appel concerne une méthode statique, une méthode d’instance, une méthode virtuelle ou une fonction globale.</span><span class="sxs-lookup"><span data-stu-id="5c64e-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="5c64e-803">Dans tous ces cas l’adresse de destination est entièrement déterminée à partir du descripteur de méthode (Ceci contraste avec le <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction d’appel de méthodes virtuelles, où l’adresse de destination dépend également du type de runtime de l’instance référence envoyé avant le <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="5c64e-804">Les arguments sont placés sur la pile dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="5c64e-805">Autrement dit, le premier argument est calculé et placé sur la pile, puis le deuxième argument, puis le troisième, jusqu'à ce que tous les arguments nécessaires sont située en haut de la pile dans l’ordre décroissant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="5c64e-806">Il existe trois cas particuliers importants :</span><span class="sxs-lookup"><span data-stu-id="5c64e-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="5c64e-807">Les appels à une instance (ou virtuel) méthode doit transmettre cette référence d’instance avant tout l’argument visible par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="5c64e-808">La référence d’instance ne doit pas être une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="5c64e-809">La signature dans les métadonnées ne contient pas une entrée dans la liste de paramètres pour le `this` pointeur ; au lieu de cela, elle utilise un bit pour indiquer si la méthode requiert le passage du `this` pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="5c64e-810">Il est possible d’appeler une méthode virtuelle à l’aide `call` (au lieu de `callvirt`) ; cela indique que la méthode doit être résolu à l’aide de la classe spécifiée par la méthode plutôt que comme spécifié dynamiquement à partir de l’objet appelé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="5c64e-811">Notez que d’un délégué `Invoke` méthode peut être appelée avec soit le `call` ou `callvirt` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="5c64e-812"><xref:System.Security.SecurityException> peut être levée si le système de sécurité n’accorde pas l’appelant l’accès à la méthode appelée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="5c64e-813">La vérification de sécurité peut se produire lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif plutôt qu’au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5c64e-814">Lorsque vous appelez des méthodes de System.Object sur des types valeur, envisagez d’utiliser le `constrained` avec le préfixe le `callvirt` instruction au lieu de l’émission d’un `call` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="5c64e-815">Cela supprime la nécessité d’émettre un IL différent en fonction de la valeur déterminant le type de valeur substitue la méthode, en évitant un problème potentiel de la gestion des versions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="5c64e-816">Envisagez d’utiliser le `constrained` préfixe lors de l’appel des méthodes d’interface sur des types valeur, étant donné que la méthode de type valeur mise en œuvre de la méthode d’interface peut être modifié à l’aide un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="5c64e-817">Ces problèmes sont décrits plus en détail dans le <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="5c64e-818">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `call` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-819">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="5c64e-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="5c64e-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5c64e-821">Le <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> méthode est fournie pour `varargs` appels.</span><span class="sxs-lookup"><span data-stu-id="5c64e-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="5c64e-822">Utilisez le <xref:System.Reflection.Emit.ILGenerator.Emit%2A> méthode pour les appels normaux.</span><span class="sxs-lookup"><span data-stu-id="5c64e-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-823">Appelle la méthode indiquée dans la pile d'évaluation (sous la forme d'un pointeur vers un point d'entrée) avec les arguments décrits par une convention d'appel.</span><span class="sxs-lookup"><span data-stu-id="5c64e-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-824">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-825">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-825">Format</span></span>|<span data-ttu-id="5c64e-826">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-826">Assembly Format</span></span>|<span data-ttu-id="5c64e-827">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-828">29 < `T` ></span></span>|<span data-ttu-id="5c64e-829">calli `callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="5c64e-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="5c64e-830">Appelle la méthode pointée avec les arguments décrits par la convention d’appel.</span><span class="sxs-lookup"><span data-stu-id="5c64e-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="5c64e-831">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-832">Arguments de méthode `arg1` via `argN` sont envoyées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-833">Le pointeur d’entrée de méthode est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-834">Arguments de méthode `arg1` via `argN` et le pointeur d’entrée de méthode sont dépilés ; l’appel à la méthode est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="5c64e-835">Lorsque vous avez terminé, une valeur de retour est générée par la méthode de l’appelé et envoyée à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="5c64e-836">La valeur de retour est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-837">Le `calli` instruction appelle le pointeur d’entrée de méthode avec les arguments `arg1` via `argN`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="5c64e-838">Les types de ces arguments sont décrits par la convention d’appel spécifique (`callSiteDesc`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="5c64e-839">Le `calli` instruction peut être immédiatement précédée d’un `tail` préfixe (<xref:System.Reflection.Emit.OpCodes.Tailcall>) pour spécifier que l’état actuel de la méthode doit être libéré avant le transfert du contrôle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="5c64e-840">Si l’appel transfère le contrôle à une méthode de confiance plus élevé que la méthode d’origine le frame de pile n’est pas libéré ; au lieu de cela, l’exécution se poursuit en silence comme si le `tail` n’avait pas été fourni.</span><span class="sxs-lookup"><span data-stu-id="5c64e-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="5c64e-841">Le pointeur d’entrée de méthode est censé pour être un pointeur spécifique en code natif (de l’ordinateur cible) qui peut être appelée de manière légitime avec les arguments décrits par la convention d’appel (un jeton de métadonnées pour une signature autonome).</span><span class="sxs-lookup"><span data-stu-id="5c64e-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="5c64e-842">Ce type de pointeur peut être créé à l’aide de la <xref:System.Reflection.Emit.OpCodes.Ldftn> ou <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> obtenir des instructions, ou transmise par le code natif.</span><span class="sxs-lookup"><span data-stu-id="5c64e-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="5c64e-843">La convention d’appel n’est pas vérifiée dynamiquement, par conséquent, code qui utilise un `calli` instruction ne fonctionne pas correctement si la destination n’utilise pas réellement la convention d’appel spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="5c64e-844">Les arguments sont placés sur la pile dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="5c64e-845">Autrement dit, le premier argument est calculé et placé sur la pile, puis le deuxième argument, puis le troisième, jusqu'à ce que tous les arguments nécessaires sont située en haut de la pile dans l’ordre décroissant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="5c64e-846">La séquence de génération de code pour une instance ou une méthode virtuelle doit transmettre cette référence d’instance (qui ne doit pas être une référence null) avant tout argument visible par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="5c64e-847"><xref:System.Security.SecurityException> peut être levée si le système de sécurité n’accorde pas l’accès de l’appelant à la méthode appelée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="5c64e-848">La vérification de sécurité peut se produire lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-849">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> méthodes peuvent être utilisées pour effectuer un `calli` obtenir des instructions sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="5c64e-850">Notez que `calli` doit être appelé via les méthodes ci-dessous au lieu d’utiliser la <xref:System.Reflection.Emit.ILGenerator.Emit%2A> classe pour placer l’instruction directement sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="5c64e-851">ILGenerator.EmitCalli (Opcode, CallingConventions, Type, Type [], Type[]) pour les appels à l’aide d’une convention d’appel managée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="5c64e-852">ILGenerator.EmitCalli (Opcode, Type[]) CallingConvention, Type, pour les appels à l’aide d’une convention d’appel non managée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-853">Appelle une méthode à liaison tardive sur un objet, en exécutant un push de la valeur de retour dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-854">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-855">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-855">Format</span></span>|<span data-ttu-id="5c64e-856">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-856">Assembly Format</span></span>|<span data-ttu-id="5c64e-857">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-858">6F < `T` ></span></span>|<span data-ttu-id="5c64e-859">callvirt `method`</span><span class="sxs-lookup"><span data-stu-id="5c64e-859">callvirt `method`</span></span>|<span data-ttu-id="5c64e-860">Appelle une méthode spécifique associée `obj`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="5c64e-861">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-862">Une référence d’objet `obj` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-863">Arguments de méthode `arg1` via `argN` sont envoyées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-864">Arguments de méthode `arg1` via `argN` et la référence d’objet `obj` sont dépilés ; l’appel de méthode est effectué avec ces arguments et le contrôle est transféré à la méthode dans `obj` référencé par la méthode jeton de métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="5c64e-865">Lorsque vous avez terminé, une valeur de retour est générée par la méthode de l’appelé et envoyée à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="5c64e-866">La valeur de retour est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-867">La `callvirt` instruction appelle une méthode à liaison tardive sur un objet.</span><span class="sxs-lookup"><span data-stu-id="5c64e-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="5c64e-868">Autrement dit, la méthode est choisie en fonction du type de runtime de `obj` plutôt que de la classe de compilation visible dans le pointeur de la méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="5c64e-869">`Callvirt` peut être utilisé pour appeler à la fois virtuels et de méthodes d’instance.</span><span class="sxs-lookup"><span data-stu-id="5c64e-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="5c64e-870">Le `callvirt` instruction peut être immédiatement précédée d’un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) pour spécifier que le frame de pile actuel doit être libéré avant de transférer le contrôle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="5c64e-871">Si l’appel transfère le contrôle à une méthode de confiance plus élevé que la méthode d’origine, le frame de pile ne sera pas publié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="5c64e-872">Le jeton de métadonnées de méthode fournit le nom, la classe et la signature de la méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="5c64e-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="5c64e-873">La classe associée `obj` est la classe dont il s’agit d’une instance.</span><span class="sxs-lookup"><span data-stu-id="5c64e-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="5c64e-874">Si la classe définit une méthode non statique qui correspond au nom de la méthode indiquée et signature, cette méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="5c64e-875">Dans le cas contraire, toutes les classes dans la chaîne de la classe de base de cette classe sont vérifiées dans l’ordre.</span><span class="sxs-lookup"><span data-stu-id="5c64e-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="5c64e-876">C’est une erreur si aucune méthode n’est trouvée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="5c64e-877">`Callvirt` Dépile l’objet et les arguments associés de la pile d’évaluation avant d’appeler la méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="5c64e-878">Si la méthode a une valeur de retour, elle est ajoutée à la pile à l’achèvement de la méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="5c64e-879">Sur le côté de l’appelé, le `obj` paramètre est accessible en tant qu’argument 0, `arg1` en tant qu’argument 1 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="5c64e-880">Les arguments sont placés sur la pile dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="5c64e-881">Autrement dit, le premier argument est calculé et placé sur la pile, puis le deuxième argument, puis le troisième, jusqu'à ce que tous les arguments nécessaires sont située en haut de la pile dans l’ordre décroissant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="5c64e-882">La référence d’instance `obj` (toujours obligatoire pour `callvirt`) doivent être envoyées avant les arguments visible par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="5c64e-883">La signature (contenue dans le jeton de métadonnées) pas besoin de contenir une entrée dans la liste de paramètres pour ce pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="5c64e-884">Notez qu’une méthode virtuelle peut également être appelée à l’aide de la <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="5c64e-885"><xref:System.MissingMethodException> est levée si une méthode non statique avec le nom indiqué et la signature est introuvable dans la classe associée `obj` ou l’un de ses classes de base.</span><span class="sxs-lookup"><span data-stu-id="5c64e-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="5c64e-886">Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-887"><xref:System.NullReferenceException> est levé si obj est null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="5c64e-888"><xref:System.Security.SecurityException> est levée si le système de sécurité n’accorde pas l’appelant l’accès à la méthode appelée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="5c64e-889">La vérification de sécurité peut se produire lorsque le fichier CIL est converti en code natif plutôt qu’au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5c64e-890">Lorsque vous appelez des méthodes de System.Object sur des types valeur, envisagez d’utiliser le `constrained` avec le préfixe le `callvirt` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="5c64e-891">Cela supprime la nécessité d’émettre un IL différent en fonction de la valeur déterminant le type de valeur substitue la méthode, en évitant un problème potentiel de la gestion des versions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="5c64e-892">Envisagez d’utiliser le `constrained` préfixe lors de l’appel des méthodes d’interface sur des types valeur, étant donné que la méthode de type valeur mise en œuvre de la méthode d’interface peut être modifié à l’aide un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="5c64e-893">Ces problèmes sont décrits plus en détail dans le <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="5c64e-894">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `callvirt` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-895">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="5c64e-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="5c64e-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-897">Tente d'effectuer un cast d'un objet passé par référence en classe spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-897">Attempts to cast an object passed by reference to the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-898">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-899">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-899">Format</span></span>|<span data-ttu-id="5c64e-900">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-900">Assembly Format</span></span>|<span data-ttu-id="5c64e-901">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-902">74 < `T` ></span></span>|<span data-ttu-id="5c64e-903">castclass `class`</span><span class="sxs-lookup"><span data-stu-id="5c64e-903">castclass `class`</span></span>|<span data-ttu-id="5c64e-904">Convertit un objet vers un nouvel objet de type `class`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="5c64e-905">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-906">Une référence d’objet est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-907">La référence d’objet est retirée de la pile ; l’objet référencé est convertie comme spécifié `class`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="5c64e-908">En cas de réussite, une nouvelle référence d’objet est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-909">Le `castclass` instruction tente d’effectuer un cast de la référence d’objet (type `O`) située en haut de la pile pour une classe spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="5c64e-910">La nouvelle classe est spécifiée par un jeton de métadonnées indiquant la classe souhaitée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="5c64e-911">Si la classe de l’objet en haut de la pile n’implémente pas la nouvelle classe (en supposant que la nouvelle classe est une interface) et n’est pas une classe dérivée de la nouvelle classe puis un <xref:System.InvalidCastException> est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="5c64e-912">Si la référence d’objet est une référence null, `castclass` réussit et retourne le nouvel objet comme une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-913"><xref:System.InvalidCastException> est levé si obj ne peut pas être casté en classe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="5c64e-914"><xref:System.TypeLoadException> est levée si la classe est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="5c64e-915">Cela est généralement détecté lorsqu’une instruction de langage MSIL (Microsoft Intermediate Language) est convertie en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-916">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `castclass` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-917">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-918">Compare deux valeurs.</span><span class="sxs-lookup"><span data-stu-id="5c64e-918">Compares two values.</span></span> <span data-ttu-id="5c64e-919">Si elles sont égales, la valeur entière 1 <see langword="(int32" />) est envoyée à la pile d’évaluation ; Sinon, 0 (<see langword="int32" />) est envoyée à la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-920">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-921">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-921">Format</span></span>|<span data-ttu-id="5c64e-922">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-922">Assembly Format</span></span>|<span data-ttu-id="5c64e-923">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="5c64e-924">FE 01</span></span>|<span data-ttu-id="5c64e-925">ceq</span><span class="sxs-lookup"><span data-stu-id="5c64e-925">ceq</span></span>|<span data-ttu-id="5c64e-926">Exécute un push de 1 si `value1` est égal à `value2`; sinon exécute un push de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="5c64e-927">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-928">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-929">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-930">`value2` et `value1` sont dépilés de la pile ; `value1` est comparé à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-931">Si `value1` est égal à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-932">Le `ceq` instruction compare `value1` et `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="5c64e-933">Si `value1` est égal à `value2`, la valeur 1 (de type `int32`) est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="5c64e-934">Sinon, 0 (de type `int32`) est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-935">Pour un nombre à virgule flottante, `ceq` retourne 0 si les nombres ne sont pas ordonnés (ou les deux sont des valeurs NaN).</span><span class="sxs-lookup"><span data-stu-id="5c64e-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="5c64e-936">Les valeurs infinies sont égales à eux-mêmes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="5c64e-937">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ceq` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-939">Compare deux valeurs.</span><span class="sxs-lookup"><span data-stu-id="5c64e-939">Compares two values.</span></span> <span data-ttu-id="5c64e-940">Si la première valeur est supérieure à la seconde, la valeur entière 1 <see langword="(int32" />) est envoyée à la pile d’évaluation ; Sinon, 0 (<see langword="int32" />) est envoyée à la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-941">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-942">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-942">Format</span></span>|<span data-ttu-id="5c64e-943">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-943">Assembly Format</span></span>|<span data-ttu-id="5c64e-944">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="5c64e-945">FE 02</span></span>|<span data-ttu-id="5c64e-946">cgt</span><span class="sxs-lookup"><span data-stu-id="5c64e-946">cgt</span></span>|<span data-ttu-id="5c64e-947">Exécute un push de 1 si `value1` est supérieur à `value2`; sinon exécute un push de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="5c64e-948">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-949">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-950">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-951">`value2` et `value1` sont dépilés de la pile ; `cgt` teste si `value1` est supérieur à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-952">Si `value1` est supérieur à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-953">Le `cgt` instruction compare `value1` et `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="5c64e-954">Si `value1` est strictement supérieur à `value2`, puis un `int32` la valeur 1 est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="5c64e-955">Sinon, un `int32` la valeur 0 est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="5c64e-956">Pour les nombres à virgule flottante, `cgt` retourne 0 si les nombres ne sont pas ordonnés (autrement dit, si un ou les deux arguments sont des valeurs NaN).</span><span class="sxs-lookup"><span data-stu-id="5c64e-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="5c64e-957">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cgt` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-959">Compare deux valeurs non signées ou non ordonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-959">Compares two unsigned or unordered values.</span></span> <span data-ttu-id="5c64e-960">Si la première valeur est supérieure à la seconde, la valeur entière 1 <see langword="(int32" />) est envoyée à la pile d’évaluation ; Sinon, 0 (<see langword="int32" />) est envoyée à la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-961">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-962">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-962">Format</span></span>|<span data-ttu-id="5c64e-963">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-963">Assembly Format</span></span>|<span data-ttu-id="5c64e-964">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="5c64e-965">FE 03</span></span>|<span data-ttu-id="5c64e-966">cgt.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-966">cgt.un</span></span>|<span data-ttu-id="5c64e-967">Exécute un push de 1 si `value1` est supérieur à `value2`; sinon exécute un push de 0 (valeurs non signées).</span><span class="sxs-lookup"><span data-stu-id="5c64e-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="5c64e-968">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-969">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-970">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-971">`value2` et `value1` sont dépilés de la pile ; `cgt.un` teste si `value1` est supérieur à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-972">Si `value1` est supérieur à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-973">Un `int32` la valeur 1 est ajoutée à la pile si une des opérations suivantes est `true` :</span><span class="sxs-lookup"><span data-stu-id="5c64e-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="5c64e-974">Pour les nombres à virgule flottante, `value1` n’est pas ordonné par rapport à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="5c64e-975">Pour les valeurs entières, `value1` est strictement supérieur à `value2` lorsqu’elles sont considérées comme des nombres non signés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="5c64e-976">Sinon, un `int32` la valeur 0 est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-977">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cgt.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-979">Lève <see cref="T:System.ArithmeticException" /> si la valeur n’est pas un nombre fini.</span><span class="sxs-lookup"><span data-stu-id="5c64e-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-980">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-981">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-981">Format</span></span>|<span data-ttu-id="5c64e-982">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-982">Assembly Format</span></span>|<span data-ttu-id="5c64e-983">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-984">C3</span><span class="sxs-lookup"><span data-stu-id="5c64e-984">C3</span></span>|<span data-ttu-id="5c64e-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="5c64e-985">ckfinite</span></span>|<span data-ttu-id="5c64e-986">lever <xref:System.ArithmeticException> si la valeur n’est pas un nombre fini.</span><span class="sxs-lookup"><span data-stu-id="5c64e-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="5c64e-987">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-988">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-988">`value` is pushed onto the stack.</span></span> 
  
2.  <span data-ttu-id="5c64e-989">`value` est retirée de la pile et la `ckfinite` instruction est exécutée sur celui-ci.</span><span class="sxs-lookup"><span data-stu-id="5c64e-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="5c64e-990">`value` sont réinsérées dans la pile si aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-991">Le `ckfinite instruction` lève <xref:System.ArithmeticException> si `value` (un nombre à virgule flottante) est soit un « not a number » valeur (NaN) ou un `+-` valeur d’infini.</span><span class="sxs-lookup"><span data-stu-id="5c64e-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="5c64e-992">`Ckfinite` laisse la valeur dans la pile si aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="5c64e-993">L’exécution n’est pas spécifiée si `value` n’est pas un nombre à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="5c64e-994"><xref:System.ArithmeticException> est levée si `value` n’est pas un nombre « normal ».</span><span class="sxs-lookup"><span data-stu-id="5c64e-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="5c64e-995">Notez qu’une exception spécifique ou une classe dérivée de <xref:System.ArithmeticException> peut être plus appropriée, en passant la valeur incorrecte au gestionnaire d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="5c64e-996">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ckfinite` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-998">Compare deux valeurs.</span><span class="sxs-lookup"><span data-stu-id="5c64e-998">Compares two values.</span></span> <span data-ttu-id="5c64e-999">Si la première valeur est inférieure à la seconde, la valeur entière 1 <see langword="(int32" />) est envoyée à la pile d’évaluation ; Sinon, 0 (<see langword="int32" />) est envoyée à la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1000">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1001">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1001">Format</span></span>|<span data-ttu-id="5c64e-1002">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1002">Assembly Format</span></span>|<span data-ttu-id="5c64e-1003">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="5c64e-1004">FE 04</span></span>|<span data-ttu-id="5c64e-1005">clt</span><span class="sxs-lookup"><span data-stu-id="5c64e-1005">clt</span></span>|<span data-ttu-id="5c64e-1006">Exécute un push de 1 si `value1` est inférieure à `value2`; sinon exécute un push de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="5c64e-1007">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1007">The stack transitional behavior, in sequential order, is:</span></span> 

1.  <span data-ttu-id="5c64e-1008">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1008">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1009">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1009">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-1010">`value2` et `value1` sont dépilés de la pile ; `clt` teste si `value1` est inférieure à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1010">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-1011">Si `value1` est inférieure à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1011">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1012">Le `clt` instruction compare `value1` et `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1012">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="5c64e-1013">Si `value1` est strictement inférieur à `value2`, puis un `int32` la valeur 1 est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1013">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="5c64e-1014">Sinon, un `int32` la valeur 0 est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1014">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="5c64e-1015">Pour les nombres à virgule flottante, `clt` retourne 0 si les nombres ne sont pas ordonnés (autrement dit, si un ou les deux arguments sont des valeurs NaN).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1015">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="5c64e-1016">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `clt` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1016">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1017">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1017">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1018">Compare les valeurs non signées ou non ordonnées <paramref name="value1" /> et <paramref name="value2" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1018">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span></span> <span data-ttu-id="5c64e-1019">If <paramref name="value1" /> est inférieure à <paramref name="value2" />, puis la valeur entière 1 <see langword="(int32" />) est envoyée à l’évaluation de pile ; sinon, 0 (<see langword="int32" />) est envoyée à la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1019">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1020">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1021">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1021">Format</span></span>|<span data-ttu-id="5c64e-1022">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1022">Assembly Format</span></span>|<span data-ttu-id="5c64e-1023">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1024">FE 05</span><span class="sxs-lookup"><span data-stu-id="5c64e-1024">FE 05</span></span>|<span data-ttu-id="5c64e-1025">clt.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1025">clt.un</span></span>|<span data-ttu-id="5c64e-1026">Exécute un push de 1 si `value1` est inférieure à `value2`; sinon exécute un push de 0 (valeurs non signées).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1026">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="5c64e-1027">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1028">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1028">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1029">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1029">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-1030">`value2` et `value1` sont dépilés de la pile ; `clt.un` teste si `value1` est inférieure à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1030">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-1031">Si `value1` est inférieure à `value2`, 1 est placé sur la pile ; sinon, 0 est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1031">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1032">Le `clt.un` instruction compare `value1` et `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1032">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="5c64e-1033">Un `int32` la valeur 1 est ajoutée à la pile si une des opérations suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1033">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="5c64e-1034">`value1` est strictement inférieur à `value2` (comme pour `clt`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1034">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="5c64e-1035">Pour les nombres à virgule flottante, `value1` n’est pas ordonné par rapport à `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1035">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="5c64e-1036">Pour les valeurs entières, `value1` est strictement inférieur à `value2` lorsqu’elles sont considérées comme des nombres non signés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1036">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="5c64e-1037">Sinon, un `int32` la valeur 0 est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1037">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1038">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `clt.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1038">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1039">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1039">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1040">Contraint le type sur lequel un appel à une méthode virtuelle est effectué.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1040">Constrains the type on which a virtual method call is made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1041">Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1041">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1042">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1042">Format</span></span>|<span data-ttu-id="5c64e-1043">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1043">Assembly Format</span></span>|<span data-ttu-id="5c64e-1044">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1044">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1045">FE 16 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-1045">FE 16 < `T` ></span></span>|<span data-ttu-id="5c64e-1046">contrainte.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1046">constrained.</span></span> `thisType`|<span data-ttu-id="5c64e-1047">Appel d’une méthode virtuelle sur un type contraint à être de type `T`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1047">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="5c64e-1048">Le `constrained` préfixe est autorisé uniquement sur un `callvirt` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1048">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="5c64e-1049">L’état de la pile MSIL à ce stade doit être comme suit :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1049">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="5c64e-1050">Un pointeur managé, `ptr`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1050">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="5c64e-1051">Le type de `ptr` doit être un pointeur managé (`&`) à `thisType`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1051">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="5c64e-1052">Notez que cela est différent du cas d’un sans préfixe `callvirt` qui attend une référence de `thisType`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1052">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="5c64e-1053">Arguments de méthode `arg1` via `argN` sont envoyées dans la pile, comme avec un sans préfixe `callvirt` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1053">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="5c64e-1054">Le `constrained` préfixe est conçu pour permettre `callvirt` instructions effectuées uniforme de façon indépendante si `thisType` est un type valeur ou un type référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1054">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="5c64e-1055">Quand un `callvirt` `method` l’instruction a été préfixée par `constrained` `thisType`, l’instruction est exécutée comme suit :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1055">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="5c64e-1056">Si `thisType` est un type référence (par opposition à un type valeur) puis `ptr` est déréférencé et passé en tant que le pointeur 'this' à la `callvirt` de `method`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1056">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="5c64e-1057">Si `thisType` est un type valeur et `thisType` implémente `method` puis `ptr` est passée non modifié comme le pointeur 'this' à un `call` `method` instruction, pour l’implémentation de `method` par `thisType`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1057">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="5c64e-1058">Si `thisType` est un type valeur et `thisType` n’implémente pas `method` puis `ptr` est déréférencé, boxed et passé en tant que le pointeur 'this' à la `callvirt` `method` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1058">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="5c64e-1059">Ce dernier cas peut se produire uniquement lorsque `method` a été définie sur <xref:System.Object>, <xref:System.ValueType>, ou <xref:System.Enum> et ne pas remplacé par `thisType`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1059">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="5c64e-1060">Dans ce cas, la conversion boxing entraîne une copie de l’objet d’origine qu’il veut.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1060">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="5c64e-1061">Toutefois, car aucune des méthodes de <xref:System.Object>, <xref:System.ValueType>, et <xref:System.Enum> modifier l’état de l’objet, cette action ne peut pas être détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1061">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="5c64e-1062">Le `constrained` préfixe prend en charge les générateurs IL qui créent du code générique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1062">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="5c64e-1063">Normalement la `callvirt` instruction n’est pas valide sur les types valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1063">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="5c64e-1064">Au lieu de cela, il est nécessaire que les compilateurs de langage intermédiaire exécutent de manière efficace la transformation « this » décrite ci-dessus au moment de la compilation, selon le type de `ptr` et la méthode appelée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1064">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="5c64e-1065">Toutefois, lorsque `ptr` est un type générique qui est inconnu au moment de la compilation, il n’est pas possible d’effectuer cette transformation au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1065">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="5c64e-1066">Le `constrained` opcode permet aux compilateurs IL d’effectuer un appel à une fonction virtuelle uniforme façon de s’il `ptr` est un type valeur ou un type référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1066">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="5c64e-1067">Même s’il est destiné à être le cas où `thisType` est une variable de type générique, le `constrained` peut réduire la complexité de la génération d’appels virtuels dans des langages qui masquent la distinction entre les types valeur et utilisez le préfixe également fonctionne pour les types non génériques et types de référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1067">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="5c64e-1068">À l’aide de la `constrained` préfixe évite également d’éventuels problèmes de versioning avec les types valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1068">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="5c64e-1069">Si le `constrained` préfixe n’est pas utilisé, IL différent doit être émis selon ou non un type valeur substitue à une méthode de System.Object.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1069">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="5c64e-1070">Par exemple, si un type valeur `V` substitue la méthode Object.ToString (), un `call` `V.ToString()` l’instruction est émise ; dans ce cas, un `box` instruction et un `callvirt` `Object.ToString()` instruction sont émis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1070">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="5c64e-1071">Un problème de contrôle de version peut se produire dans le premier cas, si la substitution est supprimée ultérieurement et dans ce cas si une substitution est ajoutée ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1071">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="5c64e-1072">Le `constrained` préfixe peut également servir pour l’appel de méthodes d’interface sur des types valeur, car la méthode de type valeur mise en œuvre de la méthode d’interface peut être changée à l’aide un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1072">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="5c64e-1073">Si le `constrained` préfixe n’est pas utilisé, le compilateur est forcé de choisir les de la valeur de méthodes du type à lier au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1073">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="5c64e-1074">À l’aide de la `constrained` préfixe permet au code MSIL de la lier à la méthode qui implémente la méthode d’interface au moment de l’exécution, plutôt qu’au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1074">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="5c64e-1075">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `constrained` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1075">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1076">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1076">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1077">Convertit la valeur située en haut de la pile d’évaluation en <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1077">Converts the value on top of the evaluation stack to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1078">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1078">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1079">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1079">Format</span></span>|<span data-ttu-id="5c64e-1080">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1080">Assembly Format</span></span>|<span data-ttu-id="5c64e-1081">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1081">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1082">D3</span><span class="sxs-lookup"><span data-stu-id="5c64e-1082">D3</span></span>|<span data-ttu-id="5c64e-1083">conv.i</span><span class="sxs-lookup"><span data-stu-id="5c64e-1083">conv.i</span></span>|<span data-ttu-id="5c64e-1084">Convertir en `native int`, exécution de type push `native int` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1084">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1085">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1085">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1086">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1086">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1087">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1087">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1088">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1088">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1089">Le `conv.i` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1089">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1090">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1090">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1091">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1091">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1092">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1092">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1093">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1093">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1094">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1094">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1095">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1095">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1096">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1096">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1097">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1097">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1098">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1098">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1099">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1099">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1100">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1100">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1101">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1101">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1102">Convertit la valeur située en haut de la pile d’évaluation en <see langword="int8" />, puis étend (remplit) à <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1102">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1103">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1103">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1104">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1104">Format</span></span>|<span data-ttu-id="5c64e-1105">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1105">Assembly Format</span></span>|<span data-ttu-id="5c64e-1106">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1106">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1107">67</span><span class="sxs-lookup"><span data-stu-id="5c64e-1107">67</span></span>|<span data-ttu-id="5c64e-1108">conv.i1</span><span class="sxs-lookup"><span data-stu-id="5c64e-1108">conv.i1</span></span>|<span data-ttu-id="5c64e-1109">Convertir en `int8`, exécution de type push `int32` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1109">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1110">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1110">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1111">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1111">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1112">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1112">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1113">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1113">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1114">Le `conv.i1` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1114">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1115">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1115">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1116">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1116">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1117">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1117">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1118">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1118">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1119">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1119">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1120">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1120">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1121">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1121">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1122">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1122">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1123">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1123">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1124">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1124">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1125">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1125">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1126">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1126">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1127">Convertit la valeur située en haut de la pile d’évaluation en <see langword="int16" />, puis étend (remplit) à <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1127">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1128">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1128">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1129">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1129">Format</span></span>|<span data-ttu-id="5c64e-1130">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1130">Assembly Format</span></span>|<span data-ttu-id="5c64e-1131">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1131">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1132">68</span><span class="sxs-lookup"><span data-stu-id="5c64e-1132">68</span></span>|<span data-ttu-id="5c64e-1133">conv.i2</span><span class="sxs-lookup"><span data-stu-id="5c64e-1133">conv.i2</span></span>|<span data-ttu-id="5c64e-1134">Convertir en `int16`, exécution de type push `int32` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1134">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1135">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1135">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1136">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1136">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1137">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1137">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1138">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1138">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1139">Le `conv.i2` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1139">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1140">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1140">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1141">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1141">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1142">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1142">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1143">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1143">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1144">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1144">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1145">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1145">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1146">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1146">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1147">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1147">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1148">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1148">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1149">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1149">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1150">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1150">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1151">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1151">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1152">Convertit la valeur située en haut de la pile d’évaluation en <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1152">Converts the value on top of the evaluation stack to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1153">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1153">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1154">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1154">Format</span></span>|<span data-ttu-id="5c64e-1155">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1155">Assembly Format</span></span>|<span data-ttu-id="5c64e-1156">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1156">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1157">69</span><span class="sxs-lookup"><span data-stu-id="5c64e-1157">69</span></span>|<span data-ttu-id="5c64e-1158">conv.i4</span><span class="sxs-lookup"><span data-stu-id="5c64e-1158">conv.i4</span></span>|<span data-ttu-id="5c64e-1159">Convertir en `int32`, exécution de type push `int32` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1159">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1160">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1160">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1161">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1161">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1162">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1162">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1163">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1163">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1164">Le `conv.i4` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1164">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1165">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1165">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1166">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1166">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1167">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1167">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1168">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1168">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1169">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1169">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1170">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1170">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1171">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1171">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1172">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1172">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1173">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1173">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1174">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1174">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1175">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1176">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1176">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1177">Convertit la valeur située en haut de la pile d’évaluation en <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1177">Converts the value on top of the evaluation stack to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1178">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1179">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1179">Format</span></span>|<span data-ttu-id="5c64e-1180">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1180">Assembly Format</span></span>|<span data-ttu-id="5c64e-1181">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1182">6A</span><span class="sxs-lookup"><span data-stu-id="5c64e-1182">6A</span></span>|<span data-ttu-id="5c64e-1183">conv.i8</span><span class="sxs-lookup"><span data-stu-id="5c64e-1183">conv.i8</span></span>|<span data-ttu-id="5c64e-1184">Convertir en `int64`, exécution de type push `int64` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1184">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1185">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1186">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1186">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1187">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1187">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1188">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1188">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1189">Le `conv.i8` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1189">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1190">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1190">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1191">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1191">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1192">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1192">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1193">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1193">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1194">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1194">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1195">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1195">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1196">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1196">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1197">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1197">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1198">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1198">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1199">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1199">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1200">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.i8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1202">Convertit la valeur signée en haut de la pile d’évaluation signés <see langword="native int" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1202">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1203">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1204">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1204">Format</span></span>|<span data-ttu-id="5c64e-1205">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1205">Assembly Format</span></span>|<span data-ttu-id="5c64e-1206">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1207">D4</span><span class="sxs-lookup"><span data-stu-id="5c64e-1207">D4</span></span>|<span data-ttu-id="5c64e-1208">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="5c64e-1208">conv.ovf.i</span></span>|<span data-ttu-id="5c64e-1209">Convertir un `native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1209">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1210">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1211">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1211">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1212">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1212">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1213">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1213">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1214">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1214">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1215">Le `conv.ovf.i` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1215">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1216">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1216">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1217">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1217">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1218">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1218">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1219"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1219"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1220">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1220">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1221">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1221">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1222">Convertit la valeur non signée en haut de la pile d’évaluation signés <see langword="native int" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1222">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1223">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1223">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1224">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1224">Format</span></span>|<span data-ttu-id="5c64e-1225">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1225">Assembly Format</span></span>|<span data-ttu-id="5c64e-1226">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1226">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1227">8A</span><span class="sxs-lookup"><span data-stu-id="5c64e-1227">8A</span></span>|<span data-ttu-id="5c64e-1228">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1228">conv.ovf.i.un</span></span>|<span data-ttu-id="5c64e-1229">Convertit une valeur non signée à un `native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1229">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1230">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1230">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1231">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1231">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1232">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1232">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1233">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1233">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1234">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1234">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1235">Le `conv.ovf.i.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1235">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1236">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1236">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1237">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1237">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1238">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1238">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1239"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1239"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1240">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1241">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1241">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1242">Convertit la valeur signée située en haut de la pile d’évaluation en <see langword="int8" /> signé et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> en cas de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1242">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1243">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1243">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1244">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1244">Format</span></span>|<span data-ttu-id="5c64e-1245">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1245">Assembly Format</span></span>|<span data-ttu-id="5c64e-1246">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1246">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1247">B3</span><span class="sxs-lookup"><span data-stu-id="5c64e-1247">B3</span></span>|<span data-ttu-id="5c64e-1248">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="5c64e-1248">conv.ovf.i1</span></span>|<span data-ttu-id="5c64e-1249">Convertir un `int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1249">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1250">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1250">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1251">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1251">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1252">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1252">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1253">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1253">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1254">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1254">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1255">Le `conv.ovf.i1` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1255">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1256">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1256">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1257">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1257">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1258">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1258">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1259"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1259"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1260">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1260">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1261">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1261">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1262">Convertit la valeur non signée en haut de la pile d’évaluation signés <see langword="int8" /> et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1262">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1263">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1263">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1264">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1264">Format</span></span>|<span data-ttu-id="5c64e-1265">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1265">Assembly Format</span></span>|<span data-ttu-id="5c64e-1266">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1266">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1267">82</span><span class="sxs-lookup"><span data-stu-id="5c64e-1267">82</span></span>|<span data-ttu-id="5c64e-1268">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1268">conv.ovf.i1.un</span></span>|<span data-ttu-id="5c64e-1269">Convertit une valeur non signée à un `int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1269">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1270">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1270">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1271">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1271">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1272">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1272">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1273">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1273">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1274">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1274">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1275">Le `conv.ovf.i1.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1275">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1276">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1276">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1277">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1277">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1278">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1278">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1279"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1279"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1280">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i1.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1280">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1281">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1281">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1282">Convertit la valeur signée en haut de la pile d’évaluation signés <see langword="int16" /> et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1282">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1283">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1283">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1284">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1284">Format</span></span>|<span data-ttu-id="5c64e-1285">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1285">Assembly Format</span></span>|<span data-ttu-id="5c64e-1286">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1286">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1287">B5</span><span class="sxs-lookup"><span data-stu-id="5c64e-1287">B5</span></span>|<span data-ttu-id="5c64e-1288">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="5c64e-1288">conv.ovf.i2</span></span>|<span data-ttu-id="5c64e-1289">Convertir un `int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1289">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1290">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1290">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1291">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1291">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1292">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1292">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1293">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1293">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1294">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1294">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1295">Le `conv.ovf.i2` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1295">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1296">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1296">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1297">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1297">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1298">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1298">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1299"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1299"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1300">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1300">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1301">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1301">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1302">Convertit la valeur non signée en haut de la pile d’évaluation signés <see langword="int16" /> et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1302">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1303">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1303">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1304">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1304">Format</span></span>|<span data-ttu-id="5c64e-1305">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1305">Assembly Format</span></span>|<span data-ttu-id="5c64e-1306">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1306">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1307">83</span><span class="sxs-lookup"><span data-stu-id="5c64e-1307">83</span></span>|<span data-ttu-id="5c64e-1308">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1308">conv.ovf.i2.un</span></span>|<span data-ttu-id="5c64e-1309">Convertit une valeur non signée à un `int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1309">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1310">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1310">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1311">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1311">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1312">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1312">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1313">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1313">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1314">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1314">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1315">Le `conv.ovf.i2.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1315">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1316">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1316">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1317">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1317">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1318">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1318">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1319"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1319"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1320">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i2.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1322">Convertit la valeur signée en haut de la pile d’évaluation signés <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1322">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1323">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1324">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1324">Format</span></span>|<span data-ttu-id="5c64e-1325">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1325">Assembly Format</span></span>|<span data-ttu-id="5c64e-1326">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1327">B7</span><span class="sxs-lookup"><span data-stu-id="5c64e-1327">B7</span></span>|<span data-ttu-id="5c64e-1328">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="5c64e-1328">conv.ovf.i4</span></span>|<span data-ttu-id="5c64e-1329">Convertir un `int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1329">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1330">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1331">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1331">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1332">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1332">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1333">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1333">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1334">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1334">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1335">Le `conv.ovf.i4` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1335">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1336">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1336">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1337">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1337">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1338">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1338">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1339"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1340">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1340">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1341">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1341">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1342">Convertit la valeur non signée en haut de la pile d’évaluation signés <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1342">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1343">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1343">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1344">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1344">Format</span></span>|<span data-ttu-id="5c64e-1345">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1345">Assembly Format</span></span>|<span data-ttu-id="5c64e-1346">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1346">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1347">84</span><span class="sxs-lookup"><span data-stu-id="5c64e-1347">84</span></span>|<span data-ttu-id="5c64e-1348">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1348">conv.ovf.i4.un</span></span>|<span data-ttu-id="5c64e-1349">Convertit une valeur non signée à un `int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1349">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1350">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1350">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1351">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1351">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1352">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1352">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1353">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1353">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1354">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1354">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1355">Le `conv.ovf.i4.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1355">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1356">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1356">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1357">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1357">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1358">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1358">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1359"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1359"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1360">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i4.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1361">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1361">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1362">Convertit la valeur signée en haut de la pile d’évaluation signés <see langword="int64" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1362">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1363">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1364">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1364">Format</span></span>|<span data-ttu-id="5c64e-1365">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1365">Assembly Format</span></span>|<span data-ttu-id="5c64e-1366">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1367">B9</span><span class="sxs-lookup"><span data-stu-id="5c64e-1367">B9</span></span>|<span data-ttu-id="5c64e-1368">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="5c64e-1368">conv.ovf.i8</span></span>|<span data-ttu-id="5c64e-1369">Convertir un `int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1369">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1370">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1371">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1371">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1372">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1372">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1373">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1373">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1374">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1374">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1375">Le `conv.ovf.i8` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1375">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1376">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1376">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1377">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1377">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1378">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1378">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1379"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1379"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1380">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1380">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1381">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1381">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1382">Convertit la valeur non signée en haut de la pile d’évaluation signés <see langword="int64" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1382">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1383">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1383">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1384">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1384">Format</span></span>|<span data-ttu-id="5c64e-1385">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1385">Assembly Format</span></span>|<span data-ttu-id="5c64e-1386">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1386">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1387">85</span><span class="sxs-lookup"><span data-stu-id="5c64e-1387">85</span></span>|<span data-ttu-id="5c64e-1388">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1388">conv.ovf.i8.un</span></span>|<span data-ttu-id="5c64e-1389">Convertit une valeur non signée à un `int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1389">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1390">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1390">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1391">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1391">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1392">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1392">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1393">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1393">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1394">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1394">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1395">Le `conv.ovf.i8.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1395">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1396">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1396">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1397">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1397">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1398">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1398">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1399"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1399"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1400">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.i8.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1400">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1401">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1401">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1402">Convertit la valeur signée en haut de la pile d’évaluation en <see langword="unsigned native int" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1402">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1403">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1403">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1404">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1404">Format</span></span>|<span data-ttu-id="5c64e-1405">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1405">Assembly Format</span></span>|<span data-ttu-id="5c64e-1406">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1406">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1407">D5</span><span class="sxs-lookup"><span data-stu-id="5c64e-1407">D5</span></span>|<span data-ttu-id="5c64e-1408">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="5c64e-1408">conv.ovf.u</span></span>|<span data-ttu-id="5c64e-1409">Convertir un `unsigned native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1409">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1410">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1410">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1411">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1411">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1412">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1412">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1413">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1413">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1414">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1414">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1415">Le `conv.ovf.u` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1415">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1416">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1416">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1417">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1417">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1418">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1418">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1419"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1419"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1420">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1420">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1421">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1421">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1422">Convertit la valeur non signée en haut de la pile d’évaluation en <see langword="unsigned native int" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1422">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1423">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1423">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1424">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1424">Format</span></span>|<span data-ttu-id="5c64e-1425">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1425">Assembly Format</span></span>|<span data-ttu-id="5c64e-1426">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1426">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1427">8B</span><span class="sxs-lookup"><span data-stu-id="5c64e-1427">8B</span></span>|<span data-ttu-id="5c64e-1428">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1428">conv.ovf.u.un</span></span>|<span data-ttu-id="5c64e-1429">Convertit valeur non signée en une `unsigned native int` (sur la pile en tant que `native int`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1429">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1430">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1430">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1431">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1431">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1432">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1432">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1433">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1433">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1434">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1434">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1435">Le `conv.ovf.u.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1435">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1436">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1436">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1437">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1437">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1438">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1438">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1439"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1439"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1440">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.uvf.u.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1440">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1441">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1441">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1442">Convertit la valeur signée en haut de la pile d’évaluation en <see langword="unsigned int8" /> et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1442">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1443">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1443">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1444">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1444">Format</span></span>|<span data-ttu-id="5c64e-1445">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1445">Assembly Format</span></span>|<span data-ttu-id="5c64e-1446">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1446">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1447">B4</span><span class="sxs-lookup"><span data-stu-id="5c64e-1447">B4</span></span>|<span data-ttu-id="5c64e-1448">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="5c64e-1448">conv.ovf.u1</span></span>|<span data-ttu-id="5c64e-1449">Convertir un `unsigned int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1449">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1450">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1450">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1451">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1451">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1452">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1452">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1453">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1453">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1454">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1454">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1455">Le `conv.ovf.u1` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1455">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1456">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1456">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1457">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1457">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1458">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1458">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1459"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1459"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1460">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1460">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1461">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1461">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1462">Convertit la valeur non signée en haut de la pile d’évaluation en <see langword="unsigned int8" /> et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1462">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1463">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1463">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1464">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1464">Format</span></span>|<span data-ttu-id="5c64e-1465">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1465">Assembly Format</span></span>|<span data-ttu-id="5c64e-1466">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1466">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1467">86</span><span class="sxs-lookup"><span data-stu-id="5c64e-1467">86</span></span>|<span data-ttu-id="5c64e-1468">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1468">conv.ovf.u1.un</span></span>|<span data-ttu-id="5c64e-1469">Convertit une valeur non signée à un `unsigned int8` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1469">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1470">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1470">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1471">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1471">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1472">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1472">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1473">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1473">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1474">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1474">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1475">Le `conv.ovf.u1.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1475">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1476">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1476">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1477">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1477">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1478">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1478">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1479"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1479"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1480">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u1.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1482">Convertit la valeur signée en haut de la pile d’évaluation en <see langword="unsigned int16" /> et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1482">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1483">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1484">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1484">Format</span></span>|<span data-ttu-id="5c64e-1485">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1485">Assembly Format</span></span>|<span data-ttu-id="5c64e-1486">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1487">B6</span><span class="sxs-lookup"><span data-stu-id="5c64e-1487">B6</span></span>|<span data-ttu-id="5c64e-1488">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="5c64e-1488">conv.ovf.u2</span></span>|<span data-ttu-id="5c64e-1489">Convertir un `unsigned int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1489">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1490">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1491">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1491">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1492">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1492">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1493">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1493">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1494">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1494">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1495">Le `conv.ovf.u2` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1495">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1496">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1496">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1497">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1497">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1498">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1498">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1499"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1499"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1500">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1500">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1501">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1501">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1502">Convertit la valeur non signée en haut de la pile d’évaluation en <see langword="unsigned int16" /> et l’étend à <see langword="int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1502">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1503">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1503">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1504">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1504">Format</span></span>|<span data-ttu-id="5c64e-1505">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1505">Assembly Format</span></span>|<span data-ttu-id="5c64e-1506">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1506">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1507">87</span><span class="sxs-lookup"><span data-stu-id="5c64e-1507">87</span></span>|<span data-ttu-id="5c64e-1508">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1508">conv.ovf.u2.un</span></span>|<span data-ttu-id="5c64e-1509">Convertit une valeur non signée à un `unsigned int16` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1509">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1510">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1510">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1511">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1511">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1512">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1512">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1513">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1513">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1514">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1514">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1515">Le `conv.ovf.u2.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1515">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1516">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1516">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1517">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1517">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1518">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1518">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1519"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1519"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1520">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u2.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1520">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1521">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1521">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1522">Convertit la valeur signée en haut de la pile d’évaluation en <see langword="unsigned int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1522">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1523">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1523">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1524">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1524">Format</span></span>|<span data-ttu-id="5c64e-1525">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1525">Assembly Format</span></span>|<span data-ttu-id="5c64e-1526">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1526">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1527">B8</span><span class="sxs-lookup"><span data-stu-id="5c64e-1527">B8</span></span>|<span data-ttu-id="5c64e-1528">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="5c64e-1528">conv.ovf.u4</span></span>|<span data-ttu-id="5c64e-1529">Convertir un `unsigned int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1529">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1530">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1530">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1531">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1531">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1532">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1532">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1533">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1533">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1534">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1534">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1535">Le `conv.ovf.u4` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1535">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1536">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1536">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1537">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1537">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1538">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1538">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1539"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1539"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1540">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1540">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1541">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1541">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1542">Convertit la valeur non signée en haut de la pile d’évaluation en <see langword="unsigned int32" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1542">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1543">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1543">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1544">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1544">Format</span></span>|<span data-ttu-id="5c64e-1545">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1545">Assembly Format</span></span>|<span data-ttu-id="5c64e-1546">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1546">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1547">88</span><span class="sxs-lookup"><span data-stu-id="5c64e-1547">88</span></span>|<span data-ttu-id="5c64e-1548">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1548">conv.ovf.u4.un</span></span>|<span data-ttu-id="5c64e-1549">Convertit une valeur non signée à un `unsigned int32` (sur la pile en tant que `int32`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1549">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1550">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1550">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1551">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1551">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1552">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1552">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1553">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1553">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1554">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1554">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1555">Le `conv.ovf.u4.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1555">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1556">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1556">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1557">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1557">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1558">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1558">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1559"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1559"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1560">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u4.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1560">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1561">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1561">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1562">Convertit la valeur signée en haut de la pile d’évaluation en <see langword="unsigned int64" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1562">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1563">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1563">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1564">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1564">Format</span></span>|<span data-ttu-id="5c64e-1565">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1565">Assembly Format</span></span>|<span data-ttu-id="5c64e-1566">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1566">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1567">BA</span><span class="sxs-lookup"><span data-stu-id="5c64e-1567">BA</span></span>|<span data-ttu-id="5c64e-1568">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="5c64e-1568">conv.ovf.u8</span></span>|<span data-ttu-id="5c64e-1569">Convertir un `unsigned int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1569">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1570">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1570">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1571">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1571">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1572">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1572">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1573">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1573">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1574">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1574">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1575">Le `conv.ovf.u8` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1575">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1576">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1576">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1577">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1577">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1578">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1578">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1579"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1579"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1580">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1580">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1581">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1581">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1582">Convertit la valeur non signée en haut de la pile d’évaluation en <see langword="unsigned int64" />, en levant <see cref="T:System.OverflowException" /> de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1582">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1583">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1583">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1584">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1584">Format</span></span>|<span data-ttu-id="5c64e-1585">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1585">Assembly Format</span></span>|<span data-ttu-id="5c64e-1586">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1586">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1587">89</span><span class="sxs-lookup"><span data-stu-id="5c64e-1587">89</span></span>|<span data-ttu-id="5c64e-1588">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1588">conv.ovf.u8.un</span></span>|<span data-ttu-id="5c64e-1589">Convertit une valeur non signée à un `unsigned int64` (sur la pile en tant que `int64`) et lève une exception de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1589">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="5c64e-1590">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1590">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1591">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1591">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1592">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1592">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="5c64e-1593">En cas de dépassement de capacité, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1593">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="5c64e-1594">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1594">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1595">Le `conv.ovf.u8.un` opcode convertit le `value` sur la pile pour le type spécifié dans le code d’opération et place cette valeur en haut de la pile convertie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1595">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1596">Si la valeur est trop grande ou trop petite pour être représentée par le type de cible, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1596">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="5c64e-1597">Les conversions de nombres à virgule flottante en valeurs entières tronquent le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1597">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="5c64e-1598">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.ovf.i` ou `conv.ovf.u` sont utilisés, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1598">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-1599"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1599"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-1600">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.ovf.u8.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1600">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1601">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1601">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1602">Convertit la valeur de l’entier non signé en haut de la pile d’évaluation en <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1602">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1603">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1603">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1604">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1604">Format</span></span>|<span data-ttu-id="5c64e-1605">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1605">Assembly Format</span></span>|<span data-ttu-id="5c64e-1606">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1606">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1607">76</span><span class="sxs-lookup"><span data-stu-id="5c64e-1607">76</span></span>|<span data-ttu-id="5c64e-1608">conv.r.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1608">conv.r.un</span></span>|<span data-ttu-id="5c64e-1609">Convert entier non signé à virgule flottante, en exécutant un push `F` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1609">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1610">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1610">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1611">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1611">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1612">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1612">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1613">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1613">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1614">Le `conv.r.un` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1614">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1615">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1615">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1616">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1616">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1617">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1617">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1618">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1618">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1619">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1619">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1620">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1620">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1621">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1621">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1622">Si le dépassement de capacité se produit la conversion d’un type à virgule flottante en entier la `result` retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1622">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="5c64e-1623">Le `conv.r.un` opération prend un entier de la pile, il interprète comme étant non signés et le remplace par un nombre à virgule flottante pour représenter l’entier : soit un `float32`, si c’est assez large pour représenter l’entier sans perte de précision, sans quoi un `float64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1623">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="5c64e-1624">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1624">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="5c64e-1625">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.r.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1627">Convertit la valeur située en haut de la pile d’évaluation en <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1627">Converts the value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1628">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1629">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1629">Format</span></span>|<span data-ttu-id="5c64e-1630">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1630">Assembly Format</span></span>|<span data-ttu-id="5c64e-1631">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1632">6B</span><span class="sxs-lookup"><span data-stu-id="5c64e-1632">6B</span></span>|<span data-ttu-id="5c64e-1633">conv.r4</span><span class="sxs-lookup"><span data-stu-id="5c64e-1633">conv.r4</span></span>|<span data-ttu-id="5c64e-1634">Convertir en `float32`, exécution de type push `F` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1634">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1635">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1636">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1636">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1637">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1637">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1638">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1638">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1639">Le `conv.r4` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1639">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1640">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1640">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1641">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1641">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1642">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1642">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1643">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1643">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1644">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1644">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1645">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1645">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1646">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1646">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1647">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1647">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1648">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1648">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="5c64e-1649">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.r4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1649">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1650">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1650">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1651">Convertit la valeur située en haut de la pile d’évaluation en <see langword="float64" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1651">Converts the value on top of the evaluation stack to <see langword="float64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1652">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1652">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1653">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1653">Format</span></span>|<span data-ttu-id="5c64e-1654">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1654">Assembly Format</span></span>|<span data-ttu-id="5c64e-1655">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1655">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1656">6C</span><span class="sxs-lookup"><span data-stu-id="5c64e-1656">6C</span></span>|<span data-ttu-id="5c64e-1657">conv.r8</span><span class="sxs-lookup"><span data-stu-id="5c64e-1657">conv.r8</span></span>|<span data-ttu-id="5c64e-1658">Convertir en `float64`, exécution de type push `F` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1658">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1659">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1659">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1660">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1660">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1661">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1661">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1662">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1662">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1663">Le `conv.r8` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1663">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1664">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1664">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1665">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1665">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1666">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1666">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1667">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1667">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1668">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1668">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1669">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1669">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1670">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1670">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1671">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1671">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1672">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1672">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="5c64e-1673">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.r8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1673">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1674">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1674">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1675">Convertit la valeur située en haut de la pile d’évaluation en <see langword="unsigned native int" />, et l’étend à <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1675">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1676">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1676">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1677">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1677">Format</span></span>|<span data-ttu-id="5c64e-1678">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1678">Assembly Format</span></span>|<span data-ttu-id="5c64e-1679">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1679">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1680">E0</span><span class="sxs-lookup"><span data-stu-id="5c64e-1680">E0</span></span>|<span data-ttu-id="5c64e-1681">conv.u</span><span class="sxs-lookup"><span data-stu-id="5c64e-1681">conv.u</span></span>|<span data-ttu-id="5c64e-1682">Convertir en `unsigned native int`, exécution de type push `native int` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1682">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1683">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1683">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1684">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1684">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1685">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1685">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1686">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1686">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1687">Le `conv.u` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1687">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1688">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1688">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1689">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1689">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1690">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1690">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1691">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1691">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1692">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1692">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1693">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1693">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1694">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1694">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1695">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1695">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1696">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1696">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1697">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1697">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1698">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1700">Convertit la valeur située en haut de la pile d’évaluation en <see langword="unsigned int8" />, et l’étend à <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1700">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1701">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1702">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1702">Format</span></span>|<span data-ttu-id="5c64e-1703">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1703">Assembly Format</span></span>|<span data-ttu-id="5c64e-1704">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1705">D2</span><span class="sxs-lookup"><span data-stu-id="5c64e-1705">D2</span></span>|<span data-ttu-id="5c64e-1706">conv.U1</span><span class="sxs-lookup"><span data-stu-id="5c64e-1706">conv.u1</span></span>|<span data-ttu-id="5c64e-1707">Convertir en `int8`, exécution de type push `int32` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1707">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1708">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1709">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1709">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1710">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1710">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1711">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1711">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1712">Le `conv.u1` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1712">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1713">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1713">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1714">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1714">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1715">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1715">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1716">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1716">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1717">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1717">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1718">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1718">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1719">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1719">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1720">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1720">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1721">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1721">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1722">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1722">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1723">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1723">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1724">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1724">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1725">Convertit la valeur située en haut de la pile d’évaluation en <see langword="unsigned int16" />, et l’étend à <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1725">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1726">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1726">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1727">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1727">Format</span></span>|<span data-ttu-id="5c64e-1728">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1728">Assembly Format</span></span>|<span data-ttu-id="5c64e-1729">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1729">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1730">D1</span><span class="sxs-lookup"><span data-stu-id="5c64e-1730">D1</span></span>|<span data-ttu-id="5c64e-1731">conv.u2</span><span class="sxs-lookup"><span data-stu-id="5c64e-1731">conv.u2</span></span>|<span data-ttu-id="5c64e-1732">Convertir en `int16`, exécution de type push `int32` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1732">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1733">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1733">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1734">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1734">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1735">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1735">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1736">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1736">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1737">Le `conv.u2` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1737">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1738">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1738">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1739">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1739">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1740">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1740">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1741">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1741">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1742">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1742">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1743">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1743">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1744">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1744">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1745">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1745">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1746">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1746">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1747">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1747">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1748">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1748">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1749">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1749">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1750">Convertit la valeur située en haut de la pile d’évaluation en <see langword="unsigned int32" />, et l’étend à <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1750">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1751">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1751">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1752">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1752">Format</span></span>|<span data-ttu-id="5c64e-1753">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1753">Assembly Format</span></span>|<span data-ttu-id="5c64e-1754">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1754">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1755">6D</span><span class="sxs-lookup"><span data-stu-id="5c64e-1755">6D</span></span>|<span data-ttu-id="5c64e-1756">conv.u4</span><span class="sxs-lookup"><span data-stu-id="5c64e-1756">conv.u4</span></span>|<span data-ttu-id="5c64e-1757">Convertir en `unsigned int32`, exécution de type push `int32` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1757">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1758">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1758">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1759">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1759">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1760">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1760">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1761">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1761">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1762">Le `conv.u4` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1762">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1763">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1763">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1764">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1764">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1765">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1765">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1766">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1766">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1767">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1767">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1768">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1768">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1769">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1769">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1770">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1770">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1771">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1771">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1772">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1772">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1773">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1773">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1774">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1774">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1775">Convertit la valeur située en haut de la pile d’évaluation en <see langword="unsigned int64" />, et l’étend à <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1775">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1776">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1776">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1777">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1777">Format</span></span>|<span data-ttu-id="5c64e-1778">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1778">Assembly Format</span></span>|<span data-ttu-id="5c64e-1779">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1779">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1780">6E</span><span class="sxs-lookup"><span data-stu-id="5c64e-1780">6E</span></span>|<span data-ttu-id="5c64e-1781">conv.u8</span><span class="sxs-lookup"><span data-stu-id="5c64e-1781">conv.u8</span></span>|<span data-ttu-id="5c64e-1782">Convertir en `int64`, exécution de type push `int64` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1782">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1783">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1783">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1784">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1784">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1785">`value` est dépilée de la pile et la conversion est tentée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1785">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="5c64e-1786">Si la conversion est réussie, la valeur résultante est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1786">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1787">Le `conv.u8` opcode convertit le `value` sur la pile pour le type spécifié dans l’opcode et laisse cette valeur convertie en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1787">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="5c64e-1788">Les valeurs entières inférieures à 4 octets sont étendues à `int32` lorsqu’elles sont chargées dans la pile d’évaluation (sauf si `conv.i` ou `conv.u` est utilisé, auquel cas le résultat est également `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1788">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="5c64e-1789">Les valeurs à virgule flottante sont converties en la `F` type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1789">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="5c64e-1790">Conversion de nombres à virgule flottante en valeurs entières tronque le nombre vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1790">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="5c64e-1791">Lors de la conversion à partir d’un `float64` à un `float32`, la précision peut être perdue.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1791">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="5c64e-1792">Si `value` est trop grande pour tenir dans un `float32 (F)`, l’infini positif (si `value` est un nombre positif) ou l’infini négatif (si `value` est négative) est retourné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1792">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="5c64e-1793">Si le dépassement de capacité produit la conversion d’un type entier à un autre, les bits de poids fort sont tronqués.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1793">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="5c64e-1794">Si le résultat est inférieur à un `int32`, la valeur est étendue avec un signe pour remplir l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1794">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="5c64e-1795">En cas de dépassement de capacité de conversion d’un type à virgule flottante en entier, la valeur retournée n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1795">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="5c64e-1796">Aucune exception n’est levée lors de l’utilisation de ce champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1796">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="5c64e-1797">Consultez <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> et <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> pour obtenir des instructions équivalentes qui lèvent une exception lorsque le type de résultat ne peut pas représenter correctement la valeur de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1797">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="5c64e-1798">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `conv.u8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1798">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1799">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1799">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1800">Copie un nombre d'octets spécifié d'une adresse source vers une adresse de destination.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1800">Copies a specified number bytes from a source address to a destination address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1801">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1801">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1802">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1802">Format</span></span>|<span data-ttu-id="5c64e-1803">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1803">Assembly Format</span></span>|<span data-ttu-id="5c64e-1804">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1804">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1805">FE 17</span><span class="sxs-lookup"><span data-stu-id="5c64e-1805">FE 17</span></span>|<span data-ttu-id="5c64e-1806">cpblk</span><span class="sxs-lookup"><span data-stu-id="5c64e-1806">cpblk</span></span>|<span data-ttu-id="5c64e-1807">Copier des données à partir d’un bloc de mémoire à un autre.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1807">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="5c64e-1808">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1808">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1809">L’adresse de destination est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1809">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1810">L’adresse source est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1810">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-1811">Le nombre d’octets à copier est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1811">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-1812">Le nombre d’octets, l’adresse source et l’adresse de destination est dépilé de la pile ; le nombre spécifié d’octets est copié à partir de l’adresse source à l’adresse de destination.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1812">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="5c64e-1813">Le `cpblk` instruction copie un nombre (type `unsigned int32`) d’octets à partir d’une adresse source (de type `*`, `native int`, ou `&`) à une adresse de destination (de type `*`, `native int`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1813">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="5c64e-1814">Le comportement de `cpblk` n’est pas spécifié si les zones source et de destination se chevauchent.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1814">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="5c64e-1815">`cpblk` suppose que la source et la destination traités sont alignées avec la taille naturelle de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1815">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="5c64e-1816">Le `cpblk` instruction peut être immédiatement précédée par le `unaligned.<prefix>` pour indiquer que la source ou la destination n’est pas alignée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1816">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="5c64e-1817">L’opération de la `cpblk` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1817">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-1818"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1818"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-1819">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cpblk` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1819">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1820">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1820">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1821">Copie le type de valeur situé à l’adresse d’un objet (type <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />) à l’adresse de l’objet de destination (type <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1821">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1822">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1822">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1823">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1823">Format</span></span>|<span data-ttu-id="5c64e-1824">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1824">Assembly Format</span></span>|<span data-ttu-id="5c64e-1825">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1825">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1826">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-1826">70 < `T` ></span></span>|<span data-ttu-id="5c64e-1827">cpobj `classTok`</span><span class="sxs-lookup"><span data-stu-id="5c64e-1827">cpobj `classTok`</span></span>|<span data-ttu-id="5c64e-1828">Copie un type valeur à partir d’un objet source vers un objet de destination.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1828">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="5c64e-1829">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1829">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1830">La référence d’objet de destination est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1830">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1831">La référence d’objet source est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1831">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-1832">Les deux références d’objet sont dépilés de la pile ; le type de valeur à l’adresse de l’objet source est copié à l’adresse de l’objet de destination.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1832">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="5c64e-1833">Le comportement de `cpobj` n’est pas spécifié si la source et la destination de l’objet références ne sont pas des pointeurs vers des instances de la classe représentée par le jeton de la classe `classTok` (un `typeref` ou `typedef`), ou si `classTok` ne représente pas un type de valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1833">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="5c64e-1834"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1834"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-1835">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `cpobj` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1835">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1836">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1836">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1837">Divise deux valeurs et transmet les résultats en tant que virgule flottante (type <see langword="F" />) ou quotient (type <see langword="int32" />) dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1837">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1838">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1838">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1839">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1839">Format</span></span>|<span data-ttu-id="5c64e-1840">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1840">Assembly Format</span></span>|<span data-ttu-id="5c64e-1841">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1841">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1842">5B</span><span class="sxs-lookup"><span data-stu-id="5c64e-1842">5B</span></span>|<span data-ttu-id="5c64e-1843">div</span><span class="sxs-lookup"><span data-stu-id="5c64e-1843">div</span></span>|<span data-ttu-id="5c64e-1844">Divise deux valeurs pour retourner un quotient ou un résultat à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1844">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="5c64e-1845">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1845">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1846">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1846">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1847">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1847">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-1848">`value2` et `value1` sont dépilés de la pile ; `value1` est divisé par `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1848">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-1849">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1849">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1850">`result` = `value1` value2 répond aux conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1850">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="5c64e-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span><span class="sxs-lookup"><span data-stu-id="5c64e-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="5c64e-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="5c64e-1853">La `div` instruction calcule le résultat et il exécute un push sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1853">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1854">Division d’entier tronque vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1854">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="5c64e-1855">Division d’un nombre fini par zéro produit la valeur infinie correctement signée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1855">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="5c64e-1856">La division de zéro par zéro ou l’infini par l’infini produit la valeur NaN (Not-A-Number).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1856">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="5c64e-1857">N’importe quel nombre divisé par l’infini produit une valeur de zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1857">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="5c64e-1858">Opérations intégrales lever <xref:System.ArithmeticException> si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1858">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="5c64e-1859">Cela peut se produire si `value1` est la valeur négative maximale, et `value2` est -1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1859">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="5c64e-1860">Opérations intégrales lever <xref:System.DivideByZeroException> si `value2` est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1860">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="5c64e-1861">Notez que sur les plateformes Intel un <xref:System.OverflowException> est levée lors du calcul (minint div -1).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1861">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="5c64e-1862">Opérations à virgule flottante ne lèvent jamais d’exception (elles produisent NaN ou les valeurs infinies).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1862">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="5c64e-1863">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `div` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1863">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1864">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1864">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1865">Divise deux valeurs entières non signées et transmet les résultats (<see langword="int32" />) dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1865">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1866">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1866">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1867">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1867">Format</span></span>|<span data-ttu-id="5c64e-1868">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1868">Assembly Format</span></span>|<span data-ttu-id="5c64e-1869">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1869">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1870">5C</span><span class="sxs-lookup"><span data-stu-id="5c64e-1870">5C</span></span>|<span data-ttu-id="5c64e-1871">div.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-1871">div.un</span></span>|<span data-ttu-id="5c64e-1872">Divise deux valeurs, non signés, retournant un quotient.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1872">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="5c64e-1873">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1873">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1874">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1874">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1875">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1875">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-1876">`value2` et `value1` sont dépilés de la pile ; `value1` est divisé par `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1876">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-1877">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1877">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1878">Le `div.un` instruction calcule `value1` divisé par `value2`, les deux étant pris en tant qu’entiers non signés et exécute un push le `result` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1878">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1879">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `div.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1879">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1880">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1880">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1881">Copie la valeur actuelle la plus haute dans la pile d'évaluation et exécute un push de la copie dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1881">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1882">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1882">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1883">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1883">Format</span></span>|<span data-ttu-id="5c64e-1884">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1884">Assembly Format</span></span>|<span data-ttu-id="5c64e-1885">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1885">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1886">25</span><span class="sxs-lookup"><span data-stu-id="5c64e-1886">25</span></span>|<span data-ttu-id="5c64e-1887">DUP</span><span class="sxs-lookup"><span data-stu-id="5c64e-1887">dup</span></span>|<span data-ttu-id="5c64e-1888">Duplique la valeur en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1888">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-1889">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1889">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1890">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1890">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1891">`value` est expulsé de la pile pour la duplication.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1891">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="5c64e-1892">`value` sont réinsérées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1892">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-1893">Une valeur en double est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1893">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1894">La `dup` instruction duplique l’élément supérieur de la pile et laisse deux valeurs identiques au-dessus d’elle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1894">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="5c64e-1895">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `dup` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1895">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1896">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1896">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1897">Transfère le contrôle à partir de la <see langword="filter" /> clause d’une exception au gestionnaire d’exceptions Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1897">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1898">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1899">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1899">Format</span></span>|<span data-ttu-id="5c64e-1900">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1900">Assembly Format</span></span>|<span data-ttu-id="5c64e-1901">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1902">FE 11</span><span class="sxs-lookup"><span data-stu-id="5c64e-1902">FE 11</span></span>|<span data-ttu-id="5c64e-1903">endfilter</span><span class="sxs-lookup"><span data-stu-id="5c64e-1903">endfilter</span></span>|<span data-ttu-id="5c64e-1904">Clause de filtre de fin de la gestion des exceptions SEH.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1904">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="5c64e-1905">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1906">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1906">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1907">`value` est retirée de la pile ; `endfilter` est exécutée et le contrôle est transféré au gestionnaire d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1907">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="5c64e-1908">`Value` (qui doit être de type `int32` et fait partie d’un ensemble spécifique de valeurs) est retournée à partir de la clause de filtre.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1908">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="5c64e-1909">Il doit s’agir de :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1909">It should be one of:</span></span>  
  
-   <span data-ttu-id="5c64e-1910">`exception_continue_search` (`value` = 0) pour poursuivre la recherche pour un gestionnaire d’exceptions</span><span class="sxs-lookup"><span data-stu-id="5c64e-1910">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="5c64e-1911">`exception_execute_handler` (`value` = 1) pour lancer la deuxième phase de gestion des exceptions où les blocs finally sont exécutés jusqu'à ce que le gestionnaire associé à cette clause de filtre se trouve.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1911">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="5c64e-1912">Lors de la découverte, le gestionnaire est exécuté.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1912">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="5c64e-1913">D’autres valeurs entières produira des résultats non spécifiées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1913">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="5c64e-1914">Le point d’entrée d’un filtre, comme indiqué dans la table d’exceptions de la méthode, doit être la première instruction dans le bloc de code du filtre.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1914">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="5c64e-1915">Le `endfilter` instruction doit être la dernière instruction dans le bloc de code du filtre (par conséquent, il peut être seulement un `endfilter` pour chaque bloc de filtre).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1915">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="5c64e-1916">Après avoir exécuté la `endfilter` instruction, logiquement le flux de contrôle au mécanisme de gestion d’exceptions CLI.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1916">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="5c64e-1917">Contrôle ne peut pas être transféré dans un bloc de filtre sauf via le mécanisme d’exception.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1917">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="5c64e-1918">Le contrôle ne peut pas être transféré en dehors d’un bloc de filtre à l’exception à l’aide d’un `throw` instruction ou en exécutant la dernière `endfilter` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1918">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="5c64e-1919">Vous ne pouvez pas incorporer un `try` bloquer dans un `filter` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1919">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="5c64e-1920">Si une exception est levée à l’intérieur de la `filter` bloc, elle est interceptée et la valeur 0 (`exception_continue_search`) est retournée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1920">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="5c64e-1921">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `endfilter` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1921">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1922">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1922">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1923">Transfère le contrôle à partir de la <see langword="fault" /> ou <see langword="finally" /> clause d’un bloc d’exception au gestionnaire d’exceptions Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1923">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1924">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1924">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1925">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1925">Format</span></span>|<span data-ttu-id="5c64e-1926">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1926">Assembly Format</span></span>|<span data-ttu-id="5c64e-1927">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1927">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1928">DC</span><span class="sxs-lookup"><span data-stu-id="5c64e-1928">DC</span></span>|<span data-ttu-id="5c64e-1929">endfinally</span><span class="sxs-lookup"><span data-stu-id="5c64e-1929">endfinally</span></span><br /><br /> <span data-ttu-id="5c64e-1930">endfault</span><span class="sxs-lookup"><span data-stu-id="5c64e-1930">endfault</span></span>|<span data-ttu-id="5c64e-1931">Met fin à la `finally` ou `fault` clause d’un bloc d’exception.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1931">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="5c64e-1932">Il n’existe aucune pile de comportements de transition pour cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1932">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-1933">`Endfinally` et `endfault` signaler la fin de la `finally` ou `fault` clause afin que le déroulement puisse continuer jusqu'à ce que le Gestionnaire d’exceptions est appelé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1933">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="5c64e-1934">Le `endfinally` ou `endfault` instruction transfère le contrôle vers le mécanisme d’exception CLI.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1934">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="5c64e-1935">La recherche pour le prochain ensuite `finally` clause dans la chaîne si le bloc protégé a été fermé avec une instruction leave.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1935">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="5c64e-1936">Si le bloc protégé a été fermé avec une exception, l’interface CLI recherchera la prochaine `finally` ou `fault`, ou entrez le Gestionnaire d’exceptions au moment de la première passe de la gestion des exceptions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1936">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="5c64e-1937">Un `endfinally` instruction peut apparaître uniquement sur le plan lexical dans un `finally` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1937">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="5c64e-1938">Contrairement à la `endfilter` obtenir des instructions, il n’est pas nécessaire que le bloc se termine avec un `endfinally` instruction et peut avoir autant `endfinally` instructions au sein du bloc en fonction des besoins.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1938">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="5c64e-1939">Ces mêmes restrictions s’appliquent à la `endfault` instruction et le `fault` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1939">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="5c64e-1940">Le contrôle ne peut pas être transféré dans un `finally` (ou `fault`) bloquer, sauf via le mécanisme d’exception.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1940">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="5c64e-1941">Contrôle ne peut pas être transféré hors d’un `finally` (ou `fault`) bloquer à l’exception à l’aide d’un `throw` instruction ou en exécutant la `endfinally` (ou `endfault`) instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1941">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="5c64e-1942">En particulier, vous ne pouvez pas » se répartissent » d’un `finally` (ou `fault`) bloc ou d’exécuter un <xref:System.Reflection.Emit.OpCodes.Ret> ou <xref:System.Reflection.Emit.OpCodes.Leave> instruction dans un `finally` (ou `fault`) bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1942">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="5c64e-1943">Notez que le `endfault` et `endfinally` instructions sont des alias : ils correspondent au même opcode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1943">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="5c64e-1944">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `endfinally` (`endfault`) opcode, ainsi que le `ILGenerator` méthode <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1944">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="5c64e-1945">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1945">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="5c64e-1946">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="5c64e-1946">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1947">Initialise un bloc de mémoire spécifié situé à une adresse spécifique en utilisant une taille et une valeur initiale données.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1947">Initializes a specified block of memory at a specific address to a given size and initial value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1948">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1948">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1949">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1949">Format</span></span>|<span data-ttu-id="5c64e-1950">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1950">Assembly Format</span></span>|<span data-ttu-id="5c64e-1951">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1951">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1952">FE 18</span><span class="sxs-lookup"><span data-stu-id="5c64e-1952">FE 18</span></span>|<span data-ttu-id="5c64e-1953">initblk</span><span class="sxs-lookup"><span data-stu-id="5c64e-1953">initblk</span></span>|<span data-ttu-id="5c64e-1954">Définir chaque emplacement dans un bloc de mémoire à une valeur donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1954">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="5c64e-1955">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1955">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1956">Une adresse de début est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1956">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1957">Une valeur d’initialisation est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1957">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-1958">Le nombre d’octets à initialiser est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1958">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-1959">Le nombre d’octets, la valeur d’initialisation et l’adresse de départ est dépilé et l’initialisation est exécutée conformément à leurs valeurs.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1959">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="5c64e-1960">Le `initblk` instruction définit le nombre (`unsigned int32`) d’octets commençant à l’adresse spécifiée (de type `native int`, `&`, ou `*`) à la valeur d’initialisation (de type `unsigned int8`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-1960">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="5c64e-1961">`initblk` suppose que l’adresse de départ est alignée avec la taille naturelle de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1961">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="5c64e-1962">L’opération de la `initblk` instructions peuvent être modifiées par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1962">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-1963"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1963"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-1964">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `initblk` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1964">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1965">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1965">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1966">Initialise tous les champs du type de valeur figurant à l'adresse spécifiée en utilisant la référence null ou la valeur 0 du type primitif qui convient.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1966">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1967">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1967">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1968">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1968">Format</span></span>|<span data-ttu-id="5c64e-1969">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1969">Assembly Format</span></span>|<span data-ttu-id="5c64e-1970">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1970">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1971">FE 15 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-1971">FE 15 < `T` ></span></span>|<span data-ttu-id="5c64e-1972">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="5c64e-1972">`initobj` `typeTok`</span></span>|<span data-ttu-id="5c64e-1973">Initialise un type valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1973">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="5c64e-1974">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1974">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1975">L’adresse du type valeur à initialiser est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1975">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1976">L’adresse est retirée de la pile ; le type de valeur à l’adresse spécifiée est initialisé en tant que type `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1976">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="5c64e-1977">Le `initobj` instruction initialise chaque champ du type valeur spécifié par l’adresse envoyée (de type `native int`, `&`, ou `*`) à une référence null ou une valeur 0 du type primitif qui convient.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1977">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="5c64e-1978">Une fois que cette méthode est appelée, l’instance est prête pour une méthode de constructeur à appeler.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1978">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="5c64e-1979">Si `typeTok` est un type référence, cette instruction a le même effet que `ldnull` suivie `stind.ref`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1979">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="5c64e-1980">Contrairement aux <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` n’appelle pas la méthode de constructeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1980">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="5c64e-1981">`Initobj` est conçu pour l’initialisation des types valeur, tandis que `newobj` est utilisé pour allouer et initialiser des objets.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1981">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="5c64e-1982">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `initobj` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1982">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-1983">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-1983">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-1984">Teste si une référence d’objet (type <see langword="O" />) est une instance d’une classe particulière.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1984">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-1985">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1985">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-1986">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-1986">Format</span></span>|<span data-ttu-id="5c64e-1987">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-1987">Assembly Format</span></span>|<span data-ttu-id="5c64e-1988">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-1988">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-1989">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-1989">75 < `T` ></span></span>|<span data-ttu-id="5c64e-1990">isinst `class`</span><span class="sxs-lookup"><span data-stu-id="5c64e-1990">isinst `class`</span></span>|<span data-ttu-id="5c64e-1991">Teste si une référence d’objet est une instance de `class`, retournant une référence null ou une instance de cette classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1991">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="5c64e-1992">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-1992">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-1993">Une référence d’objet est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1993">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-1994">La référence d’objet est dépilée et testée pour s’il s’agit d’une instance de la classe passée dans `class`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1994">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="5c64e-1995">Le résultat (une référence d’objet ou une référence null) est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1995">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-1996">`Class` est un jeton de métadonnées indiquant la classe souhaitée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1996">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="5c64e-1997">Si la classe de l’objet en haut de la pile implémente `class` (si `class` est une interface) ou est une classe dérivée de `class` (si `class` est une classe normale), puis elle est convertie en type `class` et le résultat est ajoutée à la pile, exactement comme si <xref:System.Reflection.Emit.OpCodes.Castclass> avait été appelée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1997">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="5c64e-1998">Sinon, une référence null est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1998">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="5c64e-1999">Si la référence d’objet est une référence null, alors `isinst` même retourne une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-1999">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2000"><xref:System.TypeLoadException> est levée si la classe est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2000"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="5c64e-2001">Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2001">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-2002">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `isinst` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2003">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2003">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2004">Quitte la méthode actuelle et passe à la méthode spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2004">Exits current method and jumps to specified method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2005">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2006">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2006">Format</span></span>|<span data-ttu-id="5c64e-2007">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2007">Assembly Format</span></span>|<span data-ttu-id="5c64e-2008">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2009">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2009">27 < `T` ></span></span>|<span data-ttu-id="5c64e-2010">jmp `method`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2010">jmp `method`</span></span>|<span data-ttu-id="5c64e-2011">Quitte la méthode actuelle et passer à la méthode spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2011">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="5c64e-2012">Il n’existe aucune pile de comportements de transition pour cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2012">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-2013">Le `jmp` (lien) instruction transfère le contrôle à la méthode spécifiée par `method`, qui est un jeton de métadonnées pour une référence de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2013">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="5c64e-2014">Les arguments actuels sont transférés à la méthode de destination.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2014">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="5c64e-2015">La pile d’évaluation doit être vide lorsque cette instruction est exécutée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2015">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="5c64e-2016">La convention d’appel, le nombre et le type d’arguments à l’adresse de destination doivent correspondre à celui de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2016">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="5c64e-2017">Le `jmp` ne peut pas être utilisée pour transférer le contrôle d’un `try`, `filter`, `catch`, ou `finally` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2017">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="5c64e-2018">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `jmp` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2019">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2019">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2020">Charge un argument (référencé par une valeur d’index spécifiée) dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2020">Loads an argument (referenced by a specified index value) onto the stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2021">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2022">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2022">Format</span></span>|<span data-ttu-id="5c64e-2023">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2023">Assembly Format</span></span>|<span data-ttu-id="5c64e-2024">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2025">FE 09 < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2025">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="5c64e-2026">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2026">ldarg `index`</span></span>|<span data-ttu-id="5c64e-2027">Charge l’argument à `index` sur pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2027">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2028">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2029">La valeur d’argument à `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2029">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2030">Le `ldarg` push de l’argument indexé à `index`, où les arguments sont indexés à partir de 0, dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2030">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2031">La `ldarg` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2031">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="5c64e-2032">Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2032">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-2033">Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, le `ldarg` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature (voir la <xref:System.Reflection.Emit.OpCodes.Arglist> instruction pour plus d’informations).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2033">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="5c64e-2034">Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2034">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-2035">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2035">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-2036">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2037">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2037">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2038">Charge l'argument à l'index 0 dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2038">Loads the argument at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2039">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2040">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2040">Format</span></span>|<span data-ttu-id="5c64e-2041">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2041">Assembly Format</span></span>|<span data-ttu-id="5c64e-2042">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2043">02</span><span class="sxs-lookup"><span data-stu-id="5c64e-2043">02</span></span>|<span data-ttu-id="5c64e-2044">ldarg.0</span><span class="sxs-lookup"><span data-stu-id="5c64e-2044">ldarg.0</span></span>|<span data-ttu-id="5c64e-2045">Charge l’argument 0 dans la pile</span><span class="sxs-lookup"><span data-stu-id="5c64e-2045">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="5c64e-2046">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2047">La valeur d’argument à l’index 0 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2047">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2048">La `ldarg.0` instruction est un codage efficace pour charger la valeur d’argument à l’index 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2048">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="5c64e-2049">La `ldarg.0` instruction exécute un push de l’argument indexé à 0 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2049">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2050">La `ldarg.0` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2050">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="5c64e-2051">Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2051">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-2052">Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2052">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-2053">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2053">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-2054">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.0` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2056">Charge l’argument à l’index 1 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2056">Loads the argument at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2057">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2058">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2058">Format</span></span>|<span data-ttu-id="5c64e-2059">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2059">Assembly Format</span></span>|<span data-ttu-id="5c64e-2060">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2061">03</span><span class="sxs-lookup"><span data-stu-id="5c64e-2061">03</span></span>|<span data-ttu-id="5c64e-2062">ldarg.1</span><span class="sxs-lookup"><span data-stu-id="5c64e-2062">ldarg.1</span></span>|<span data-ttu-id="5c64e-2063">Charge l’argument 1 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2063">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2064">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2065">La valeur d’argument à l’index 1 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2065">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2066">La `ldarg.1` instruction est un codage efficace pour charger la valeur d’argument à l’index 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2066">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="5c64e-2067">La `ldarg.1` instruction exécute un push de l’argument indexé à 1 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2067">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2068">La `ldarg.1` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2068">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="5c64e-2069">Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2069">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-2070">Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2070">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-2071">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-2072">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2074">Charge l’argument à l’index 2 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2074">Loads the argument at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2075">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2076">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2076">Format</span></span>|<span data-ttu-id="5c64e-2077">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2077">Assembly Format</span></span>|<span data-ttu-id="5c64e-2078">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2079">04</span><span class="sxs-lookup"><span data-stu-id="5c64e-2079">04</span></span>|<span data-ttu-id="5c64e-2080">ldarg.2</span><span class="sxs-lookup"><span data-stu-id="5c64e-2080">ldarg.2</span></span>|<span data-ttu-id="5c64e-2081">Charge l’argument 2 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2081">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2082">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2083">La valeur d’argument à l’index 2 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2083">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2084">La `ldarg.2` instruction est un codage efficace pour charger la valeur d’argument à l’index 2.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2084">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="5c64e-2085">La `ldarg.2` instruction exécute un push de l’argument indexé à 2 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2085">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2086">La `ldarg.2` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2086">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="5c64e-2087">Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2087">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-2088">Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2088">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-2089">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2089">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-2090">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2092">Charge l’argument à l’index 3 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2092">Loads the argument at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2093">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2094">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2094">Format</span></span>|<span data-ttu-id="5c64e-2095">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2095">Assembly Format</span></span>|<span data-ttu-id="5c64e-2096">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2097">05</span><span class="sxs-lookup"><span data-stu-id="5c64e-2097">05</span></span>|<span data-ttu-id="5c64e-2098">ldarg.3</span><span class="sxs-lookup"><span data-stu-id="5c64e-2098">ldarg.3</span></span>|<span data-ttu-id="5c64e-2099">Charge l’argument 3 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2099">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2100">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2101">La valeur d’argument à l’index 3 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2101">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2102">La `ldarg.3` instruction est un codage efficace pour charger la valeur d’argument à l’index 3.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2102">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="5c64e-2103">La `ldarg.3` instruction exécute un push de l’argument indexé à 3 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2103">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2104">La `ldarg.3` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2104">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="5c64e-2105">Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2105">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-2106">Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2106">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-2107">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2107">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-2108">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.3` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2110">Charge l'argument (référencé par un index sous la forme abrégée) dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2110">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2111">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2112">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2112">Format</span></span>|<span data-ttu-id="5c64e-2113">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2113">Assembly Format</span></span>|<span data-ttu-id="5c64e-2114">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2115">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2115">0E < `unsigned int8` ></span></span>|<span data-ttu-id="5c64e-2116">ldarg.s `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2116">ldarg.s `index`</span></span>|<span data-ttu-id="5c64e-2117">Charge l’argument à `index` dans la pile, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2117">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-2118">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2119">La valeur d’argument à `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2119">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2120">La `ldarg.s` instruction est un codage efficace pour charger les arguments indexés de 4 à 255.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2120">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="5c64e-2121">Le `ldarg.s` push de l’argument indexé à `index`, où les arguments sont indexés à partir de 0, dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2121">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2122">La `ldarg.s` instruction peut être utilisée pour charger un type valeur ou une valeur primitive dans la pile en le copiant à partir d’un argument entrant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2122">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="5c64e-2123">Le type de la valeur d’argument est le même que le type de l’argument, comme spécifié par la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2123">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-2124">Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, le `ldarg.s` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature (voir la <xref:System.Reflection.Emit.OpCodes.Arglist> instruction pour plus d’informations).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2124">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="5c64e-2125">Les arguments qui contiennent une valeur entière inférieure à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2125">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-2126">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2126">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-2127">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarg.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2128">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2128">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2129">Charge une adresse d’argument dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2129">Load an argument address onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2130">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2131">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2131">Format</span></span>|<span data-ttu-id="5c64e-2132">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2132">Assembly Format</span></span>|<span data-ttu-id="5c64e-2133">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2134">FE 0A < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2134">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="5c64e-2135">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2135">ldarga `index`</span></span>|<span data-ttu-id="5c64e-2136">Extrait l’adresse de l’argument indexé par `index`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2136">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="5c64e-2137">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2138">L’adresse `addr` de l’argument indexé par `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2138">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2139">Le `ldarga` instruction extrait l’adresse (de type `*`) de l’argument indexé par `index`, où les arguments sont indexés à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2139">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="5c64e-2140">L’adresse `addr` est toujours aligné sur une frontière naturelle sur l’ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2140">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="5c64e-2141">Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, la `ldarga` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2141">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="5c64e-2142">`ldarga` est utilisé pour le passage de paramètres par référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2142">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="5c64e-2143">Pour les autres cas, <xref:System.Reflection.Emit.OpCodes.Ldarg> et <xref:System.Reflection.Emit.OpCodes.Starg> doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2143">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="5c64e-2144">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarga` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2145">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2145">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2146">Charge une adresse d'argument, sous la forme abrégée, dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2146">Load an argument address, in short form, onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2147">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2148">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2148">Format</span></span>|<span data-ttu-id="5c64e-2149">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2149">Assembly Format</span></span>|<span data-ttu-id="5c64e-2150">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2151">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2151">0F < `unsigned int8` ></span></span>|<span data-ttu-id="5c64e-2152">ldarga.s `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2152">ldarga.s `index`</span></span>|<span data-ttu-id="5c64e-2153">Extrait l’adresse de l’argument indexé par `index`, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2153">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-2154">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2155">L’adresse `addr` de l’argument indexé par `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2155">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2156">`ldarga.s` (la forme abrégée de `ldarga`) doit être utilisé pour les numéros d’arguments de 0 à 255 et constitue un encodage plus efficace.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2156">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="5c64e-2157">Le `ldarga.s` instruction extrait l’adresse (de type`*`) de l’argument indexé par `index`, où les arguments sont indexés à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2157">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="5c64e-2158">L’adresse `addr` est toujours aligné sur une frontière naturelle sur l’ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2158">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="5c64e-2159">Pour connaître les procédures qui acceptent une liste d’arguments de longueur variable, la `ldarga.s` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2159">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="5c64e-2160">`ldarga.s` est utilisé pour le passage de paramètres par référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2160">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="5c64e-2161">Pour les autres cas, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> et <xref:System.Reflection.Emit.OpCodes.Starg_S> doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2161">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="5c64e-2162">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldarga.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2162">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2163">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2163">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2164">Exécute un push d’une valeur fournie de type <see langword="int32" /> dans la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2164">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2165">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2165">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2166">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2166">Format</span></span>|<span data-ttu-id="5c64e-2167">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2167">Assembly Format</span></span>|<span data-ttu-id="5c64e-2168">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2168">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2169">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2169">20 < `int32` ></span></span>|<span data-ttu-id="5c64e-2170">ldc.i4 `num`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2170">ldc.i4 `num`</span></span>|<span data-ttu-id="5c64e-2171">Exécute un push de la valeur `num` dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2171">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2172">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2172">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2173">La valeur `num` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2173">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2174">Notez qu’il n’y a les encodages abrégés (et donc plus efficaces) spéciaux pour les entiers -128 à 127 et particulièrement-1 à 8.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2174">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="5c64e-2175">Tous les encodages abrégés push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2175">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="5c64e-2176">Les codages plus longs sont utilisés pour les entiers de 8 octets et 4 et 8 nombres à virgule flottante octets, ainsi que les valeurs de 4 octets qui ne tiennent pas dans les formes abrégées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2176">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="5c64e-2177">Il existe trois façons pour transmettre une constante entière de 8 octets dans la pile</span><span class="sxs-lookup"><span data-stu-id="5c64e-2177">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="5c64e-2178">Utilisez la <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction pour les constantes doivent être exprimées en plus de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="5c64e-2179">Utilisez le <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction suivie d’un <xref:System.Reflection.Emit.OpCodes.Conv_I8> pour les constantes qui requièrent de 9 à 32 bits.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2179">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="5c64e-2180">Utilisez une instruction de forme abrégée suivie d’un <xref:System.Reflection.Emit.OpCodes.Conv_I8> pour les constantes qui peuvent être exprimées en moins de 8 bits.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2180">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="5c64e-2181">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2181">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2182">ILGenerator.Emit(OpCode, int)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2182">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2183">Exécute un push de la valeur entière 0 dans la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2183">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2184">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2184">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2185">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2185">Format</span></span>|<span data-ttu-id="5c64e-2186">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2186">Assembly Format</span></span>|<span data-ttu-id="5c64e-2187">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2187">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2188">16</span><span class="sxs-lookup"><span data-stu-id="5c64e-2188">16</span></span>|<span data-ttu-id="5c64e-2189">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="5c64e-2189">ldc.i4.0</span></span>|<span data-ttu-id="5c64e-2190">Exécute un push de 0 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2190">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2191">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2191">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2192">La valeur 0 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2192">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2193">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2193">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2194">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2194">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2195">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.0` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2195">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2196">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2196">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2197">Exécute un envoi (push) de la valeur entière 1 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2197">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2198">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2198">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2199">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2199">Format</span></span>|<span data-ttu-id="5c64e-2200">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2200">Assembly Format</span></span>|<span data-ttu-id="5c64e-2201">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2201">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2202">17</span><span class="sxs-lookup"><span data-stu-id="5c64e-2202">17</span></span>|<span data-ttu-id="5c64e-2203">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="5c64e-2203">ldc.i4.1</span></span>|<span data-ttu-id="5c64e-2204">Exécute un push de 1 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2204">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2205">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2205">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2206">La valeur 1 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2206">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2207">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2207">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2208">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2208">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2209">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2210">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2210">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2211">Exécute un envoi (push) de la valeur entière 2 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2211">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2212">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2213">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2213">Format</span></span>|<span data-ttu-id="5c64e-2214">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2214">Assembly Format</span></span>|<span data-ttu-id="5c64e-2215">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2216">18</span><span class="sxs-lookup"><span data-stu-id="5c64e-2216">18</span></span>|<span data-ttu-id="5c64e-2217">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="5c64e-2217">ldc.i4.2</span></span>|<span data-ttu-id="5c64e-2218">Exécute un push de 2 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2218">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2219">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2220">La valeur 2 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2220">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2221">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2221">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2222">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2222">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2223">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2224">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2224">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2225">Exécute un envoi (push) de la valeur entière 3 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2225">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2226">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2227">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2227">Format</span></span>|<span data-ttu-id="5c64e-2228">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2228">Assembly Format</span></span>|<span data-ttu-id="5c64e-2229">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2230">19</span><span class="sxs-lookup"><span data-stu-id="5c64e-2230">19</span></span>|<span data-ttu-id="5c64e-2231">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="5c64e-2231">ldc.i4.3</span></span>|<span data-ttu-id="5c64e-2232">Exécute un push de 3 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2232">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2233">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2234">La valeur 3 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2234">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2235">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2235">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2236">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2236">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2237">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.3` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2237">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2238">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2238">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2239">Exécute un envoi (push) de la valeur entière 4 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2239">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2240">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2240">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2241">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2241">Format</span></span>|<span data-ttu-id="5c64e-2242">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2242">Assembly Format</span></span>|<span data-ttu-id="5c64e-2243">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2243">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2244">1A</span><span class="sxs-lookup"><span data-stu-id="5c64e-2244">1A</span></span>|<span data-ttu-id="5c64e-2245">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="5c64e-2245">ldc.i4.4</span></span>|<span data-ttu-id="5c64e-2246">Exécute un push de 4 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2246">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2247">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2247">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2248">La valeur 4 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2248">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2249">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2249">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2250">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2250">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2251">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2252">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2252">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2253">Exécute un envoi (push) de la valeur entière 5 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2253">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2254">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2255">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2255">Format</span></span>|<span data-ttu-id="5c64e-2256">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2256">Assembly Format</span></span>|<span data-ttu-id="5c64e-2257">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2258">1B</span><span class="sxs-lookup"><span data-stu-id="5c64e-2258">1B</span></span>|<span data-ttu-id="5c64e-2259">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="5c64e-2259">ldc.i4.5</span></span>|<span data-ttu-id="5c64e-2260">Exécute un push de 5 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2260">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2261">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2262">La valeur 5 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2262">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2263">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2263">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2264">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2264">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2265">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.5` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2265">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2266">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2266">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2267">Exécute un envoi (push) de la valeur entière 6 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2267">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2268">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2268">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2269">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2269">Format</span></span>|<span data-ttu-id="5c64e-2270">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2270">Assembly Format</span></span>|<span data-ttu-id="5c64e-2271">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2271">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2272">1C</span><span class="sxs-lookup"><span data-stu-id="5c64e-2272">1C</span></span>|<span data-ttu-id="5c64e-2273">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="5c64e-2273">ldc.i4.6</span></span>|<span data-ttu-id="5c64e-2274">Exécute un push de 6 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2274">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2275">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2275">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2276">La valeur 6 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2276">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2277">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2277">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2278">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2278">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2279">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.6` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2281">Exécute un envoi (push) de la valeur entière 7 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2281">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2282">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2283">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2283">Format</span></span>|<span data-ttu-id="5c64e-2284">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2284">Assembly Format</span></span>|<span data-ttu-id="5c64e-2285">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2286">1D</span><span class="sxs-lookup"><span data-stu-id="5c64e-2286">1D</span></span>|<span data-ttu-id="5c64e-2287">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="5c64e-2287">ldc.i4.7</span></span>|<span data-ttu-id="5c64e-2288">Exécute un push de 7 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2288">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2289">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2290">La valeur 7 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2290">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2291">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2291">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2292">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2292">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2293">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.7` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2294">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2294">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2295">Exécute un envoi (push) de la valeur entière 8 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2295">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2296">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2297">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2297">Format</span></span>|<span data-ttu-id="5c64e-2298">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2298">Assembly Format</span></span>|<span data-ttu-id="5c64e-2299">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2300">1E</span><span class="sxs-lookup"><span data-stu-id="5c64e-2300">1E</span></span>|<span data-ttu-id="5c64e-2301">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="5c64e-2301">ldc.i4.8</span></span>|<span data-ttu-id="5c64e-2302">Exécute un push de 8 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2302">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2303">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2304">La valeur 8 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2304">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2305">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2305">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2306">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2306">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2307">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2309">Exécute un envoi (push) de la valeur entière -1 dans la pile d’évaluation en tant que <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2309">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2310">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2311">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2311">Format</span></span>|<span data-ttu-id="5c64e-2312">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2312">Assembly Format</span></span>|<span data-ttu-id="5c64e-2313">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2314">15</span><span class="sxs-lookup"><span data-stu-id="5c64e-2314">15</span></span>|<span data-ttu-id="5c64e-2315">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="5c64e-2315">ldc.i4.m1</span></span>|<span data-ttu-id="5c64e-2316">Exécute un push de -1 dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2316">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2317">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2318">La valeur -1 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2318">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2319">Voici une courte un codage spécial pour le push de la valeur entière 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2319">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="5c64e-2320">Tous les encodages abrégés spéciaux push des entiers de 4 octets dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2320">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2321">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.m1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2321">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2322">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2322">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2323">Exécute un push fourni <see langword="int8" /> valeur dans la pile d’évaluation en tant qu’un <see langword="int32" />, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2323">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2324">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2324">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2325">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2325">Format</span></span>|<span data-ttu-id="5c64e-2326">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2326">Assembly Format</span></span>|<span data-ttu-id="5c64e-2327">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2327">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2328">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2328">1F < `int8` ></span></span>|<span data-ttu-id="5c64e-2329">ldc.i4.s `num`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2329">ldc.i4.s `num`</span></span>|<span data-ttu-id="5c64e-2330">Exécute un push `num` dans la pile en tant que `int32`, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2330">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-2331">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2331">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2332">La valeur `num` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2332">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2333">`ldc.i4.s` est un encodage plus efficace pour pousser les entiers de -128 à 127 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2333">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2334">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i4.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2335">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2335">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2336">Exécute un push d’une valeur fournie de type <see langword="int64" /> dans la pile d’évaluation en tant qu’un <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2336">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2337">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2338">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2338">Format</span></span>|<span data-ttu-id="5c64e-2339">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2339">Assembly Format</span></span>|<span data-ttu-id="5c64e-2340">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2341">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2341">21 < `int64` ></span></span>|<span data-ttu-id="5c64e-2342">ldc.i8 `num`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2342">ldc.i8 `num`</span></span>|<span data-ttu-id="5c64e-2343">Exécute un push `num` dans la pile en tant que `int64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2343">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="5c64e-2344">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2345">La valeur `num` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2345">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2346">Cet encodage exécute un push d’un `int64` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2346">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2347">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.i8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2348">ILGenerator.Emit(OpCode, long)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2348">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2349">Exécute un push d’une valeur fournie de type <see langword="float32" /> dans la pile d’évaluation en tant que type <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2349">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2350">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2351">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2351">Format</span></span>|<span data-ttu-id="5c64e-2352">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2352">Assembly Format</span></span>|<span data-ttu-id="5c64e-2353">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2354">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2354">22 < `float32` ></span></span>|<span data-ttu-id="5c64e-2355">ldc.r4 `num`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2355">ldc.r4 `num`</span></span>|<span data-ttu-id="5c64e-2356">Exécute un push `num` dans la pile en tant que `F`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2356">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="5c64e-2357">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2358">La valeur `num` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2358">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2359">Cet encodage exécute un push d’un `float32` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2359">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2360">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.r4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2361">ILGenerator.Emit(OpCode, single)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2361">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2362">Exécute un push d’une valeur fournie de type <see langword="float64" /> dans la pile d’évaluation en tant que type <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2362">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2363">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2364">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2364">Format</span></span>|<span data-ttu-id="5c64e-2365">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2365">Assembly Format</span></span>|<span data-ttu-id="5c64e-2366">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2367">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2367">23 < `float64` ></span></span>|<span data-ttu-id="5c64e-2368">ldc.r8 `num`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2368">ldc.r8 `num`</span></span>|<span data-ttu-id="5c64e-2369">Exécute un push `num` dans la pile en tant que `F`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2369">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="5c64e-2370">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2371">La valeur `num` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2371">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2372">Cet encodage exécute un push d’un `float64` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2372">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2373">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldc.r8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2373">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2374">ILGenerator.Emit(OpCode, double)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2374">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2375">Charge l’élément à un index de tableau spécifié en haut de la pile d’évaluation en tant que le type spécifié dans l’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2375">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2376">Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2376">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2377">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2377">Format</span></span>|<span data-ttu-id="5c64e-2378">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2378">Assembly Format</span></span>|<span data-ttu-id="5c64e-2379">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2379">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2380">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2380">A3 < `T` ></span></span>|<span data-ttu-id="5c64e-2381">ldelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2381">ldelem `typeTok`</span></span>|<span data-ttu-id="5c64e-2382">Charge l’élément à `index` en haut de la pile en tant que type `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2382">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="5c64e-2383">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2383">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2384">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2384">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2385">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2385">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2386">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2386">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2387">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2387">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2388">Le `ldelem` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2388">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2389">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2389">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2390">Le type de la valeur de retour est spécifié par le jeton `typeTok` dans l’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2390">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="5c64e-2391"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2391"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2392"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite supérieure de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2392"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2393">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2393">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2394">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2394">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2395">Charge l’élément avec le type <see langword="native int" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2395">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2396">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2396">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2397">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2397">Format</span></span>|<span data-ttu-id="5c64e-2398">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2398">Assembly Format</span></span>|<span data-ttu-id="5c64e-2399">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2399">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2400">97</span><span class="sxs-lookup"><span data-stu-id="5c64e-2400">97</span></span>|<span data-ttu-id="5c64e-2401">ldelem.i</span><span class="sxs-lookup"><span data-stu-id="5c64e-2401">ldelem.i</span></span>|<span data-ttu-id="5c64e-2402">Charge l’élément avec le type `native int` à `index` en haut de la pile en tant qu’un `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2402">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="5c64e-2403">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2403">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2404">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2404">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2405">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2405">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2406">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2406">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2407">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2407">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2408">Le `ldelem.i` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2408">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2409">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2409">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2410">La valeur de retour pour `ldelem.i` est `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2410">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-2411">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2411">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2412"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2412"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2413"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2413"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2414"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2414"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2415">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2415">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2416">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2416">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2417">Charge l’élément avec le type <see langword="int8" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2417">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2418">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2418">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2419">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2419">Format</span></span>|<span data-ttu-id="5c64e-2420">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2420">Assembly Format</span></span>|<span data-ttu-id="5c64e-2421">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2421">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2422">90</span><span class="sxs-lookup"><span data-stu-id="5c64e-2422">90</span></span>|<span data-ttu-id="5c64e-2423">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="5c64e-2423">ldelem.i1</span></span>|<span data-ttu-id="5c64e-2424">Charge l’élément avec le type `int8` à `index` en haut de la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2424">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2425">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2425">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2426">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2426">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2427">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2427">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2428">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2428">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2429">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2429">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2430">Le `ldelem.i1` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2430">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2431">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2431">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2432">La valeur de retour pour `ldelem.i1` est `int8`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2432">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="5c64e-2433">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2433">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2434"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2434"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2435"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2435"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2436"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2436"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2437">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2437">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2438">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2438">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2439">Charge l’élément avec le type <see langword="int16" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2439">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2440">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2440">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2441">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2441">Format</span></span>|<span data-ttu-id="5c64e-2442">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2442">Assembly Format</span></span>|<span data-ttu-id="5c64e-2443">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2443">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2444">92</span><span class="sxs-lookup"><span data-stu-id="5c64e-2444">92</span></span>|<span data-ttu-id="5c64e-2445">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="5c64e-2445">ldelem.i2</span></span>|<span data-ttu-id="5c64e-2446">Charge l’élément avec le type `int16` à `index` en haut de la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2446">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2447">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2447">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2448">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2448">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2449">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2449">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2450">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2450">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2451">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2451">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2452">Le `ldelem.i2` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2452">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2453">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2453">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2454">La valeur de retour pour `ldelem.i2` est `int16`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2454">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="5c64e-2455">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2455">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2456"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2456"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2457"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2457"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2458"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2458"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2459">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2460">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2460">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2461">Charge l’élément avec le type <see langword="int32" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2461">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2462">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2462">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2463">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2463">Format</span></span>|<span data-ttu-id="5c64e-2464">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2464">Assembly Format</span></span>|<span data-ttu-id="5c64e-2465">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2466">94</span><span class="sxs-lookup"><span data-stu-id="5c64e-2466">94</span></span>|<span data-ttu-id="5c64e-2467">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="5c64e-2467">ldelem.i4</span></span>|<span data-ttu-id="5c64e-2468">Charge l’élément avec le type `int32` à `index` en haut de la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2468">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2469">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2470">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2470">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2471">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2471">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2472">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2472">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2473">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2473">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2474">Le `ldelem.i4` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2474">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2475">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2475">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2476">La valeur de retour pour `ldelem.i4` est `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2476">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2477">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2477">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2478"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2478"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2479"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2479"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2480"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2480"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2481">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2481">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2482">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2482">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2483">Charge l’élément avec le type <see langword="int64" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2483">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2484">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2484">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2485">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2485">Format</span></span>|<span data-ttu-id="5c64e-2486">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2486">Assembly Format</span></span>|<span data-ttu-id="5c64e-2487">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2487">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2488">96</span><span class="sxs-lookup"><span data-stu-id="5c64e-2488">96</span></span>|<span data-ttu-id="5c64e-2489">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="5c64e-2489">ldelem.i8</span></span>|<span data-ttu-id="5c64e-2490">Charge l’élément avec le type `int64` à `index` en haut de la pile en tant qu’un `int64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2490">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="5c64e-2491">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2491">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2492">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2492">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2493">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2493">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2494">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2494">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2495">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2495">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2496">Le `ldelem.i8` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2496">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2497">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2497">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2498">La valeur de retour pour `ldelem.i8` est `int64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2498">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="5c64e-2499">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2499">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2500"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2500"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2501"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2501"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2502"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2502"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2503">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.i8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2503">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2504">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2504">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2505">Charge l’élément avec le type <see langword="float32" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant que type <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2505">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2506">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2506">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2507">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2507">Format</span></span>|<span data-ttu-id="5c64e-2508">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2508">Assembly Format</span></span>|<span data-ttu-id="5c64e-2509">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2509">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2510">98</span><span class="sxs-lookup"><span data-stu-id="5c64e-2510">98</span></span>|<span data-ttu-id="5c64e-2511">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="5c64e-2511">ldelem.r4</span></span>|<span data-ttu-id="5c64e-2512">Charge l’élément avec le type `float32` à `index` en haut de la pile en tant que type `F`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2512">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="5c64e-2513">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2513">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2514">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2514">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2515">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2515">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2516">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2516">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2517">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2517">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2518">Le `ldelem.r4` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2518">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2519">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2519">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2520">La valeur de retour pour `ldelem.r4` est `float32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2520">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="5c64e-2521">Valeurs à virgule flottante sont convertis en type `F` lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2521">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2522"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2522"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2523"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2523"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2524"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2524"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2525">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.r4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2525">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2526">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2526">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2527">Charge l’élément avec le type <see langword="float64" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant que type <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2527">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2528">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2528">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2529">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2529">Format</span></span>|<span data-ttu-id="5c64e-2530">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2530">Assembly Format</span></span>|<span data-ttu-id="5c64e-2531">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2531">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2532">99</span><span class="sxs-lookup"><span data-stu-id="5c64e-2532">99</span></span>|<span data-ttu-id="5c64e-2533">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="5c64e-2533">ldelem.r8</span></span>|<span data-ttu-id="5c64e-2534">Charge l’élément avec le type `float64` à `index` en haut de la pile en tant que type `F`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2534">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="5c64e-2535">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2535">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2536">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2536">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2537">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2537">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2538">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2538">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2539">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2539">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2540">Le `ldelem.r8` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2540">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2541">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2541">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2542">La valeur de retour pour `ldelem.r8` est `float64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2542">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="5c64e-2543">Valeurs à virgule flottante sont convertis en type `F` lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2543">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2544"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2544"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2545"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2545"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2546"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2546"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2547">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.r8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2547">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2548">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2548">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2549">Charge l’élément contenant une référence d’objet à un index de tableau spécifié en haut de la pile d’évaluation en tant que type <see langword="O" /> (référence d’objet).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2549">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2550">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2550">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2551">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2551">Format</span></span>|<span data-ttu-id="5c64e-2552">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2552">Assembly Format</span></span>|<span data-ttu-id="5c64e-2553">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2553">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2554">9A</span><span class="sxs-lookup"><span data-stu-id="5c64e-2554">9A</span></span>|<span data-ttu-id="5c64e-2555">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="5c64e-2555">ldelem.ref</span></span>|<span data-ttu-id="5c64e-2556">Charge l’élément avec une référence d’objet à `index` en haut de la pile en tant que type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2556">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="5c64e-2557">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2557">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2558">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2558">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2559">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2559">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2560">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2560">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2561">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2561">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2562">Le `ldelem.ref` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2562">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2563">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2563">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2564">La valeur de retour pour `ldelem.ref` est de type `O` (référence d’objet).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2564">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="5c64e-2565"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2565"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2566"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2566"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2567"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2567"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2568">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.ref` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2568">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2569">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2569">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2570">Charge l’élément avec le type <see langword="unsigned int8" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2570">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2571">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2571">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2572">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2572">Format</span></span>|<span data-ttu-id="5c64e-2573">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2573">Assembly Format</span></span>|<span data-ttu-id="5c64e-2574">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2574">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2575">91</span><span class="sxs-lookup"><span data-stu-id="5c64e-2575">91</span></span>|<span data-ttu-id="5c64e-2576">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="5c64e-2576">ldelem.u1</span></span>|<span data-ttu-id="5c64e-2577">Charge l’élément avec le type `unsigned int8` à `index` en haut de la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2577">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2578">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2578">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2579">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2579">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2580">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2580">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2581">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2581">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2582">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2582">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2583">Le `ldelem.u1` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2583">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2584">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2584">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2585">La valeur de retour pour `ldelem.u1` est `int8`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2585">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="5c64e-2586">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2586">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2587"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2587"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2588"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2588"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2589"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2589"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2590">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.u1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2590">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2591">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2591">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2592">Charge l’élément avec le type <see langword="unsigned int16" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2592">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2593">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2593">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2594">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2594">Format</span></span>|<span data-ttu-id="5c64e-2595">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2595">Assembly Format</span></span>|<span data-ttu-id="5c64e-2596">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2596">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2597">93</span><span class="sxs-lookup"><span data-stu-id="5c64e-2597">93</span></span>|<span data-ttu-id="5c64e-2598">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="5c64e-2598">ldelem.u2</span></span>|<span data-ttu-id="5c64e-2599">Charge l’élément avec le type `unsigned int16` à index en haut de la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2599">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2600">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2600">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2601">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2601">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2602">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2602">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2603">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2603">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2604">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2604">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2605">Le `ldelem.u2` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2605">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2606">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2606">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2607">La valeur de retour pour `ldelem.u2` est `int16`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2607">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="5c64e-2608">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2608">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2609"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2609"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2610"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2610"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2611"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2611"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2612">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.u2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2612">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2613">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2613">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2614">Charge l’élément avec le type <see langword="unsigned int32" /> à un index de tableau spécifié en haut de la pile d’évaluation en tant qu’un <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2614">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2615">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2615">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2616">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2616">Format</span></span>|<span data-ttu-id="5c64e-2617">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2617">Assembly Format</span></span>|<span data-ttu-id="5c64e-2618">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2618">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2619">95</span><span class="sxs-lookup"><span data-stu-id="5c64e-2619">95</span></span>|<span data-ttu-id="5c64e-2620">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="5c64e-2620">ldelem.u4</span></span>|<span data-ttu-id="5c64e-2621">Charge l’élément avec le type `unsigned int32` à index en haut de la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2621">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2622">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2622">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2623">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2623">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2624">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2624">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2625">`index` et `array` sont dépilés ; la valeur stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2625">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2626">La valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2626">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2627">Le `ldelem.u4` instruction charge la valeur de l’élément avec index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2627">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2628">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2628">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2629">La valeur de retour pour `ldelem.u4` est `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2629">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2630">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2630">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2631"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2631"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2632"><xref:System.ArrayTypeMismatchException> est levée si le tableau ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2632"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2633"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2633"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2634">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelem.u4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2634">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2635">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2635">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2636">Charge l’adresse de l’élément de tableau à un index de tableau spécifié en haut de la pile d’évaluation en tant que type <see langword="&amp;" /> (pointeur managé).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2636">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2637">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2637">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2638">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2638">Format</span></span>|<span data-ttu-id="5c64e-2639">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2639">Assembly Format</span></span>|<span data-ttu-id="5c64e-2640">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2640">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2641">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2641">8F < `T` ></span></span>|<span data-ttu-id="5c64e-2642">ldelema `class`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2642">ldelema `class`</span></span>|<span data-ttu-id="5c64e-2643">Charge l’adresse de l’élément de tableau à `index` en haut de la pile d’évaluation en tant que type `&` (pointeur managé).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2643">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="5c64e-2644">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2644">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2645">Une référence d’objet `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2645">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2646">Une valeur d’index `index` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2646">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-2647">`index` et `array` sont dépilés ; l’adresse stockée à la position `index` dans `array` est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2647">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="5c64e-2648">L’adresse est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2648">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2649">Le `ldelema` est utilisé pour récupérer l’adresse d’un objet à un index particulier dans un tableau d’objets (de type `class`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2649">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="5c64e-2650">Le `ldelema` instruction charge l’adresse de la valeur à l’index `index` (type `native int`) dans le tableau unidimensionnel de base zéro `array` et le place en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2650">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="5c64e-2651">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2651">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-2652">La valeur doit être de type `class` passé avec l’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2652">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="5c64e-2653">La valeur de retour pour `ldelema` est un pointeur managé (type `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2653">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="5c64e-2654">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2654">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2655"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2655"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-2656"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2656"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-2657"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2657"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-2658">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldelema` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2658">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2659">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2659">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2660">Recherche la valeur d'un champ dans l'objet dont la référence est actuellement située dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2660">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2661">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2661">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2662">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2662">Format</span></span>|<span data-ttu-id="5c64e-2663">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2663">Assembly Format</span></span>|<span data-ttu-id="5c64e-2664">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2664">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2665">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2665">7B < `T` ></span></span>|<span data-ttu-id="5c64e-2666">ldfld `field`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2666">ldfld `field`</span></span>|<span data-ttu-id="5c64e-2667">Exécute un push de la valeur d’un champ dans un objet spécifié dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2667">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2668">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2668">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2669">Une référence d’objet (ou pointeur) est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2669">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2670">La référence d’objet (ou pointeur) est retirée de la pile ; la valeur du champ spécifié dans l’objet est trouvée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2670">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="5c64e-2671">La valeur stockée dans le champ est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2671">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2672">La `ldfld` instruction exécute un push de la valeur d’un champ situé dans un objet dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2672">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="5c64e-2673">L’objet doit se trouver sur la pile en tant que référence d’objet (type `O`), un pointeur managé (type `&`), un pointeur non managé (type `native int`), un pointeur transitoire (type `*`), ou une instance d’un type valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2673">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="5c64e-2674">L’utilisation d’un pointeur non managé n’est pas autorisée dans du code vérifiable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2674">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="5c64e-2675">Champ de l’objet est spécifié par un jeton de métadonnées qui doit faire référence à un membre de champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2675">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="5c64e-2676">Le type de retour est identique à celui associé au champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2676">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="5c64e-2677">Le champ peut être un champ d’instance (auquel cas l’objet ne doit pas être une référence null) ou un champ statique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2677">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="5c64e-2678">Le `ldfld` instruction peut être précédée d’une des deux le <xref:System.Reflection.Emit.OpCodes.Unaligned> et <xref:System.Reflection.Emit.OpCodes.Volatile> préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2678">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="5c64e-2679"><xref:System.NullReferenceException> est levée si l’objet est null et que le champ n’est pas statique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2679"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="5c64e-2680"><xref:System.MissingFieldException> est levée si le champ spécifié est introuvable dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2680"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="5c64e-2681">Cette option est généralement activée lorsque des instructions de langage MSIL (Microsoft Intermediate Language) en code natif, pas en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2681">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="5c64e-2682">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldfld` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2682">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2683">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2683">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2684">Recherche l'adresse d'un champ dans l'objet dont la référence est actuellement située dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2684">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2685">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2685">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2686">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2686">Format</span></span>|<span data-ttu-id="5c64e-2687">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2687">Assembly Format</span></span>|<span data-ttu-id="5c64e-2688">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2688">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2689">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2689">7C < `T` ></span></span>|<span data-ttu-id="5c64e-2690">ldflda `field`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2690">ldflda `field`</span></span>|<span data-ttu-id="5c64e-2691">Exécute un push de l’adresse de `field` dans un objet spécifié dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2691">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2692">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2692">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2693">Une référence d’objet (ou pointeur) est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2693">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2694">La référence d’objet (ou pointeur) est retirée de la pile ; l’adresse du champ spécifié dans l’objet est trouvé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2694">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="5c64e-2695">L’adresse du champ spécifié est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2695">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2696">La `ldflda` instruction exécute un push de l’adresse d’un champ situé dans un objet dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2696">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="5c64e-2697">L’objet doit se trouver sur la pile en tant que référence d’objet (type `O`), un pointeur managé (type `&`), un pointeur non managé (type `native int`), un pointeur transitoire (type `*`), ou une instance d’un type valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2697">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="5c64e-2698">L’utilisation d’un pointeur non managé n’est pas autorisée dans du code vérifiable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2698">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="5c64e-2699">Champ de l’objet est spécifié par un jeton de métadonnées qui doit faire référence à un membre de champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2699">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="5c64e-2700">La valeur retournée par `ldflda` est un pointeur managé (type `&`), sauf si l’objet est placé sur la pile en tant que pointeur non managé, auquel cas l’adresse de retour est également un pointeur non managé (type `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2700">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="5c64e-2701">Le `ldflda` instruction peut être précédée d’une des deux le <xref:System.Reflection.Emit.OpCodes.Unaligned> et <xref:System.Reflection.Emit.OpCodes.Volatile> préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2701">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="5c64e-2702"><xref:System.InvalidOperationException> est levée si l’objet n’est pas dans le domaine d’application à partir de laquelle il est accessible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2702"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="5c64e-2703">L’adresse d’un champ qui n’est pas dans le domaine d’application accès ne peut pas être chargé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2703">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="5c64e-2704"><xref:System.NullReferenceException> est levée si l’objet est null et que le champ n’est pas statique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2704"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="5c64e-2705"><xref:System.MissingFieldException> est levée si le champ spécifié est introuvable dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2705"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="5c64e-2706">Cette option est généralement activée lorsque des instructions de langage MSIL (Microsoft Intermediate Language) en code natif, pas en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2706">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="5c64e-2707">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldflda` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2707">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2708">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2708">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2709">Exécute un push d’un pointeur non managé (type <see langword="native int" />) sur le code natif implémentant une méthode spécifique dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2709">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2710">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2710">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2711">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2711">Format</span></span>|<span data-ttu-id="5c64e-2712">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2712">Assembly Format</span></span>|<span data-ttu-id="5c64e-2713">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2713">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2714">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-2714">FE 06 < `T` ></span></span>|<span data-ttu-id="5c64e-2715">ldftn `method`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2715">ldftn `method`</span></span>|<span data-ttu-id="5c64e-2716">Exécute un push d’un pointeur vers une méthode référencée par `method` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2716">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2717">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2717">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2718">Le pointeur non managé vers une méthode spécifique est envoyé à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2718">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2719">La méthode spécifique (`method`) peut être appelée à l’aide de la <xref:System.Reflection.Emit.OpCodes.Calli> instruction si elle fait référence à une méthode managée (ou un stub qui effectue la transition à partir de code non managé).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2719">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="5c64e-2720">La valeur retournée de points de code natif à l’aide de la convention d’appel de CLR.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2720">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="5c64e-2721">Ce pointeur de la méthode ne doit pas être passé au code natif non managé comme une routine de rappel.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2721">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="5c64e-2722">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldftn` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2723">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2723">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2724">Charge une valeur de type <see langword="native int" /> comme un <see langword="native int" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2724">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2725">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2726">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2726">Format</span></span>|<span data-ttu-id="5c64e-2727">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2727">Assembly Format</span></span>|<span data-ttu-id="5c64e-2728">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2729">4D</span><span class="sxs-lookup"><span data-stu-id="5c64e-2729">4D</span></span>|<span data-ttu-id="5c64e-2730">ldind.i</span><span class="sxs-lookup"><span data-stu-id="5c64e-2730">ldind.i</span></span>|<span data-ttu-id="5c64e-2731">Charge le `native int` valeur à l’adresse `addr` dans la pile en tant qu’un `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2731">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="5c64e-2732">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2732">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2733">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2733">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2734">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2734">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2735">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2735">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2736">Le `ldind.i` instruction charge indirectement une `native int` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2736">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-2737">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2737">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2738">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2738">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2739">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2739">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2740">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2740">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2741">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2741">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2742">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2742">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2743">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2743">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2744">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2744">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2745"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2745"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2746">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2746">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2747">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2747">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2748">Charge une valeur de type <see langword="int8" /> comme un <see langword="int32" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2748">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2749">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2749">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2750">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2750">Format</span></span>|<span data-ttu-id="5c64e-2751">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2751">Assembly Format</span></span>|<span data-ttu-id="5c64e-2752">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2752">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2753">46</span><span class="sxs-lookup"><span data-stu-id="5c64e-2753">46</span></span>|<span data-ttu-id="5c64e-2754">ldind.i1</span><span class="sxs-lookup"><span data-stu-id="5c64e-2754">ldind.i1</span></span>|<span data-ttu-id="5c64e-2755">Charge le `int8` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2755">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2756">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2756">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2757">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2757">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2758">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2758">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2759">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2759">The fetched value is pushed onto the stack.</span></span> 
  
 <span data-ttu-id="5c64e-2760">Le `ldind.i1` instruction charge indirectement une `int8` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2760">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2761">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2761">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2762">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2762">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2763">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2763">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2764">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2764">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2765">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2765">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2766">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2766">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2767">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2767">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2768">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2768">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2769"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2769"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2770">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2770">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2771">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2771">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2772">Charge une valeur de type <see langword="int16" /> comme un <see langword="int32" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2772">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2773">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2773">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2774">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2774">Format</span></span>|<span data-ttu-id="5c64e-2775">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2775">Assembly Format</span></span>|<span data-ttu-id="5c64e-2776">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2776">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2777">48</span><span class="sxs-lookup"><span data-stu-id="5c64e-2777">48</span></span>|<span data-ttu-id="5c64e-2778">ldind.i2</span><span class="sxs-lookup"><span data-stu-id="5c64e-2778">ldind.i2</span></span>|<span data-ttu-id="5c64e-2779">Charge le `int16` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2779">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2780">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2780">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2781">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2781">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2782">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2782">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2783">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2783">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2784">Le `ldind.i2` instruction charge indirectement une `int16` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2784">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2785">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2785">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2786">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2786">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2787">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2787">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2788">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2788">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2789">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2789">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2790">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2790">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2791">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2791">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2792">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2792">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2793"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2793"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2794">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2794">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2795">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2795">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2796">Charge une valeur de type <see langword="int32" /> comme un <see langword="int32" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2796">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2797">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2797">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2798">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2798">Format</span></span>|<span data-ttu-id="5c64e-2799">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2799">Assembly Format</span></span>|<span data-ttu-id="5c64e-2800">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2800">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2801">4A</span><span class="sxs-lookup"><span data-stu-id="5c64e-2801">4A</span></span>|<span data-ttu-id="5c64e-2802">ldind.i4</span><span class="sxs-lookup"><span data-stu-id="5c64e-2802">ldind.i4</span></span>|<span data-ttu-id="5c64e-2803">Charge le `int32` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2803">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2804">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2804">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2805">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2805">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2806">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2806">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2807">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2807">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2808">Le `ldind.i4` instruction charge indirectement une `int32` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2808">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2809">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2809">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2810">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2810">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2811">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2811">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2812">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2812">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2813">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2813">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2814">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2814">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2815">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2815">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2816">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2816">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2817"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2817"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2818">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2819">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2819">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2820">Charge une valeur de type <see langword="int64" /> comme un <see langword="int64" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2820">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2821">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2821">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2822">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2822">Format</span></span>|<span data-ttu-id="5c64e-2823">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2823">Assembly Format</span></span>|<span data-ttu-id="5c64e-2824">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2824">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2825">4C</span><span class="sxs-lookup"><span data-stu-id="5c64e-2825">4C</span></span>|<span data-ttu-id="5c64e-2826">ldind.i8</span><span class="sxs-lookup"><span data-stu-id="5c64e-2826">ldind.i8</span></span>|<span data-ttu-id="5c64e-2827">Charge le `int64` valeur à l’adresse `addr` dans la pile en tant qu’un `int64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2827">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="5c64e-2828">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2828">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2829">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2829">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2830">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2830">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2831">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2831">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2832">Le `ldind.i8` instruction charge indirectement une `int64` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `int64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2832">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="5c64e-2833">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2833">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2834">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2834">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2835">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2835">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2836">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2836">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2837">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2837">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2838">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2838">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2839">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2839">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2840">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2840">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2841"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2841"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2842">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.i8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2842">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2843">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2843">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2844">Charge une valeur de type <see langword="float32" /> en tant que type <see langword="F" /> (float) dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2844">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2845">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2845">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2846">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2846">Format</span></span>|<span data-ttu-id="5c64e-2847">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2847">Assembly Format</span></span>|<span data-ttu-id="5c64e-2848">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2848">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2849">4E</span><span class="sxs-lookup"><span data-stu-id="5c64e-2849">4E</span></span>|<span data-ttu-id="5c64e-2850">ldind.r4</span><span class="sxs-lookup"><span data-stu-id="5c64e-2850">ldind.r4</span></span>|<span data-ttu-id="5c64e-2851">Charge le `float32` valeur à l’adresse `addr` dans la pile en tant que type `F`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2851">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="5c64e-2852">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2852">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2853">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2853">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2854">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2854">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2855">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2855">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2856">Le `ldind.r4` instruction charge indirectement une `float32` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant que type `F`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2856">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="5c64e-2857">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2857">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2858">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2858">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2859">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2859">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2860">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2860">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2861">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2861">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2862">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2862">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2863">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2863">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2864">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2864">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2865"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2865"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2866">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.r4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2866">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2867">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2867">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2868">Charge une valeur de type <see langword="float64" /> en tant que type <see langword="F" /> (float) dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2868">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2869">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2869">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2870">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2870">Format</span></span>|<span data-ttu-id="5c64e-2871">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2871">Assembly Format</span></span>|<span data-ttu-id="5c64e-2872">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2872">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2873">4F</span><span class="sxs-lookup"><span data-stu-id="5c64e-2873">4F</span></span>|<span data-ttu-id="5c64e-2874">ldind.r8</span><span class="sxs-lookup"><span data-stu-id="5c64e-2874">ldind.r8</span></span>|<span data-ttu-id="5c64e-2875">Charge le `float64` valeur à l’adresse `addr` dans la pile en tant que type `F`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2875">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="5c64e-2876">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2876">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2877">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2877">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2878">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2878">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2879">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2879">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2880">Le `ldind.r8` instruction charge indirectement une `float64` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `float64`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2880">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="5c64e-2881">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2881">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2882">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2882">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2883">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2883">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2884">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2884">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2885">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2885">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2886">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2886">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2887">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2887">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2888">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2888">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2889"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2889"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2890">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.r8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2890">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2891">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2891">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2892">Charge une référence d’objet en tant que type <see langword="O" /> (référence d’objet) dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2892">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2893">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2893">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2894">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2894">Format</span></span>|<span data-ttu-id="5c64e-2895">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2895">Assembly Format</span></span>|<span data-ttu-id="5c64e-2896">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2896">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2897">50</span><span class="sxs-lookup"><span data-stu-id="5c64e-2897">50</span></span>|<span data-ttu-id="5c64e-2898">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="5c64e-2898">ldind.ref</span></span>|<span data-ttu-id="5c64e-2899">Charge la référence d’objet à l’adresse `addr` dans la pile en tant que type `O`</span><span class="sxs-lookup"><span data-stu-id="5c64e-2899">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="5c64e-2900">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2900">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2901">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2901">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2902">L’adresse est retirée de la pile ; la référence d’objet située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2902">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2903">La référence extraite est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2903">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2904">Le `ldind.ref` instruction charge indirectement la référence d’objet l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant que type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2904">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="5c64e-2905">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2905">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2906">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2906">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2907">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2907">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2908">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2908">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2909">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2909">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2910">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2910">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2911">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2911">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2912">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2912">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2913"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2913"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2914">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.ref` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2915">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2916">Charge une valeur de type <see langword="unsigned int8" /> comme un <see langword="int32" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2916">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2917">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2918">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2918">Format</span></span>|<span data-ttu-id="5c64e-2919">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2919">Assembly Format</span></span>|<span data-ttu-id="5c64e-2920">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2921">47</span><span class="sxs-lookup"><span data-stu-id="5c64e-2921">47</span></span>|<span data-ttu-id="5c64e-2922">ldind.u1</span><span class="sxs-lookup"><span data-stu-id="5c64e-2922">ldind.u1</span></span>|<span data-ttu-id="5c64e-2923">Charge le `unsigned int8` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2923">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2924">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2925">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2925">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2926">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2926">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2927">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2927">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2928">Le `ldind.u1` instruction charge indirectement une `unsigned int8` valeur à partir de l’adresse spécifiée (de type`native int`, `&`, ou \*) dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2928">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2929">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2929">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2930">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2930">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2931">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2931">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2932">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2932">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2933">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2933">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2934">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2934">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2935">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2935">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2936">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2936">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2937"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2937"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2938">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.u1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2938">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2939">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2939">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2940">Charge une valeur de type <see langword="unsigned int16" /> comme un <see langword="int32" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2940">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2941">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2942">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2942">Format</span></span>|<span data-ttu-id="5c64e-2943">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2943">Assembly Format</span></span>|<span data-ttu-id="5c64e-2944">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2945">49</span><span class="sxs-lookup"><span data-stu-id="5c64e-2945">49</span></span>|<span data-ttu-id="5c64e-2946">ldind.u2</span><span class="sxs-lookup"><span data-stu-id="5c64e-2946">ldind.u2</span></span>|<span data-ttu-id="5c64e-2947">Charge le `unsigned int16` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2947">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2948">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2949">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2949">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2950">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2950">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2951">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2951">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2952">Le `ldind.u2` instruction charge indirectement une `unsigned int16` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2952">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2953">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2953">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2954">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2954">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2955">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2955">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2956">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2956">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2957">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2957">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2958">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2958">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2959">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2959">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2960">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2960">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2961"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2961"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2962">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.u2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2962">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2963">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2963">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2964">Charge une valeur de type <see langword="unsigned int32" /> comme un <see langword="int32" /> dans la pile d’évaluation indirectement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2964">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2965">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2965">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2966">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2966">Format</span></span>|<span data-ttu-id="5c64e-2967">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2967">Assembly Format</span></span>|<span data-ttu-id="5c64e-2968">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2968">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2969">4B</span><span class="sxs-lookup"><span data-stu-id="5c64e-2969">4B</span></span>|<span data-ttu-id="5c64e-2970">ldind.u4</span><span class="sxs-lookup"><span data-stu-id="5c64e-2970">ldind.u4</span></span>|<span data-ttu-id="5c64e-2971">Charge le `unsigned int32` valeur à l’adresse `addr` dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2971">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-2972">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2972">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2973">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2973">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2974">L’adresse est retirée de la pile ; la valeur située à l’adresse est extraite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2974">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="5c64e-2975">La valeur récupérée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2975">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-2976">Le `ldind.u4` instruction charge indirectement une `unsigned int32` valeur à partir de l’adresse spécifiée (de type `native int`, `&`, ou \*) dans la pile en tant qu’un `int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2976">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="5c64e-2977">Tous les `ldind` instructions sont des raccourcis pour un <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction qui spécifie la classe de valeur intégrée correspondante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2977">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="5c64e-2978">Notez que les valeurs entières inférieures à 4 octets sont étendues à `int32` (pas `native int`) lorsqu’elles sont chargées dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2978">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="5c64e-2979">Les valeurs à virgule flottante sont converties en `F` tapez lors du chargement dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2979">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-2980">Correct langage MSIL (Microsoft Intermediate) garantit que le `ldind` instructions sont utilisées de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2980">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="5c64e-2981">L’adresse initialement placé sur la pile doit être alignée avec la taille naturelle des objets sur l’ordinateur ou un <xref:System.NullReferenceException> peut se produire (consultez la <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction pour des mesures préventives du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-2981">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="5c64e-2982">Les résultats de toutes les instructions MSIL qui retournent des adresses (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloca> et <xref:System.Reflection.Emit.OpCodes.Ldarga>) sont alignés en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2982">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="5c64e-2983">Pour les types de données supérieurs à 1 octet, le classement des octets dépend de l’unité centrale cible.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2983">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="5c64e-2984">Code qui dépend de l’ordre des octets ne peut pas exécuter sur toutes les plateformes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2984">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="5c64e-2985"><xref:System.NullReferenceException> peut être levée si une adresse non valide est détectée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2985"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="5c64e-2986">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldind.u4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2986">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-2987">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-2987">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-2988">Exécute un push du nombre d'éléments d'un tableau unidimensionnel de base zéro dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2988">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-2989">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2989">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-2990">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-2990">Format</span></span>|<span data-ttu-id="5c64e-2991">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-2991">Assembly Format</span></span>|<span data-ttu-id="5c64e-2992">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-2992">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-2993">8E</span><span class="sxs-lookup"><span data-stu-id="5c64e-2993">8E</span></span>|<span data-ttu-id="5c64e-2994">ldlen</span><span class="sxs-lookup"><span data-stu-id="5c64e-2994">ldlen</span></span>|<span data-ttu-id="5c64e-2995">Exécute un push de la longueur (de type `natural unsigned int`) d’un tableau sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2995">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-2996">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-2996">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-2997">Une référence d’objet à un tableau est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2997">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-2998">La référence de tableau est dépilée et la longueur est calculée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2998">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="5c64e-2999">La longueur est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-2999">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3000">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3000">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3001">La longueur est retournée en tant qu’un `natural unsigned int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3001">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="5c64e-3002"><xref:System.NullReferenceException> est levé si la référence de tableau est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3002"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3003">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldlen` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3003">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3004">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3004">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3005">Charge la variable locale à un index spécifique dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3005">Loads the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3006">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3006">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3007">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3007">Format</span></span>|<span data-ttu-id="5c64e-3008">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3008">Assembly Format</span></span>|<span data-ttu-id="5c64e-3009">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3009">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3010">FE 0C < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3010">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="5c64e-3011">ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3011">ldloc `index`</span></span>|<span data-ttu-id="5c64e-3012">Charge la variable locale à l’index `index` sur pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3012">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3013">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3013">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3014">La valeur de variable locale à l’index spécifié est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3014">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3015">La `ldloc` instruction exécute un push le contenu de la variable locale à l’index passé dans la pile d’évaluation, où les variables locales sont numérotées à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3015">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="5c64e-3016">Variables locales sont initialisées à 0 avant d’entrer la méthode uniquement si l’indicateur d’initialisation sur la méthode a la valeur true.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3016">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="5c64e-3017">Il existe 65 535 (2 ^ 16 - 1) variables locales possibles (0-65 534).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3017">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="5c64e-3018">L’index 65 535 n’est pas valide, car les implémentations éventuelles utiliseront un entier de 2 octets pour effectuer le suivi à la fois un index de variable locale, ainsi que le nombre total de variables locales pour une méthode donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3018">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="5c64e-3019">Si un index 65 535 avait été rendu valide, un entier plus large pour suivre le nombre de variables locales dans une telle méthode serait nécessaire.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3019">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="5c64e-3020">Le `ldloc.0`, `ldloc.1`, `ldloc.2`, et `ldloc.3` fournissent un codage efficace pour l’accès aux quatre premières variables locales.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3020">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="5c64e-3021">Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3021">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="5c64e-3022">Consultez Partition I. Local variables qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3022">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-3023">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3023">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-3024">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `ldloc` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3024">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3025">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3025">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="5c64e-3026">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3026">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3027">Charge la variable locale à l'index 0 dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3027">Loads the local variable at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3028">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3028">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3029">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3029">Format</span></span>|<span data-ttu-id="5c64e-3030">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3030">Assembly Format</span></span>|<span data-ttu-id="5c64e-3031">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3031">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3032">06</span><span class="sxs-lookup"><span data-stu-id="5c64e-3032">06</span></span>|<span data-ttu-id="5c64e-3033">ldloc.0</span><span class="sxs-lookup"><span data-stu-id="5c64e-3033">ldloc.0</span></span>|<span data-ttu-id="5c64e-3034">Charge la variable locale à l'index 0 dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3034">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3035">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3035">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3036">La valeur de variable locale à l’index 0 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3036">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3037">`ldloc.0` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3037">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="5c64e-3038">Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3038">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="5c64e-3039">Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3039">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-3040">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3040">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-3041">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.0` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3041">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3042">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3042">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3043">Charge la variable locale à l’index 1 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3043">Loads the local variable at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3044">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3044">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3045">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3045">Format</span></span>|<span data-ttu-id="5c64e-3046">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3046">Assembly Format</span></span>|<span data-ttu-id="5c64e-3047">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3047">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3048">07</span><span class="sxs-lookup"><span data-stu-id="5c64e-3048">07</span></span>|<span data-ttu-id="5c64e-3049">ldloc.1</span><span class="sxs-lookup"><span data-stu-id="5c64e-3049">ldloc.1</span></span>|<span data-ttu-id="5c64e-3050">Charge la variable locale à l’index 1 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3050">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3051">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3051">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3052">La valeur de variable locale à l’index 1 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3052">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3053">`ldloc.1` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3053">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="5c64e-3054">Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3054">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="5c64e-3055">Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3055">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-3056">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3056">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-3057">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3057">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3058">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3058">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3059">Charge la variable locale à l’index 2 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3059">Loads the local variable at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3060">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3060">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3061">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3061">Format</span></span>|<span data-ttu-id="5c64e-3062">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3062">Assembly Format</span></span>|<span data-ttu-id="5c64e-3063">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3063">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3064">08</span><span class="sxs-lookup"><span data-stu-id="5c64e-3064">08</span></span>|<span data-ttu-id="5c64e-3065">ldloc.2</span><span class="sxs-lookup"><span data-stu-id="5c64e-3065">ldloc.2</span></span>|<span data-ttu-id="5c64e-3066">Charge la variable locale à l'index 2 dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3066">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3067">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3067">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3068">La valeur de variable locale à l’index 2 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3068">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3069">`ldloc.2` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 2.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3069">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="5c64e-3070">Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3070">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="5c64e-3071">Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3071">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-3072">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3072">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-3073">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3074">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3075">Charge la variable locale à l’index 3 dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3075">Loads the local variable at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3076">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3077">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3077">Format</span></span>|<span data-ttu-id="5c64e-3078">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3078">Assembly Format</span></span>|<span data-ttu-id="5c64e-3079">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3080">09</span><span class="sxs-lookup"><span data-stu-id="5c64e-3080">09</span></span>|<span data-ttu-id="5c64e-3081">ldloc.3</span><span class="sxs-lookup"><span data-stu-id="5c64e-3081">ldloc.3</span></span>|<span data-ttu-id="5c64e-3082">Charge la variable locale à l'index 3 dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3082">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3083">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3084">La valeur de variable locale à l’index 3 est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3084">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3085">`ldloc.3` est un encodage particulièrement efficace pour <xref:System.Reflection.Emit.OpCodes.Ldloc>, autorisant l’accès à la variable locale à l’index 3.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3085">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="5c64e-3086">Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3086">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="5c64e-3087">Les variables locales qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3087">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-3088">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-3089">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloc.3` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3090">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3091">Charge la variable locale à un index spécifique dans la pile d'évaluation (forme abrégée).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3091">Loads the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3092">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3093">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3093">Format</span></span>|<span data-ttu-id="5c64e-3094">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3094">Assembly Format</span></span>|<span data-ttu-id="5c64e-3095">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3096">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3096">11 < `unsigned int8` ></span></span>|<span data-ttu-id="5c64e-3097">ldloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3097">ldloc.s `index`</span></span>|<span data-ttu-id="5c64e-3098">Charge la variable locale à l’index `index` dans la pile, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3098">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-3099">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3100">La valeur de variable locale à l’index spécifié est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3100">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3101">La `ldloc.s` instruction exécute un push le contenu de la variable locale à l’index passé dans la pile d’évaluation, où les variables locales sont numérotées à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3101">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="5c64e-3102">Variables locales sont initialisées à 0 avant d’entrer la méthode si l’indicateur d’initialisation sur la méthode a la valeur true.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3102">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="5c64e-3103">Il existe 256 (2 ^ 8) variables locales possibles (0-255) sous la forme abrégée, qui est un encodage plus efficace que `ldloc`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3103">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="5c64e-3104">Le type de la valeur est le même que le type de la variable locale, qui est spécifiée dans l’en-tête de méthode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3104">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="5c64e-3105">Consultez Partition I. Local variables qui sont inférieures à 4 octets sont étendus au type `int32` lorsqu’elles sont chargées dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3105">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="5c64e-3106">Valeurs à virgule flottante sont étendues à leur taille native (type `F`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="5c64e-3107">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `ldloc.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3108">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3108">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="5c64e-3109">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3109">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3110">Charge l'adresse de la variable locale à un index spécifique dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3110">Loads the address of the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3111">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3112">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3112">Format</span></span>|<span data-ttu-id="5c64e-3113">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3113">Assembly Format</span></span>|<span data-ttu-id="5c64e-3114">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3115">FE OD &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3115">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="5c64e-3116">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3116">ldloca `index`</span></span>|<span data-ttu-id="5c64e-3117">Charge l’adresse de la variable locale à `index` dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3117">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3118">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3119">L’adresse stockée dans la variable locale à l’index spécifié est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3119">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3120">Le `ldloca` push de l’adresse de la variable locale à l’index passé dans la pile, où les variables locales sont numérotées à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3120">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="5c64e-3121">La valeur ajoutée à la pile est déjà correctement alignée pour une utilisation avec des instructions telles que <xref:System.Reflection.Emit.OpCodes.Ldind_I> et <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3121">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="5c64e-3122">Le résultat est un pointeur transitoire (type `*`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3122">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="5c64e-3123">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloca` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3123">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3124">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3124">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3125">Charge l'adresse de la variable locale à un index spécifique dans la pile d'évaluation (forme abrégée).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3125">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3126">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3126">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3127">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3127">Format</span></span>|<span data-ttu-id="5c64e-3128">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3128">Assembly Format</span></span>|<span data-ttu-id="5c64e-3129">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3129">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3130">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3130">12 < `unsigned int8` ></span></span>|<span data-ttu-id="5c64e-3131">ldloca.s `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3131">ldloca.s `index`</span></span>|<span data-ttu-id="5c64e-3132">Charge l’adresse de la variable locale à `index` dans la pile d’évaluation, la forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3132">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-3133">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3133">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3134">L’adresse stockée dans la variable locale à l’index spécifié est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3134">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3135">Le `ldloca.s` push de l’adresse de la variable locale à l’index passé dans la pile, où les variables locales sont numérotées à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3135">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="5c64e-3136">La valeur ajoutée à la pile est déjà correctement alignée pour une utilisation avec des instructions telles que <xref:System.Reflection.Emit.OpCodes.Ldind_I> et <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3136">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="5c64e-3137">Le résultat est un pointeur transitoire (type `*`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3137">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="5c64e-3138">La `ldloca.s` instruction fournit un codage efficace pour une utilisation avec les variables locales de 0 à 255.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3138">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="5c64e-3139">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldloca.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3139">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3140">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3140">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3141">Exécute un push d’une référence null (type <see langword="O" />) dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3141">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3142">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3142">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3143">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3143">Format</span></span>|<span data-ttu-id="5c64e-3144">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3144">Assembly Format</span></span>|<span data-ttu-id="5c64e-3145">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3145">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3146">14</span><span class="sxs-lookup"><span data-stu-id="5c64e-3146">14</span></span>|<span data-ttu-id="5c64e-3147">ldnull</span><span class="sxs-lookup"><span data-stu-id="5c64e-3147">ldnull</span></span>|<span data-ttu-id="5c64e-3148">transmettre une référence null dans la pile</span><span class="sxs-lookup"><span data-stu-id="5c64e-3148">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="5c64e-3149">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3149">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3150">Une référence d’objet null est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3150">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3151">`ldnull` exécute un push d’une référence null (type `O`) sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3151">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="5c64e-3152">Cela est utilisé pour initialiser les emplacements avant de les remplir avec des données, ou lorsqu’ils sont déconseillés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3152">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="5c64e-3153">`ldnull` Fournit une référence null est indépendante de la taille.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3153">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="5c64e-3154">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldnull` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3154">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3155">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3155">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3156">Copie l'objet de type de valeur sur lequel pointe une adresse en haut de la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3156">Copies the value type object pointed to by an address to the top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3157">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3157">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3158">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3158">Format</span></span>|<span data-ttu-id="5c64e-3159">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3159">Assembly Format</span></span>|<span data-ttu-id="5c64e-3160">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3160">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3161">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3161">71 < `T` ></span></span>|<span data-ttu-id="5c64e-3162">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3162">ldobj `class`</span></span>|<span data-ttu-id="5c64e-3163">Copie une instance du type de valeur `class` à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3163">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3164">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3164">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3165">L’adresse d’un objet de type valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3165">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3166">L’adresse est dépilée et l’instance à l’adresse spécifique est recherchée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3166">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="5c64e-3167">La valeur de l’objet stocké à cette adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3167">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3168">La `ldobj` instruction est utilisée pour passer un type valeur en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3168">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="5c64e-3169">Le `ldobj` instruction copie la valeur vers laquelle pointée `addrOfValObj` (de type `&`, `*`, ou `native int`) vers le haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3169">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="5c64e-3170">Le nombre d’octets copiés dépend de la taille de la classe (comme spécifié par le `class` paramètre).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3170">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="5c64e-3171">Le `class` paramètre est un jeton de métadonnées représentant le type de valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3171">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="5c64e-3172">L’opération de la `ldobj` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3172">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3173"><xref:System.TypeLoadException> est levée si la classe est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3173"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="5c64e-3174">Cela est généralement détectée lors de l’instruction de langage MSIL (Microsoft Intermediate Language) est convertie en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3174">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-3175">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldobj` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3176">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3176">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3177">Exécute un push de la valeur d’un champ static dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3177">Pushes the value of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3178">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3179">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3179">Format</span></span>|<span data-ttu-id="5c64e-3180">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3180">Assembly Format</span></span>|<span data-ttu-id="5c64e-3181">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3182">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3182">7E < `T` ></span></span>|<span data-ttu-id="5c64e-3183">ldsfld `field`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3183">ldsfld `field`</span></span>|<span data-ttu-id="5c64e-3184">Exécute un push de `field` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3184">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3185">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3186">La valeur du champ spécifique est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3186">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3187">La `ldsfld` instruction exécute un push de la valeur de statique (partagé entre toutes les instances d’une classe) champ sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3187">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="5c64e-3188">Le type de retour est celui associé au jeton de métadonnées passé `field`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3188">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="5c64e-3189">Le `ldsfld` instruction peut avoir un <xref:System.Reflection.Emit.OpCodes.Volatile> préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3189">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="5c64e-3190">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldsfld` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3190">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3191">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3191">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3192">Exécute un push de l’adresse d’un champ static dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3192">Pushes the address of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3193">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3193">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3194">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3194">Format</span></span>|<span data-ttu-id="5c64e-3195">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3195">Assembly Format</span></span>|<span data-ttu-id="5c64e-3196">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3196">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3197">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3197">7F < `T` ></span></span>|<span data-ttu-id="5c64e-3198">ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3198">ldsflda `field`</span></span>|<span data-ttu-id="5c64e-3199">Push de l’adresse de `field` sur la pile</span><span class="sxs-lookup"><span data-stu-id="5c64e-3199">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="5c64e-3200">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3200">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3201">L’adresse d’un champ spécifique est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3201">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3202">La `ldsflda` instruction exécute un push de l’adresse de statique (partagé entre toutes les instances d’une classe) champ sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3202">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="5c64e-3203">L’adresse peut être représenté comme un pointeur transitoire (type `*`) si le jeton de métadonnées `field` fait référence à un type dont la mémoire est gérée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3203">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="5c64e-3204">Sinon, elle correspond à un pointeur non managé (type `native int`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3204">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="5c64e-3205">Notez que `field` peut être de type statique global avec une adresse virtuelle relative assignée (l’offset du champ de l’adresse de base à laquelle le fichier PE conteneur est chargé en mémoire) où la mémoire n’est pas gérée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3205">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="5c64e-3206">Le `ldsflda` instruction peut avoir un <xref:System.Reflection.Emit.OpCodes.Volatile> préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3206">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="5c64e-3207"><xref:System.MissingFieldException> est levée si le champ est introuvable dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3207"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="5c64e-3208">Cette option est généralement activée lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, pas lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3208">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-3209">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldsflda` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3210">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3210">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3211">Exécute un push d'une nouvelle référence d'objet à un littéral de chaîne stocké dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3211">Pushes a new object reference to a string literal stored in the metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3212">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3213">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3213">Format</span></span>|<span data-ttu-id="5c64e-3214">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3214">Assembly Format</span></span>|<span data-ttu-id="5c64e-3215">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3216">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3216">72 < `T` ></span></span>|<span data-ttu-id="5c64e-3217">ldstr `mdToken`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3217">ldstr `mdToken`</span></span>|<span data-ttu-id="5c64e-3218">Exécute un push d’un objet de chaîne pour le jeton de chaîne de métadonnées `mdToken`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3218">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="5c64e-3219">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3220">Une référence d’objet en une chaîne est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3220">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3221">Le `ldstr` instruction exécute un push d’une référence d’objet (type `O`) vers un nouvel objet de chaîne qui représente le littéral de chaîne spécifique stocké dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3221">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="5c64e-3222">La `ldstr` instruction alloue la quantité de mémoire requise et exécute toute conversion de format nécessaire pour convertir le littéral de chaîne du format utilisé dans le fichier au format de chaîne requis lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3222">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-3223">Le Common Language Infrastructure (CLI) garantit que le résultat de deux `ldstr` instructions faisant référence à deux jetons de métadonnées ayant la même séquence de caractères retournent précisément le même objet chaîne (processus appelé « centralisation des chaînes »).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3223">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="5c64e-3224">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldstr` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3224">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3225">ILGenerator.Emit(OpCode, string)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3225">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3226">Convertit un jeton de métadonnées en sa représentation runtime et exécute un push de cette représentation dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3226">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3227">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3227">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3228">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3228">Format</span></span>|<span data-ttu-id="5c64e-3229">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3229">Assembly Format</span></span>|<span data-ttu-id="5c64e-3230">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3230">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3231">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3231">D0 < `T` ></span></span>|<span data-ttu-id="5c64e-3232">ldtoken `token`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3232">ldtoken `token`</span></span>|<span data-ttu-id="5c64e-3233">Convertit un jeton de métadonnées en sa représentation sous forme de runtime.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3233">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="5c64e-3234">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3234">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3235">Le jeton passé est converti en un `RuntimeHandle` et la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3235">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3236">Le `ldtoken` instruction push un `RuntimeHandle` pour le jeton de métadonnées spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3236">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="5c64e-3237">Un `RuntimeHandle` peut être un `fieldref/fielddef`, un `methodref/methoddef`, ou un `typeref/typedef`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3237">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="5c64e-3238">La valeur ajoutée à la pile peut être utilisée dans les appels à `Reflection` méthodes dans la bibliothèque de classes système.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3238">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="5c64e-3239">Pour plus d’informations sur les handles runtime, consultez les classes suivantes : <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, et <xref:System.RuntimeMethodHandle>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3239">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="5c64e-3240">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `ldtoken` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3241">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3241">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="5c64e-3242">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3242">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="5c64e-3243">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3243">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3244">Exécute un push d’un pointeur non managé (type <see langword="native int" />) pour le code natif implémentant une méthode virtuelle spécifique associée à un objet spécifié dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3244">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3245">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3245">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3246">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3246">Format</span></span>|<span data-ttu-id="5c64e-3247">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3247">Assembly Format</span></span>|<span data-ttu-id="5c64e-3248">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3248">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3249">FE 07 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3249">FE 07 < `T` ></span></span>|<span data-ttu-id="5c64e-3250">ldvirtftn `method`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3250">ldvirtftn `method`</span></span>|<span data-ttu-id="5c64e-3251">Exécute un push le pointeur à la méthode virtuelle d’un objet `method` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3251">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3252">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3252">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3253">Une référence d’objet est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3253">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3254">La référence d’objet est dépilée de la pile et l’adresse du point d’entrée à la méthode (comme spécifié par le jeton de métadonnées `method`) est recherché.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3254">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="5c64e-3255">Le pointeur vers `method` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3255">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3256">Le pointeur non managé qui en résulte est envoyée à la pile par le `ldvirtftn` instruction peut être appelée à l’aide de la <xref:System.Reflection.Emit.OpCodes.Calli> instruction si elle fait référence à une méthode managée (ou un stub qui effectue la transition à partir de code non managé).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3256">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="5c64e-3257">Le pointeur non managé pointe vers le code natif à l’aide de la convention d’appel de CLR.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3257">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="5c64e-3258">Ce pointeur de la méthode ne doit pas être passé au code natif non managé comme une routine de rappel.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3258">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="5c64e-3259">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ldvirtftn` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3259">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3260">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3260">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3261">Quitte une région de code protégée, en transférant le contrôle à une instruction cible spécifique de manière non conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3261">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3262">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3262">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3263">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3263">Format</span></span>|<span data-ttu-id="5c64e-3264">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3264">Assembly Format</span></span>|<span data-ttu-id="5c64e-3265">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3265">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3266">DD &LT; `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3266">DD < `int32` ></span></span>|<span data-ttu-id="5c64e-3267">Laissez le champ `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3267">leave `target`</span></span>|<span data-ttu-id="5c64e-3268">Quitte une région de code protégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3268">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="5c64e-3269">Il n’existe aucun comportement de transition de pile spécifié pour cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3269">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3270">La `leave` instruction transfère sans condition le contrôle à l’instruction cible spécifique, représentée par un offset signé de 4 octets à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3270">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3271">Le `leave` instruction est identique à la `br` instruction, mais il peut être utilisé pour quitter une `try`, `filter`, ou `catch` bloquer tandis que les instructions de branche ordinaire peuvent uniquement être utilisées dans ce type de bloc pour transférer le contrôle Il.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3271">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="5c64e-3272">Le `leave` instruction vide la pile d’évaluation et garantit que l’approprié qui entoure `finally` blocs sont exécutés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3272">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="5c64e-3273">Vous ne pouvez pas utiliser un `leave` instruction pour quitter un `finally` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3273">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="5c64e-3274">Pour faciliter la génération de code pour les gestionnaires d’exception qu’il est valide à partir d’un bloc catch à utiliser un `leave` instruction pour transférer le contrôle à une instruction dans associé `try` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3274">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="5c64e-3275">Si une instruction contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré vers le premier de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3275">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="5c64e-3276">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `leave` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3276">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3277">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3277">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3278">Quitte une région de code protégée, en transférant le contrôle à une instruction cible (forme abrégée) de manière non conditionnelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3278">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3279">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3279">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3280">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3280">Format</span></span>|<span data-ttu-id="5c64e-3281">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3281">Assembly Format</span></span>|<span data-ttu-id="5c64e-3282">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3282">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3283">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3283">DE < `int8` ></span></span>|<span data-ttu-id="5c64e-3284">leave.s `target`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3284">leave.s `target`</span></span>|<span data-ttu-id="5c64e-3285">Quitte une région protégée du code, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3285">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-3286">Il n’existe aucun comportement de transition de pile spécifié pour cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3286">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3287">La `leave.s` instruction transfère sans condition le contrôle à l’instruction cible passée, représentée par un offset signé de 1 octet à partir du début de l’instruction suivant l’instruction actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3287">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3288">Le `leave.s` instruction est identique à la `br` instruction, mais il peut être utilisé pour quitter une `try`, `filter`, ou `catch` bloquer tandis que les instructions de branche ordinaire peuvent uniquement être utilisées dans ce type de bloc pour transférer le contrôle Il.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3288">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="5c64e-3289">Le `leave.s` instruction vide la pile d’évaluation et garantit que l’approprié qui entoure `finally` blocs sont exécutés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3289">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="5c64e-3290">Vous ne pouvez pas utiliser un `leave.s` instruction pour quitter un `finally` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3290">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="5c64e-3291">Pour faciliter la génération de code pour les gestionnaires d’exception qu’il est valide à partir d’un bloc catch à utiliser un `leave.s` instruction pour transférer le contrôle à une instruction dans associé `try` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3291">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="5c64e-3292">Si une instruction contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré vers le premier de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3292">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="5c64e-3293">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `leave.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3294">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3294">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3295">Alloue un certain nombre d’octets à partir du pool de mémoires dynamique local et exécute un push de l’adresse (pointeur transitoire, type <see langword="*" />) du premier octet alloué dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3295">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3296">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3297">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3297">Format</span></span>|<span data-ttu-id="5c64e-3298">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3298">Assembly Format</span></span>|<span data-ttu-id="5c64e-3299">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3300">FE 0F</span><span class="sxs-lookup"><span data-stu-id="5c64e-3300">FE 0F</span></span>|<span data-ttu-id="5c64e-3301">localloc</span><span class="sxs-lookup"><span data-stu-id="5c64e-3301">localloc</span></span>|<span data-ttu-id="5c64e-3302">Allouer de l’espace à partir du tas local.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3302">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="5c64e-3303">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3304">Le nombre d’octets à allouer est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3304">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3305">Le nombre d’octets est retirée de la pile ; une quantité de mémoire correspondant à la taille est allouée à partir du tas local.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3305">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="5c64e-3306">Un pointeur vers le premier octet de la mémoire allouée est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3306">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3307">Le `localloc` alloue de l’instruction `size` (type `natural unsigned int`) octets à partir de la mémoire dynamique locale du pool et retourne l’adresse (pointeur transitoire, type `*`) du premier octet alloué.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3307">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="5c64e-3308">Le bloc de mémoire retourné est initialisé à 0 uniquement si l’indicateur d’initialisation sur la méthode est `true`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3308">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="5c64e-3309">Lorsque la méthode actuelle exécute un <xref:System.Reflection.Emit.OpCodes.Ret>, le pool de mémoire local devient disponible pour une réutilisation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3309">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="5c64e-3310">L’adresse obtenue est alignée afin que n’importe quel type de données primitif puisse y être stocké à l’aide de la `stind` instructions (comme <xref:System.Reflection.Emit.OpCodes.Stind_I4>) et chargé à l’aide la `ldind` instructions (comme <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3310">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="5c64e-3311">Le `localloc` instruction ne peut pas se produire dans un `filter`, `catch`, `finally`, ou `fault` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3311">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="5c64e-3312"><xref:System.StackOverflowException> est levée si la mémoire est insuffisante pour traiter la demande.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3312"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="5c64e-3313">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `localloc` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3313">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3314">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3314">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3315">Exécute un push d'une référence typée à une instance d'un type spécifique dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3315">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3316">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3316">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3317">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3317">Format</span></span>|<span data-ttu-id="5c64e-3318">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3318">Assembly Format</span></span>|<span data-ttu-id="5c64e-3319">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3319">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3320">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3320">C6 < `T` ></span></span>|<span data-ttu-id="5c64e-3321">mkrefany `class`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3321">mkrefany `class`</span></span>|<span data-ttu-id="5c64e-3322">Exécute un push d’une référence typée de type `class` dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3322">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3323">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3323">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3324">Un pointeur vers l’élément de données est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3324">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3325">Le pointeur est dépilé et converti en une référence typée de type `class`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3325">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="5c64e-3326">La référence typée est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3326">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3327">La `mkrefany` instruction prend en charge le passage de références typées dynamiquement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3327">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="5c64e-3328">Le pointeur doit être de type `&`, `*`, ou `native int`et contenir l’adresse valide d’un élément de données.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3328">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="5c64e-3329">`Class` est-ce que le jeton de classe décrivant le type des données référencées par le pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3329">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="5c64e-3330">`Mkrefany` exécute un push d’une référence typée dans la pile, en fournissant un descripteur opaque du pointeur et le type `class`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3330">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="5c64e-3331">L’opération valide uniquement autorisée sur une référence typée consiste à passer à une méthode qui requiert une référence typée en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3331">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="5c64e-3332">L’appelé peut ensuite utiliser le <xref:System.Reflection.Emit.OpCodes.Refanytype> et <xref:System.Reflection.Emit.OpCodes.Refanyval> des instructions pour récupérer respectivement le type (classe) et l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3332">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="5c64e-3333"><xref:System.TypeLoadException> est levée si `class` est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3333"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="5c64e-3334">Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3334">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-3335">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mkrefany` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3335">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3336">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3336">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3337">Multiplie deux valeurs et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3337">Multiplies two values and pushes the result on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3338">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3338">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3339">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3339">Format</span></span>|<span data-ttu-id="5c64e-3340">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3340">Assembly Format</span></span>|<span data-ttu-id="5c64e-3341">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3341">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3342">5A</span><span class="sxs-lookup"><span data-stu-id="5c64e-3342">5A</span></span>|<span data-ttu-id="5c64e-3343">mul</span><span class="sxs-lookup"><span data-stu-id="5c64e-3343">mul</span></span>|<span data-ttu-id="5c64e-3344">Multiplie deux valeurs sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3344">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3345">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3345">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3346">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3346">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3347">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3347">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3348">`value2` et `value1` sont dépilés de la pile ; `value1` est multipliée par `value2`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3348">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="5c64e-3349">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3349">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3350">Le `mul` instruction multiplie `value1` par `value2` et pousse le résultat sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3350">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="5c64e-3351">Opérations sur les entiers tronquent en silence les bits de poids fort de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3351">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="5c64e-3352">Consultez <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> pour un entier spécifique multiplier opération avec gestion de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3352">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="5c64e-3353">Pour les types à virgule flottante, 0 \* infini = NaN.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3353">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="5c64e-3354">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mul` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3354">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3355">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3355">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3356">Multiplie deux valeurs entières, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3356">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3357">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3357">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3358">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3358">Format</span></span>|<span data-ttu-id="5c64e-3359">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3359">Assembly Format</span></span>|<span data-ttu-id="5c64e-3360">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3360">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3361">D8</span><span class="sxs-lookup"><span data-stu-id="5c64e-3361">D8</span></span>|<span data-ttu-id="5c64e-3362">mul.ovf</span><span class="sxs-lookup"><span data-stu-id="5c64e-3362">mul.ovf</span></span>|<span data-ttu-id="5c64e-3363">Multiplie deux valeurs entières sur la pile avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3363">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="5c64e-3364">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3364">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3365">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3365">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3366">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3366">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3367">`value2` et `value1` sont dépilés de la pile ; `value1` est multipliée par `value2`, avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3367">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="5c64e-3368">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3368">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3369">Le `mul.ovf` instruction multiplie entier `value1` par entier `value2` et pousse le résultat sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3369">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="5c64e-3370">Une exception est levée si le résultat ne tient pas dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3370">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-3371"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3371"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-3372">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mul.ovf` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3373">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3373">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3374">Multiplie deux valeurs entières non signées, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3374">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3375">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3375">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3376">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3376">Format</span></span>|<span data-ttu-id="5c64e-3377">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3377">Assembly Format</span></span>|<span data-ttu-id="5c64e-3378">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3379">D9</span><span class="sxs-lookup"><span data-stu-id="5c64e-3379">D9</span></span>|<span data-ttu-id="5c64e-3380">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-3380">mul.ovf.un</span></span>|<span data-ttu-id="5c64e-3381">Multiplie deux valeurs non signées sur la pile avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3381">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="5c64e-3382">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3383">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3383">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3384">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3384">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3385">`value2` et `value1` sont dépilés de la pile ; `value1` est multipliée par `value2`, avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3385">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="5c64e-3386">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3386">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3387">Le `mul.ovf.un` instruction multiplie l’entier non signé `value1` en entier non signé `value2` et pousse le résultat sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3387">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="5c64e-3388">Une exception est levée si le résultat ne tient pas dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3388">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-3389"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3389"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-3390">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `mul.ovf.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3390">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3391">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3391">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3392">Met en négatif une valeur et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3392">Negates a value and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3393">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3393">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3394">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3394">Format</span></span>|<span data-ttu-id="5c64e-3395">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3395">Assembly Format</span></span>|<span data-ttu-id="5c64e-3396">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3396">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3397">65</span><span class="sxs-lookup"><span data-stu-id="5c64e-3397">65</span></span>|<span data-ttu-id="5c64e-3398">neg</span><span class="sxs-lookup"><span data-stu-id="5c64e-3398">neg</span></span>|<span data-ttu-id="5c64e-3399">Inverse la valeur actuellement située en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3399">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3400">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3400">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3401">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3401">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3402">Une valeur est dépilée et négatif.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3402">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="5c64e-3403">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3403">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3404">La `neg` instruction rend négative la valeur et exécute un push du résultat en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3404">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="5c64e-3405">Le type de retour est le même type que l’opérande.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3405">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="5c64e-3406">La négation de valeurs intégrales est standard du complément à deux négation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3406">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="5c64e-3407">En particulier, annulant ainsi le plus grand nombre négatif (qui n’a pas un équivalent positif) produit le plus grand nombre négatif.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3407">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="5c64e-3408">Pour détecter ce dépassement de capacité, utilisez la <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction à la place (autrement dit, la soustraction de 0).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3408">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="5c64e-3409">La négation d’un nombre à virgule flottante ne peut pas dépassement de capacité et la négation NaN retourne NaN.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3409">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="5c64e-3410">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `neg` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3411">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3412">Exécute un push dans la pile d'évaluation sur une référence d'objet à un nouveau tableau unidimensionnel de base zéro dont les éléments sont d'un type spécifique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3412">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3413">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3414">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3414">Format</span></span>|<span data-ttu-id="5c64e-3415">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3415">Assembly Format</span></span>|<span data-ttu-id="5c64e-3416">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3417">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3417">8D < `T` ></span></span>|<span data-ttu-id="5c64e-3418">newarr `etype`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3418">newarr `etype`</span></span>|<span data-ttu-id="5c64e-3419">Crée un nouveau tableau avec des éléments de type `etype`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3419">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="5c64e-3420">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3421">Le nombre d’éléments dans le tableau est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3421">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3422">Le nombre d’éléments est retirée de la pile et le tableau est créé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3422">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="5c64e-3423">Une référence d’objet au nouveau groupe est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3423">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3424">Le `newarr` instruction exécute un push d’une référence d’objet (type `O`) vers un nouveau tableau unidimensionnel de base zéro dont les éléments sont de type `etype` (un jeton de métadonnées décrivant le type).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3424">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="5c64e-3425">Le nombre d’éléments dans le nouveau tableau doit être spécifié comme un `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3425">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="5c64e-3426">Plage d’index de tableau valide compris entre zéro et le nombre maximal d’éléments moins 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3426">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="5c64e-3427">Les éléments d’un tableau peuvent être n’importe quel type, y compris les types de valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3427">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="5c64e-3428">Tableaux unidimensionnels de base zéro de nombres sont créés à l’aide d’un jeton de métadonnées référencent le type de valeur appropriée (<xref:System.Int32>, et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3428">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="5c64e-3429">Éléments du tableau sont initialisés à 0 du type approprié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3429">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="5c64e-3430">Tableaux unidimensionnels de base et les tableaux multidimensionnels sont créés à l’aide de <xref:System.Reflection.Emit.OpCodes.Newobj> plutôt que `newarr`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3430">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="5c64e-3431">En général, ils sont créés à l’aide des méthodes de la <xref:System.Array> classe dans le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3431">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="5c64e-3432"><xref:System.OutOfMemoryException> est levée si la mémoire est insuffisante pour satisfaire la requête.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3432"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="5c64e-3433"><xref:System.OverflowException> est levée si `numElems` est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3433"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="5c64e-3434">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `newarr` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3434">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3435">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3435">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3436">Crée un nouvel objet ou une nouvelle instance d’un type valeur, en exécutant un push d’une référence d’objet (type <see langword="O" />) dans la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3436">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3437">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3438">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3438">Format</span></span>|<span data-ttu-id="5c64e-3439">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3439">Assembly Format</span></span>|<span data-ttu-id="5c64e-3440">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3441">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3441">73 < `T` ></span></span>|<span data-ttu-id="5c64e-3442">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3442">newobj `ctor`</span></span>|<span data-ttu-id="5c64e-3443">Alloue un type valeur ou un objet non initialisé et appelle la méthode de constructeur `ctor`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3443">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="5c64e-3444">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3445">Arguments `arg1` via `argn` sont envoyées sur la pile dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3445">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="5c64e-3446">Arguments `argn` via `arg1` sont dépilés et passés à `ctor` pour la création d’objets.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3446">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="5c64e-3447">Une référence au nouvel objet est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3447">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3448">La `newobj` instruction crée un nouvel objet ou une nouvelle instance d’un type valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3448">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="5c64e-3449">`Ctor` est un jeton de métadonnées (un `methodref` ou `methoddef` qui doit être marquée en tant que constructeur) qui indique le nom, la classe et la signature du constructeur à appeler.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3449">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="5c64e-3450">Le `newobj` instruction alloue une nouvelle instance de la classe associée `ctor` et initialise tous les champs dans la nouvelle instance de la valeur 0 (du type approprié) ou les références null comme il convient.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3450">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="5c64e-3451">Il appelle ensuite le constructeur `ctor` avec les arguments donnés, ainsi que l’instance nouvellement créée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3451">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="5c64e-3452">Une fois que le constructeur a été appelé, le présent initialisée référence d’objet (type `O`) est ajoutée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3452">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3453">À partir du point de vue constructeur, l’objet non initialisé est l’argument 0 et les autres arguments passés à newobj suivent dans l’ordre.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3453">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="5c64e-3454">Tous les tableaux unidimensionnels de base zéro sont créés à l’aide de <xref:System.Reflection.Emit.OpCodes.Newarr>, et non `newobj`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3454">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="5c64e-3455">En revanche, tous les autres tableaux (multidimensionnels ou unidimensionnels mais pas de base zéro) sont créés à l’aide de `newobj`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3455">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="5c64e-3456">Les types valeur ne sont pas généralement créés à l’aide de `newobj`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3456">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="5c64e-3457">Ils sont généralement alloués en tant qu’arguments ou variables locales, à l’aide de `newarr` (pour les tableaux unidimensionnels de base zéro) ou en tant que champs d’objets.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3457">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="5c64e-3458">Une fois allouée, ils sont initialisés à l’aide de <xref:System.Reflection.Emit.OpCodes.Initobj>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3458">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="5c64e-3459">Toutefois, la `newobj` instruction peut être utilisée pour créer une nouvelle instance d’un type valeur dans la pile, ce qui peut ensuite être transmise en tant qu’argument, stocké dans une variable locale et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3459">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="5c64e-3460"><xref:System.OutOfMemoryException> est levée si la mémoire est insuffisante pour satisfaire la requête.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3460"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="5c64e-3461"><xref:System.MissingMethodException> est levée si une méthode de constructeur `ctor` portant le nom indiqué, classe et la signature est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3461"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="5c64e-3462">Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3462">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-3463">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `newobj` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3463">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3464">ILGenerator.Emit(OpCode, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3464">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3465">Remplit l’espace si les opcodes sont corrigés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3465">Fills space if opcodes are patched.</span></span> <span data-ttu-id="5c64e-3466">Aucune opération significative n'est exécutée bien qu'un cycle de traitement puisse être utilisé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3466">No meaningful operation is performed although a processing cycle can be consumed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3467">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3467">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3468">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3468">Format</span></span>|<span data-ttu-id="5c64e-3469">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3469">Assembly Format</span></span>|<span data-ttu-id="5c64e-3470">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3470">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3471">00</span><span class="sxs-lookup"><span data-stu-id="5c64e-3471">00</span></span>|<span data-ttu-id="5c64e-3472">nop</span><span class="sxs-lookup"><span data-stu-id="5c64e-3472">nop</span></span>|<span data-ttu-id="5c64e-3473">Effectue une opération sans comportement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3473">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="5c64e-3474">Il n’existe aucun comportement de transition de pile défini pour cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3474">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3475">Le `nop` opération ne fait rien.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3475">The `nop` operation does nothing.</span></span> <span data-ttu-id="5c64e-3476">Il est destiné à remplir l’espace si les opcodes sont corrigés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3476">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="5c64e-3477">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `nop` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3478">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3478">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3479">Calcule le complément de bits de la valeur entière située en haut de la pile et exécute un push du résultat dans la pile d'évaluation en tant que type identique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3479">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3480">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3481">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3481">Format</span></span>|<span data-ttu-id="5c64e-3482">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3482">Assembly Format</span></span>|<span data-ttu-id="5c64e-3483">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3484">66</span><span class="sxs-lookup"><span data-stu-id="5c64e-3484">66</span></span>|<span data-ttu-id="5c64e-3485">not</span><span class="sxs-lookup"><span data-stu-id="5c64e-3485">not</span></span>|<span data-ttu-id="5c64e-3486">Calcule le complément de bits d’une valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3486">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="5c64e-3487">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3488">`value` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3488">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3489">`value` est dépilée de la pile et sa au niveau du bit complément calculée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3489">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="5c64e-3490">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3490">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3491">La `not` instruction le complément de bits d’une valeur entière et exécute un push du résultat dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3491">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="5c64e-3492">Le type de retour est le même type que l’opérande.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3492">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="5c64e-3493">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `not` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3493">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3494">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3494">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3495">Calcule le complément de bits de deux valeurs entières situées en haut de la pile et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3495">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3496">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3496">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3497">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3497">Format</span></span>|<span data-ttu-id="5c64e-3498">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3498">Assembly Format</span></span>|<span data-ttu-id="5c64e-3499">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3499">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3500">60</span><span class="sxs-lookup"><span data-stu-id="5c64e-3500">60</span></span>|<span data-ttu-id="5c64e-3501">ou</span><span class="sxs-lookup"><span data-stu-id="5c64e-3501">or</span></span>|<span data-ttu-id="5c64e-3502">Calcule l’opérateur de bits ou de deux valeurs entières, retourne un entier.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3502">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="5c64e-3503">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3503">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3504">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3504">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3505">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3505">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3506">`value2` et `value1` sont dépilés à partir de la pile et leur opération de bits OR calculée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3506">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="5c64e-3507">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3507">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3508">La `or` instruction calcule l’opération OR au niveau du bit des deux premières valeurs de la pile, en exécutant un push du résultat dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3508">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3509">`Or` est une opération spécifique aux entiers.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3509">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="5c64e-3510">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `or` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3510">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3511">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3511">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3512">Supprime la valeur actuellement située en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3512">Removes the value currently on top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3513">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3513">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3514">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3514">Format</span></span>|<span data-ttu-id="5c64e-3515">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3515">Assembly Format</span></span>|<span data-ttu-id="5c64e-3516">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3516">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3517">26</span><span class="sxs-lookup"><span data-stu-id="5c64e-3517">26</span></span>|<span data-ttu-id="5c64e-3518">pop</span><span class="sxs-lookup"><span data-stu-id="5c64e-3518">pop</span></span>|<span data-ttu-id="5c64e-3519">Dépile la valeur de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3519">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3520">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3520">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3521">La valeur supérieure est retirée de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3521">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3522">La `pop` instruction supprime l’élément supérieur de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3522">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3523">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `pop` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3523">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3524">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3524">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3525">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3525">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3526">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3526">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3527">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3527">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3528">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3528">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3529">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3529">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3530">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3530">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3531">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3531">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3532">Cette instruction est réservée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3532">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3533">Spécifie que l'opération d'adresse de tableau suivante n'exécute aucun contrôle de type au moment de l'exécution et qu'il retourne un pointeur managé dont la mutabilité est restreinte.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3533">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3534">Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3534">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3535">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3535">Format</span></span>|<span data-ttu-id="5c64e-3536">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3536">Assembly Format</span></span>|<span data-ttu-id="5c64e-3537">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3537">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3538">FE 1E</span><span class="sxs-lookup"><span data-stu-id="5c64e-3538">FE 1E</span></span>|<span data-ttu-id="5c64e-3539">en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3539">readonly.</span></span>|<span data-ttu-id="5c64e-3540">Spécifier que l’opération d’adresse de tableau suivante n’exécute aucun contrôle de type au moment de l’exécution, et qu’il retourne un pointeur managé avec la mutabilité est restreinte.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3540">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="5c64e-3541">Ce préfixe ne peut apparaître qu’immédiatement précédent le `ldelema` instruction et les appels à spéciale `Address` (méthode) sur les tableaux.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3541">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="5c64e-3542">Son effet sur l’opération suivante est double :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3542">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="5c64e-3543">Au moment de l’exécution, aucune opération de vérification de type n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3543">At run time, no type check operation is performed.</span></span> <span data-ttu-id="5c64e-3544">Notez qu’il existe normalement une vérification de type implicite pour les `ldelema` et `stelem` instructions lorsqu’il est utilisé sur la référence des tableaux de types.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3544">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="5c64e-3545">Il n’est jamais une vérification de type au moment de l’exécution pour les classes de valeur, par conséquent, `readonly` est une absence d’opération dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3545">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="5c64e-3546">Le vérificateur traite le résultat de l’opération d’adresse comme un pointeur managé avec la mutabilité est restreinte.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3546">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="5c64e-3547">Le pointeur est dite mutabilité est restreinte, car le type de définition contrôle si la valeur peut être MUTÉE.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3547">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="5c64e-3548">Pour les classes de valeur qui n’exposent aucun champ public ou les méthodes qui mettent à jour la valeur en place, le pointeur est en lecture seule (par conséquent, le nom du préfixe).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3548">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="5c64e-3549">En particulier, les classes qui représentent des types primitifs (par exemple, System.Int32) n’exposent pas les mutateurs et sont donc en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3549">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="5c64e-3550">Un pointeur managé restreint de cette manière peut être utilisé uniquement dans des manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3550">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="5c64e-3551">Comme le `object` paramètre pour le `ldfld`, `ldflda`, `stfld`, `call`, ou`constrained callvirt` obtenir des instructions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3551">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="5c64e-3552">Comme le `pointer` paramètre à la `ldobj` instruction ou à un de la `ldind` obtenir des instructions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3552">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="5c64e-3553">Comme le `source` paramètre à la `cpobj` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3553">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3554">Toutes les autres opérations interdites, notamment le `stobj`, `initobj`, ou `mkrefany` operations ou l’un de la `stind` obtenir des instructions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3554">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="5c64e-3555">L’objectif de la `readonly` préfixe est d’éviter une vérification de type lors de l’extraction d’un élément à partir d’un tableau dans le code générique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3555">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="5c64e-3556">Par exemple, l’expression `arr[i].m()`, où le type d’élément du tableau `arr` est un type générique qui a été contraint à posséder une interface avec la méthode `m`, peut compiler dans le code MSIL suivant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3556">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="5c64e-3557">Sans le `readonly` préfixe, la `ldelema` instruction effectue une vérification de type dans le cas où ! 0 a un type référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3557">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="5c64e-3558">Non seulement cette vérification de type inefficace, mais il est sémantiquement incorrect.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3558">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="5c64e-3559">La vérification des types pour `ldelema` est une correspondance exacte qui est trop forte.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3559">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="5c64e-3560">Si le tableau contenait des sous-classes de type ! 0, le code ci-dessus échoue la vérification de type.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3560">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="5c64e-3561">L’adresse de l’élément de tableau est extraite, au lieu de l’élément lui-même, afin de disposer d’un handle pour `arr[i]` que fonctionne pour les deux types valeur et types référence et peut donc être passé à la `constrained callvirt` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3561">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3562">En général, il serait risqué d’ignorer la vérification de l’exécution si le tableau contient des éléments d’un type référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3562">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="5c64e-3563">Pour plus de sécurité, il est nécessaire pour s’assurer qu’aucune modification du tableau n’est effectuées via ce pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3563">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="5c64e-3564">Les règles de vérificateur Vérifiez cela.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3564">The verifier rules ensure this.</span></span> <span data-ttu-id="5c64e-3565">Le pointeur managé restreint peut être passé en tant que l’objet d’appels de méthode d’instance, par conséquent, il n’est pas à proprement parler en lecture seule pour les types valeur, mais aucun problème de sécurité de type pour les types valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3565">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="5c64e-3566">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `readonly` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3566">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3567">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3567">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3568">Récupère le jeton de type incorporé dans une référence typée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3568">Retrieves the type token embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3569">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3569">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3570">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3570">Format</span></span>|<span data-ttu-id="5c64e-3571">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3571">Assembly Format</span></span>|<span data-ttu-id="5c64e-3572">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3572">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3573">FE 1D</span><span class="sxs-lookup"><span data-stu-id="5c64e-3573">FE 1D</span></span>|<span data-ttu-id="5c64e-3574">refanytype</span><span class="sxs-lookup"><span data-stu-id="5c64e-3574">refanytype</span></span>|<span data-ttu-id="5c64e-3575">Exécute un push du jeton de type stocké dans une référence typée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3575">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="5c64e-3576">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3576">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3577">Une référence de type valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3577">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3578">La référence typée est dépilée et le type de jeton correspondant est récupéré.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3578">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="5c64e-3579">Le jeton du type est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3579">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3580">Une référence typée contient un jeton de type et une adresse à une instance d’objet.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3580">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="5c64e-3581">La `refanytype` instruction récupère le jeton de type incorporé dans la référence typée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3581">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="5c64e-3582">Consultez le <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction pour plus d’informations sur la création de références typées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3582">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="5c64e-3583">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `refanytype` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3583">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3584">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3584">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3585">Récupère l’adresse (type <see langword="&amp;" />) incorporé dans une référence typée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3585">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3586">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3586">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3587">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3587">Format</span></span>|<span data-ttu-id="5c64e-3588">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3588">Assembly Format</span></span>|<span data-ttu-id="5c64e-3589">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3589">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3590">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3590">C2 < `T` ></span></span>|<span data-ttu-id="5c64e-3591">refanyval `type`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3591">refanyval `type`</span></span>|<span data-ttu-id="5c64e-3592">Exécute un push de l’adresse stockée dans une référence typée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3592">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="5c64e-3593">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3593">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3594">Une référence de type valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3594">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3595">La référence typée est dépilée et l’adresse correspondante est récupérée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3595">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="5c64e-3596">L’adresse est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3596">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3597">Une référence typée contient un jeton de type et une adresse à une instance d’objet.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3597">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="5c64e-3598">La `refanyval` instruction récupère l’adresse incorporée dans la référence typée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3598">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="5c64e-3599">Le type incorporé dans la référence typée fournie dans la pile doit correspondre au type spécifié par `type` (jeton de métadonnées, soit un `typedef` ou `typeref`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3599">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="5c64e-3600">Consultez le <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction concernant le contenu.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3600">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="5c64e-3601"><xref:System.InvalidCastException> est levée si `type` n’est pas identique au type stocké dans la référence de type (dans ce cas, `type` est la classe fournie à la <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction construit ladite référence typée).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3601"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="5c64e-3602"><xref:System.TypeLoadException> est levée si `type` est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3602"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="5c64e-3603">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `refanyval` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3603">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3604">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3604">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3605">Divise une valeur par une autre et exécute un push du reste dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3605">Divides two values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3606">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3606">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3607">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3607">Format</span></span>|<span data-ttu-id="5c64e-3608">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3608">Assembly Format</span></span>|<span data-ttu-id="5c64e-3609">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3609">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3610">5D</span><span class="sxs-lookup"><span data-stu-id="5c64e-3610">5D</span></span>|<span data-ttu-id="5c64e-3611">REM</span><span class="sxs-lookup"><span data-stu-id="5c64e-3611">rem</span></span>|<span data-ttu-id="5c64e-3612">Exécute un push du reste de la division `value1` par `value2` dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3612">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="5c64e-3613">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3613">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3614">Un `value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3614">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3615">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3615">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3616">`value2` et `value1` sont dépilés à partir de la pile et le reste de `value1` `div` `value2` calculée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3616">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="5c64e-3617">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3617">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3618">`result` = `value1` `rem` `value2` satisfait les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3618">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="5c64e-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), et :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="5c64e-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, signe (`result`) = connexion (`value1`), où `div` est l’instruction de division qui tronque vers zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="5c64e-3621">Si `value2` est égal à zéro ou `value1` est infini, le résultat est NaN.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3621">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="5c64e-3622">Si `value2` est l’infini, le résultat est `value1` (exclue pour `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3622">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="5c64e-3623">Opérations intégrales lever <xref:System.DivideByZeroException> si `value2` est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3623">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="5c64e-3624">Notez que sur les plateformes Intel un <xref:System.OverflowException> est levée lors du calcul (minint `rem` -1).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3624">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="5c64e-3625">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `rem` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3627">Divise une valeur non signée par une autre et exécute un push du reste dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3627">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3628">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3629">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3629">Format</span></span>|<span data-ttu-id="5c64e-3630">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3630">Assembly Format</span></span>|<span data-ttu-id="5c64e-3631">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3632">5E</span><span class="sxs-lookup"><span data-stu-id="5c64e-3632">5E</span></span>|<span data-ttu-id="5c64e-3633">rem.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-3633">rem.un</span></span>|<span data-ttu-id="5c64e-3634">Exécute un push du reste de la division non signé `value1` par non signé `value2` dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3634">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3635">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3636">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3636">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3637">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3637">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3638">`value2` et `value1` sont dépilés à partir de la pile et le reste de `value1` `div` `value2` calculée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3638">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="5c64e-3639">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3639">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3640">`result` = `value1` `rem.un` `value2` satisfait les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3640">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="5c64e-3641">`result` = `value1` - `value2` x (`value1` `div.un` `value2`), et :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3641">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="5c64e-3642">0 = `result`  <  `value2`, où `div.un` est l’instruction de division non signée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3642">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3643">Le `rem.un` instruction calcule `result` et qu’il exécute un push sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3643">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="5c64e-3644">`Rem.un` traite ses arguments comme des entiers non signés, tandis que <xref:System.Reflection.Emit.OpCodes.Rem> les traite comme des entiers signés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3644">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="5c64e-3645">`Rem.un` n’est pas spécifié pour les nombres à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3645">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="5c64e-3646">Opérations intégrales lever <xref:System.DivideByZeroException> si `value2` est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3646">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="5c64e-3647">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `rem.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3647">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3648">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3648">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3649">Effectue un retour à partir de la méthode actuelle en exécutant un push d'une valeur de retour (si elle existe) à partir de la pile d'évaluation de l'appelé dans celle de l'appelant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3649">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3650">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3650">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3651">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3651">Format</span></span>|<span data-ttu-id="5c64e-3652">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3652">Assembly Format</span></span>|<span data-ttu-id="5c64e-3653">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3653">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3654">2A</span><span class="sxs-lookup"><span data-stu-id="5c64e-3654">2A</span></span>|<span data-ttu-id="5c64e-3655">RET</span><span class="sxs-lookup"><span data-stu-id="5c64e-3655">ret</span></span>|<span data-ttu-id="5c64e-3656">Renvoie, à partir de la méthode, éventuellement retournant une valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3656">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="5c64e-3657">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3657">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3658">La valeur de retour est dépilée de la pile d’évaluation appelé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3658">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3659">La valeur de retour obtenue à l’étape 1 est placée sur la pile d’évaluation de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3659">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="5c64e-3660">Si la valeur de retour n’est pas présente sur la pile d’évaluation appelé, aucune valeur n’est retournée (aucun comportement de transition de pile pour la méthode appelant ou appelé).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3660">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="5c64e-3661">Le type de la valeur de retour, le cas échéant, de la méthode actuelle détermine le type de valeur à extraire à partir du haut de la pile et à copier dans la pile de la méthode qui a appelé la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3661">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="5c64e-3662">La pile d’évaluation de la méthode actuelle doit être vide sauf pour la valeur à retourner.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3662">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="5c64e-3663">Le `ret` ne peut pas être utilisée pour transférer le contrôle d’un`try`, `filter`, `catch`, ou `finally` bloc.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3663">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="5c64e-3664">Depuis un `try` ou `catch`, utiliser le <xref:System.Reflection.Emit.OpCodes.Leave> instruction avec une destination d’un `ret` instruction située en dehors d’englobant tous les blocs d’exception.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3664">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="5c64e-3665">Étant donné que le `filter` et `finally` blocs font logiquement partie de la gestion des exceptions et pas la méthode dans laquelle leur code est incorporé, les instructions de langage MSIL (Microsoft Intermediate Language) générées correctement n’effectuent pas un retour à partir de la méthode un `filter` ou `finally`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3665">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="5c64e-3666">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `ret` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3666">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3667">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3667">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3668">Lève de nouveau l'exception actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3668">Rethrows the current exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3669">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3669">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3670">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3670">Format</span></span>|<span data-ttu-id="5c64e-3671">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3671">Assembly Format</span></span>|<span data-ttu-id="5c64e-3672">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3672">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3673">FE 1A</span><span class="sxs-lookup"><span data-stu-id="5c64e-3673">FE 1A</span></span>|<span data-ttu-id="5c64e-3674">rethrow</span><span class="sxs-lookup"><span data-stu-id="5c64e-3674">rethrow</span></span>|<span data-ttu-id="5c64e-3675">Lève à nouveau l’exception actuelle</span><span class="sxs-lookup"><span data-stu-id="5c64e-3675">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="5c64e-3676">Aucun comportement de transition de pile n’est défini pour cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3676">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3677">Le `rethrow` instruction n’est autorisée dans le corps d’un `catch` gestionnaire.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3677">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="5c64e-3678">Elle lève la même exception qui a été interceptée par ce gestionnaire.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3678">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="5c64e-3679">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `rethrow` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3679">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3680">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3680">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3681">Déplace une valeur entière vers la gauche (décalage des zéros) d'un nombre de bits spécifié, en exécutant un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3681">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3682">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3682">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3683">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3683">Format</span></span>|<span data-ttu-id="5c64e-3684">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3684">Assembly Format</span></span>|<span data-ttu-id="5c64e-3685">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3685">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3686">62</span><span class="sxs-lookup"><span data-stu-id="5c64e-3686">62</span></span>|<span data-ttu-id="5c64e-3687">shl</span><span class="sxs-lookup"><span data-stu-id="5c64e-3687">shl</span></span>|<span data-ttu-id="5c64e-3688">Déplace un entier vers la gauche (décalage des zéros).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3688">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="5c64e-3689">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3689">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3690">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3690">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3691">La quantité de bits à décaler est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3691">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3692">Le nombre de bits à décaler et la valeur sont dépilés de la pile ; la valeur est déplacée vers la gauche du nombre spécifié de bits.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3692">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="5c64e-3693">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3693">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3694">Le `shl` instruction décale la valeur (type `int32`, `int64` ou `native int`) gauche du nombre spécifié de bits.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3694">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="5c64e-3695">Le nombre de bits est une valeur de type `int32` ou `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3695">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="5c64e-3696">La valeur de retour n’est pas spécifiée si le nombre de bits de décalage est supérieur ou égal à la largeur (en bits) de la valeur fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3696">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="5c64e-3697">`Shl` Insère un bit zéro dans la position la plus basse sur chaque décalage.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3697">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="5c64e-3698">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `shl` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3700">Déplace une valeur entière (dans le signe) vers la droite d'un nombre de bits spécifié, en exécutant un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3700">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3701">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3702">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3702">Format</span></span>|<span data-ttu-id="5c64e-3703">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3703">Assembly Format</span></span>|<span data-ttu-id="5c64e-3704">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3705">63</span><span class="sxs-lookup"><span data-stu-id="5c64e-3705">63</span></span>|<span data-ttu-id="5c64e-3706">shr</span><span class="sxs-lookup"><span data-stu-id="5c64e-3706">shr</span></span>|<span data-ttu-id="5c64e-3707">Déplace un entier vers la droite (décalage des connexion).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3707">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="5c64e-3708">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3709">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3709">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3710">La quantité de bits à décaler est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3710">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3711">Le nombre de bits à décaler et la valeur sont dépilés de la pile ; la valeur est décalée vers la droite du nombre de bits spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3711">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="5c64e-3712">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3712">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3713">Le `shr.un` instruction décale la valeur (type `int32`, `int64` ou `native int`) directement par le nombre de bits spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3713">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="5c64e-3714">Le nombre de bits est une valeur de type `int32` ou `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3714">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="5c64e-3715">La valeur de retour n’est pas spécifiée si le nombre de bits de décalage est supérieur ou égal à la largeur (en bits) de la valeur fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3715">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="5c64e-3716">`Shr` réplique l’ordre élevé bit sur chaque décalage, en conservant le signe de la valeur d’origine dans le `result`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3716">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="5c64e-3717">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `shr` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3717">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3718">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3718">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3719">Déplace une valeur entière non signée (décalage des zéros) vers la droite d'un nombre de bits spécifié, en exécutant un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3719">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3720">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3720">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3721">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3721">Format</span></span>|<span data-ttu-id="5c64e-3722">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3722">Assembly Format</span></span>|<span data-ttu-id="5c64e-3723">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3723">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3724">64</span><span class="sxs-lookup"><span data-stu-id="5c64e-3724">64</span></span>|<span data-ttu-id="5c64e-3725">shr.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-3725">shr.un</span></span>|<span data-ttu-id="5c64e-3726">Déplace un entier vers la droite (décalage des zéros).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3726">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="5c64e-3727">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3727">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3728">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3728">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3729">La quantité de bits à décaler est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3729">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3730">Le nombre de bits à décaler et la valeur sont dépilés de la pile ; la valeur est décalée vers la droite du nombre de bits spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3730">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="5c64e-3731">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3731">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3732">Le `shr.un` instruction décale la valeur (type `int32`, `int64` ou `native int`) directement par le nombre de bits spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3732">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="5c64e-3733">Le nombre de bits est une valeur de type `int32`, `int64` ou `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3733">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="5c64e-3734">La valeur de retour n’est pas spécifiée si le nombre de bits de décalage est supérieur ou égal à la largeur (en bits) de la valeur fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3734">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="5c64e-3735">`Shr.un` Insère un bit zéro dans la position la plus élevée sur chaque décalage.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3735">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="5c64e-3736">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `shr.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3736">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3737">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3737">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3738">Exécute un push de la taille (en octets) d'un type de valeur fourni dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3738">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3739">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3739">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3740">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3740">Format</span></span>|<span data-ttu-id="5c64e-3741">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3741">Assembly Format</span></span>|<span data-ttu-id="5c64e-3742">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3742">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3743">FE 1C < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3743">FE 1C < `T` ></span></span>|<span data-ttu-id="5c64e-3744">sizeof `valType`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3744">sizeof `valType`</span></span>|<span data-ttu-id="5c64e-3745">Push de la taille, en octets, d’un type valeur comme un `unsigned int32`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3745">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="5c64e-3746">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3746">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3747">La taille (en octets) du type de valeur fourni (`valType`) est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3747">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3748">`valType` doit être un jeton de métadonnées (un `typeref` ou `typedef`) qui spécifie un type valeur, un type référence ou un paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3748">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="5c64e-3749">Pour un type référence, la taille retournée est la taille d’une valeur de référence correspondante tapez (4 octets sur les systèmes 32 bits), pas la taille des données stockées dans les objets référencés par la valeur de référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3749">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="5c64e-3750">Un paramètre de type générique peut être utilisé uniquement dans le corps du type ou de méthode qui le définit.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3750">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="5c64e-3751">Lorsque ce type ou cette méthode est instancié, le paramètre de type générique est remplacé par un type valeur ou un type référence.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3751">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="5c64e-3752">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sizeof` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3752">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3753">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3753">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3754">Stocke la valeur en haut de la pile d’évaluation à l’emplacement d’argument situé à un index spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3754">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3755">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3755">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3756">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3756">Format</span></span>|<span data-ttu-id="5c64e-3757">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3757">Assembly Format</span></span>|<span data-ttu-id="5c64e-3758">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3758">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3759">FE 0B < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3759">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="5c64e-3760">starg `num`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3760">starg `num`</span></span>|<span data-ttu-id="5c64e-3761">Dépile la valeur de la pile et la stocke dans l’emplacement d’argument `num`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3761">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="5c64e-3762">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3762">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3763">La valeur actuellement située en haut de la pile est dépilée et placée dans l’emplacement d’argument `num`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3763">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="5c64e-3764">Le `starg` instruction Dépile une valeur de la pile et la place dans l’emplacement d’argument `num`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3764">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="5c64e-3765">Le type de la valeur doit correspondre au type de l’argument, comme spécifié dans la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3765">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-3766">Pour connaître les procédures qui acceptent une liste d’arguments variable, la `starg` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3766">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="5c64e-3767">Stocker dans les arguments qui contiennent une valeur entière inférieure à 4 octets tronque la valeur lorsqu’il passe à partir de la pile à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3767">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="5c64e-3768">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3768">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-3769">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `starg` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3770">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3770">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3771">Stocke la valeur en haut de la pile d’évaluation à l’emplacement d’argument situé à un index spécifié (forme abrégée).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3771">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3772">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3773">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3773">Format</span></span>|<span data-ttu-id="5c64e-3774">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3774">Assembly Format</span></span>|<span data-ttu-id="5c64e-3775">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3776">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3776">10 < `unsigned int8` ></span></span>|<span data-ttu-id="5c64e-3777">starg.s `num`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3777">starg.s `num`</span></span>|<span data-ttu-id="5c64e-3778">Dépile la valeur de la pile et la stocke dans l’emplacement de l’argument `num`, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3778">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-3779">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3780">La valeur actuellement située en haut de la pile est dépilée et placée dans l’emplacement d’argument `num`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3780">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="5c64e-3781">Le `starg.s` instruction Dépile une valeur de la pile et la place dans l’emplacement d’argument `num`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3781">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="5c64e-3782">Le type de la valeur doit correspondre au type de l’argument, comme spécifié dans la signature de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3782">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="5c64e-3783">La `starg.s` instruction fournit un codage efficace pour une utilisation avec les 256 premiers arguments.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3783">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="5c64e-3784">Pour connaître les procédures qui acceptent une liste d’arguments variable, la `starg.s` instruction peut être utilisée uniquement lors du premier fixé d’arguments, pas celles dans la partie variable de la signature.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3784">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="5c64e-3785">Stocker dans les arguments qui contiennent une valeur entière inférieure à 4 octets tronque la valeur lorsqu’il passe à partir de la pile à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3785">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="5c64e-3786">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3786">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-3787">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `starg.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3787">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3788">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3788">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3789">Remplace l'élément de tableau à un index donné par la valeur de la pile d'évaluation dont le type est spécifié dans l'instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3789">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3790">Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3790">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3791">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3791">Format</span></span>|<span data-ttu-id="5c64e-3792">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3792">Assembly Format</span></span>|<span data-ttu-id="5c64e-3793">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3793">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3794">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3794">A4 < `T` ></span></span>|<span data-ttu-id="5c64e-3795">stelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3795">stelem `typeTok`</span></span>|<span data-ttu-id="5c64e-3796">Remplace l’élément de tableau à l’index fourni par une valeur de type `typeTok` sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3796">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3797">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3797">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3798">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3798">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3799">Une valeur d’index, `index`, à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3799">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3800">Une valeur du type spécifié dans l’instruction est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3800">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3801">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3801">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3802">Le `stelem` instruction remplace la valeur de l’élément à l’index de base zéro fourni dans le tableau unidimensionnel `array` avec la valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3802">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="5c64e-3803">La valeur a le type spécifié par le jeton `typeTok` dans l’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3803">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="5c64e-3804">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3804">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3805">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3805">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3806"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3806"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3807"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3807"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3808"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3808"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3809">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3809">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3810">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3810">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3811">Remplace l’élément de tableau à un index donné par la <see langword="native int" /> valeur sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3811">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3812">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3812">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3813">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3813">Format</span></span>|<span data-ttu-id="5c64e-3814">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3814">Assembly Format</span></span>|<span data-ttu-id="5c64e-3815">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3815">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3816">9B</span><span class="sxs-lookup"><span data-stu-id="5c64e-3816">9B</span></span>|<span data-ttu-id="5c64e-3817">stelem.i</span><span class="sxs-lookup"><span data-stu-id="5c64e-3817">stelem.i</span></span>|<span data-ttu-id="5c64e-3818">Remplace un élément de tableau à l’index fourni avec le `native int` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3818">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3819">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3819">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3820">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3820">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3821">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3821">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3822">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3822">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3823">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3823">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3824">Le `stelem.i` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `native int` valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3824">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3825">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3825">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3826">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3826">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3827"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3827"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3828"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3828"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3829"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3829"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3830">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3830">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3831">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3831">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3832">Remplace l’élément de tableau à un index donné par la <see langword="int8" /> valeur sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3832">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3833">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3833">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3834">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3834">Format</span></span>|<span data-ttu-id="5c64e-3835">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3835">Assembly Format</span></span>|<span data-ttu-id="5c64e-3836">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3836">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3837">9C</span><span class="sxs-lookup"><span data-stu-id="5c64e-3837">9C</span></span>|<span data-ttu-id="5c64e-3838">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="5c64e-3838">stelem.i1</span></span>|<span data-ttu-id="5c64e-3839">Remplace un élément de tableau à l’index fourni avec le `int8` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3839">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3840">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3840">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3841">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3841">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3842">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3842">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3843">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3843">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3844">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3844">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3845">Le `stelem.i1` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int8` valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3845">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3846">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3846">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3847">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3847">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3848"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3848"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3849"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3849"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3850"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3850"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3851">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3851">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3852">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3852">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3853">Remplace l’élément de tableau à un index donné par la <see langword="int16" /> valeur sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3853">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3854">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3855">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3855">Format</span></span>|<span data-ttu-id="5c64e-3856">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3856">Assembly Format</span></span>|<span data-ttu-id="5c64e-3857">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3858">9D</span><span class="sxs-lookup"><span data-stu-id="5c64e-3858">9D</span></span>|<span data-ttu-id="5c64e-3859">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="5c64e-3859">stelem.i2</span></span>|<span data-ttu-id="5c64e-3860">Remplace un élément de tableau à l’index fourni avec le `int16` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3860">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3861">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3862">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3862">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3863">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3863">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3864">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3864">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3865">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3865">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3866">Le `stelem.i2` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int16` valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3866">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3867">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3867">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3868">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3868">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3869"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3869"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3870"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3870"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3871"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3871"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3872">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3872">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3873">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3873">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3874">Remplace l’élément de tableau à un index donné par la <see langword="int32" /> valeur sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3874">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3875">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3875">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3876">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3876">Format</span></span>|<span data-ttu-id="5c64e-3877">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3877">Assembly Format</span></span>|<span data-ttu-id="5c64e-3878">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3878">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3879">9E</span><span class="sxs-lookup"><span data-stu-id="5c64e-3879">9E</span></span>|<span data-ttu-id="5c64e-3880">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="5c64e-3880">stelem.i4</span></span>|<span data-ttu-id="5c64e-3881">Remplace un élément de tableau à l’index fourni avec le `int32` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3881">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3882">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3882">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3883">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3883">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3884">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3884">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3885">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3885">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3886">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3886">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3887">Le `stelem.i4` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int32` valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3887">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3888">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3888">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3889">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3889">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3890"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3890"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3891"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3891"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3892"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3892"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3893">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3893">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3894">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3894">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3895">Remplace l’élément de tableau à un index donné par la <see langword="int64" /> valeur sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3895">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3896">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3896">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3897">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3897">Format</span></span>|<span data-ttu-id="5c64e-3898">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3898">Assembly Format</span></span>|<span data-ttu-id="5c64e-3899">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3899">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3900">9F</span><span class="sxs-lookup"><span data-stu-id="5c64e-3900">9F</span></span>|<span data-ttu-id="5c64e-3901">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="5c64e-3901">stelem.i8</span></span>|<span data-ttu-id="5c64e-3902">Remplace un élément de tableau à l’index fourni avec le `int64` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3902">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3903">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3903">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3904">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3904">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3905">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3905">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3906">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3906">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3907">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3907">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3908">Le `stelem.i8` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `int64` valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3908">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3909">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3909">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3910">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3910">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3911"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3911"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3912"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3912"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3913"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3913"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3914">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.i8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3915">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3916">Remplace l’élément de tableau à un index donné par la <see langword="float32" /> valeur sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3916">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3917">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3918">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3918">Format</span></span>|<span data-ttu-id="5c64e-3919">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3919">Assembly Format</span></span>|<span data-ttu-id="5c64e-3920">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3921">A0</span><span class="sxs-lookup"><span data-stu-id="5c64e-3921">A0</span></span>|<span data-ttu-id="5c64e-3922">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="5c64e-3922">stelem.r4</span></span>|<span data-ttu-id="5c64e-3923">Remplace un élément de tableau à l’index fourni avec le `float32` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3923">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3924">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3925">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3925">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3926">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3926">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3927">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3927">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3928">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3928">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3929">Le `stelem.r4` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `float32` valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3929">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3930">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3930">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3931">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3931">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3932"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3932"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3933"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3933"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3934"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3934"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3935">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.r4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3935">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3936">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3936">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3937">Remplace l’élément de tableau à un index donné par la <see langword="float64" /> valeur sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3937">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3938">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3938">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3939">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3939">Format</span></span>|<span data-ttu-id="5c64e-3940">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3940">Assembly Format</span></span>|<span data-ttu-id="5c64e-3941">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3941">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3942">A1</span><span class="sxs-lookup"><span data-stu-id="5c64e-3942">A1</span></span>|<span data-ttu-id="5c64e-3943">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="5c64e-3943">stelem.r8</span></span>|<span data-ttu-id="5c64e-3944">Remplace un élément de tableau à l’index fourni avec le `float64` valeur sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3944">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3945">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3945">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3946">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3946">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3947">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3947">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3948">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3948">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3949">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3949">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3950">Le `stelem.r8` instruction remplace la valeur de l’élément `index` dans le tableau unidimensionnel `array` avec la `float64` valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3950">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3951">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3951">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3952">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3952">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3953"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3953"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3954"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3954"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3955"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3955"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3956">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.r8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3956">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3957">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3957">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3958">Remplace l’élément de tableau à un index donné par la valeur de référence d’objet (type <see langword="O" />) sur la pile d’évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3958">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3959">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3959">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3960">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3960">Format</span></span>|<span data-ttu-id="5c64e-3961">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3961">Assembly Format</span></span>|<span data-ttu-id="5c64e-3962">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3962">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3963">A2</span><span class="sxs-lookup"><span data-stu-id="5c64e-3963">A2</span></span>|<span data-ttu-id="5c64e-3964">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="5c64e-3964">stelem.ref</span></span>|<span data-ttu-id="5c64e-3965">Remplace un élément de tableau à l’index fourni avec le `ref` valeur (type `O`) sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3965">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="5c64e-3966">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3966">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3967">Une référence d’objet dans un tableau, `array`, est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3967">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3968">Un index valide à un élément dans `array` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3968">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3969">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3969">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="5c64e-3970">La valeur, l’index et la référence de tableau sont dépilés de la pile ; la valeur est placée dans l’élément de tableau à l’index donné.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3970">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="5c64e-3971">Le `stelem.ref` instruction remplace la valeur de l’élément à l’index fourni dans le tableau unidimensionnel `array` avec la `ref` (type `O`) valeur envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3971">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-3972">Les tableaux sont des objets et sont donc représentés par une valeur de type `O`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3972">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="5c64e-3973">L’index est de type `native int`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3973">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="5c64e-3974">Notez que `stelem.ref` convertit implicitement la valeur fournie pour le type d’élément de `array` avant d’affecter la valeur à l’élément de tableau.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3974">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="5c64e-3975">Cette conversion peut échouer, même pour le code vérifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3975">This cast can fail, even for verified code.</span></span> <span data-ttu-id="5c64e-3976">Par conséquent, le `stelem.ref` instruction peut lever <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3976">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="5c64e-3977">Pour les tableaux unidimensionnels qui ne sont pas de base zéro et pour les tableaux multidimensionnels, le <xref:System.Array> classe fournit un <xref:System.Array.SetValue%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="5c64e-3977">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="5c64e-3978"><xref:System.NullReferenceException> est levée si `array` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3978"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-3979"><xref:System.IndexOutOfRangeException> est levée si `index` est négatif ou supérieur à la limite de `array`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3979"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="5c64e-3980"><xref:System.ArrayTypeMismatchException> est levée si `array` ne contient pas d’éléments du type requis.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3980"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="5c64e-3981">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stelem.ref` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-3982">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-3982">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-3983">Remplace la valeur stockée dans le champ d'une référence d'objet ou d'un pointeur par une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3983">Replaces the value stored in the field of an object reference or pointer with a new value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-3984">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-3985">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-3985">Format</span></span>|<span data-ttu-id="5c64e-3986">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-3986">Assembly Format</span></span>|<span data-ttu-id="5c64e-3987">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-3987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-3988">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-3988">7D < `T` ></span></span>|<span data-ttu-id="5c64e-3989">stfld `field`</span><span class="sxs-lookup"><span data-stu-id="5c64e-3989">stfld `field`</span></span>|<span data-ttu-id="5c64e-3990">Remplace la valeur de `field` de l’objet avec une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3990">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="5c64e-3991">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-3991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-3992">Une référence d’objet ou le pointeur est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3992">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-3993">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3993">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-3994">La valeur et la référence d’objet/pointeur sont dépilés de la pile ; la valeur de `field` dans l’objet est remplacé par la valeur fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3994">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="5c64e-3995">Le `stfld` instruction remplace la valeur d’un champ d’un objet (type `O`) ou via un pointeur (type `native int`, `&`, ou `*`) avec une valeur donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3995">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="5c64e-3996">`Field` est un jeton de métadonnées qui fait référence à une référence de membre de champ.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3996">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="5c64e-3997">Le `stfld` instruction peut avoir un préfixe d’une des deux <xref:System.Reflection.Emit.OpCodes.Unaligned> et <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3997">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="5c64e-3998"><xref:System.NullReferenceException> est levée si la référence d’objet ou le pointeur est une référence null et que le champ n’est pas statique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3998"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="5c64e-3999"><xref:System.MissingFieldException> est levée si `field` est introuvable dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-3999"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="5c64e-4000">Cette option est généralement activée quand l’instruction de langage MSIL (Microsoft Intermediate Language) est convertie en code natif, pas lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4000">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-4001">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stfld` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4002">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4002">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4003">Stocke une valeur de type <see langword="native int" /> à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4003">Stores a value of type <see langword="native int" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4004">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4005">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4005">Format</span></span>|<span data-ttu-id="5c64e-4006">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4006">Assembly Format</span></span>|<span data-ttu-id="5c64e-4007">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4008">DF</span><span class="sxs-lookup"><span data-stu-id="5c64e-4008">DF</span></span>|<span data-ttu-id="5c64e-4009">stind.i</span><span class="sxs-lookup"><span data-stu-id="5c64e-4009">stind.i</span></span>|<span data-ttu-id="5c64e-4010">Stocke un `native int` valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4010">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4011">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4011">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4012">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4012">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4013">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4013">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4014">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4014">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4015">Le `stind.i` instruction stocke un `native int` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4015">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4016">Opération de type sécurisé requiert que le `stind.i` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4016">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4017">L’opération de la `stind.i` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4017">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4018"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4018"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4019">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4019">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4020">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4020">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4021">Stocke une valeur de type <see langword="int8" /> à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4021">Stores a value of type <see langword="int8" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4022">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4022">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4023">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4023">Format</span></span>|<span data-ttu-id="5c64e-4024">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4024">Assembly Format</span></span>|<span data-ttu-id="5c64e-4025">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4025">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4026">52</span><span class="sxs-lookup"><span data-stu-id="5c64e-4026">52</span></span>|<span data-ttu-id="5c64e-4027">stind.i1</span><span class="sxs-lookup"><span data-stu-id="5c64e-4027">stind.i1</span></span>|<span data-ttu-id="5c64e-4028">Stocke un `int8` valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4028">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4029">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4029">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4030">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4030">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4031">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4031">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4032">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4032">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4033">Le `stind.i1` instruction stocke un `int8` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4033">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4034">Opération de type sécurisé requiert que le `stind.i1` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4034">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4035">L’opération de la `stind.i1` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4035">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4036"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4036"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4037">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4039">Stocke une valeur de type <see langword="int16" /> à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4039">Stores a value of type <see langword="int16" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4040">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4040">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4041">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4041">Format</span></span>|<span data-ttu-id="5c64e-4042">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4042">Assembly Format</span></span>|<span data-ttu-id="5c64e-4043">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4044">53</span><span class="sxs-lookup"><span data-stu-id="5c64e-4044">53</span></span>|<span data-ttu-id="5c64e-4045">stind.i2</span><span class="sxs-lookup"><span data-stu-id="5c64e-4045">stind.i2</span></span>|<span data-ttu-id="5c64e-4046">Stocke un `int16` valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4046">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4047">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4047">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4048">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4048">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4049">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4049">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4050">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4050">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4051">Le `stind.i2` instruction stocke un `int16` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4051">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4052">Opération de type sécurisé requiert que le `stind.2i` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4052">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4053">L’opération de la `stind.i2` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4053">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4054"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4054"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4055">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4055">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4056">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4056">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4057">Stocke une valeur de type <see langword="int32" /> à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4057">Stores a value of type <see langword="int32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4058">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4058">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4059">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4059">Format</span></span>|<span data-ttu-id="5c64e-4060">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4060">Assembly Format</span></span>|<span data-ttu-id="5c64e-4061">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4061">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4062">54</span><span class="sxs-lookup"><span data-stu-id="5c64e-4062">54</span></span>|<span data-ttu-id="5c64e-4063">stind.i4</span><span class="sxs-lookup"><span data-stu-id="5c64e-4063">stind.i4</span></span>|<span data-ttu-id="5c64e-4064">Stocke un `int32` valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4064">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4065">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4065">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4066">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4066">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4067">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4067">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4068">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4068">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4069">Le `stind.i4` instruction stocke un `int32` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4069">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4070">Opération de type sécurisé requiert que le `stind.i4` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4070">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4071">L’opération de la `stind.i4` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4071">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4072"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4072"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4073">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4074">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4075">Stocke une valeur de type <see langword="int64" /> à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4075">Stores a value of type <see langword="int64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4076">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4077">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4077">Format</span></span>|<span data-ttu-id="5c64e-4078">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4078">Assembly Format</span></span>|<span data-ttu-id="5c64e-4079">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4080">55</span><span class="sxs-lookup"><span data-stu-id="5c64e-4080">55</span></span>|<span data-ttu-id="5c64e-4081">stind.i8</span><span class="sxs-lookup"><span data-stu-id="5c64e-4081">stind.i8</span></span>|<span data-ttu-id="5c64e-4082">Stocke un `int64` valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4082">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4083">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4084">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4084">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4085">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4085">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4086">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4086">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4087">Le `stind.i8` instruction stocke un `int64` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4087">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4088">Opération de type sécurisé requiert que le `stind.i8` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4088">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4089">L’opération de la `stind.i` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4089">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4090"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4090"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4091">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.i8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4091">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4092">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4092">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4093">Stocke une valeur de type <see langword="float32" /> à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4093">Stores a value of type <see langword="float32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4094">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4094">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4095">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4095">Format</span></span>|<span data-ttu-id="5c64e-4096">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4096">Assembly Format</span></span>|<span data-ttu-id="5c64e-4097">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4097">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4098">56</span><span class="sxs-lookup"><span data-stu-id="5c64e-4098">56</span></span>|<span data-ttu-id="5c64e-4099">stind.r4</span><span class="sxs-lookup"><span data-stu-id="5c64e-4099">stind.r4</span></span>|<span data-ttu-id="5c64e-4100">Stocke un `float32` valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4100">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4101">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4101">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4102">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4102">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4103">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4103">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4104">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4104">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4105">Le `stind.r4` instruction stocke un `float32` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4105">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4106">Opération de type sécurisé requiert que le `stind.r4` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4106">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4107">L’opération de la `stind.r4` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4107">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4108"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4108"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4109">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.r4` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4109">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4110">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4110">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4111">Stocke une valeur de type <see langword="float64" /> à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4111">Stores a value of type <see langword="float64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4112">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4112">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4113">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4113">Format</span></span>|<span data-ttu-id="5c64e-4114">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4114">Assembly Format</span></span>|<span data-ttu-id="5c64e-4115">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4115">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4116">57</span><span class="sxs-lookup"><span data-stu-id="5c64e-4116">57</span></span>|<span data-ttu-id="5c64e-4117">stind.r8</span><span class="sxs-lookup"><span data-stu-id="5c64e-4117">stind.r8</span></span>|<span data-ttu-id="5c64e-4118">Stocke un `float64` valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4118">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4119">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4119">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4120">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4120">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4121">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4121">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4122">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4122">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4123">Le `stind.r8` instruction stocke un `float64` valeur à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4123">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4124">Opération de type sécurisé requiert que le `stind.r8` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4124">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4125">L’opération de la `stind.r8` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4125">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4126"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4126"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4127">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.r8` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4128">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4128">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4129">Stocke une valeur de référence d'objet à une adresse fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4129">Stores a object reference value at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4130">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4131">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4131">Format</span></span>|<span data-ttu-id="5c64e-4132">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4132">Assembly Format</span></span>|<span data-ttu-id="5c64e-4133">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4134">51</span><span class="sxs-lookup"><span data-stu-id="5c64e-4134">51</span></span>|<span data-ttu-id="5c64e-4135">stind.ref</span><span class="sxs-lookup"><span data-stu-id="5c64e-4135">stind.ref</span></span>|<span data-ttu-id="5c64e-4136">Stocke une référence d’objet (type `O`) valeur à une adresse donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4136">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="5c64e-4137">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4138">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4138">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4139">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4139">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4140">La valeur et l’adresse sont dépilés de la pile ; la valeur est stockée à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4140">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4141">Le `stind.ref` instruction stocke une valeur de référence d’objet à l’adresse fournie (type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4141">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="5c64e-4142">Opération de type sécurisé requiert que le `stind.ref` instruction soit utilisée de manière cohérente avec le type du pointeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4142">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="5c64e-4143">L’opération de la `stind.ref` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4143">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4144"><xref:System.NullReferenceException> est levée si `addr` n’est pas aligné naturellement pour le type d’argument impliqué par le suffixe d’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4144"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="5c64e-4145">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stind.ref` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4145">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4146">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4146">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4147">Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à un index spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4147">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4148">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4148">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4149">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4149">Format</span></span>|<span data-ttu-id="5c64e-4150">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4150">Assembly Format</span></span>|<span data-ttu-id="5c64e-4151">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4151">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4152">FE 0E < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4152">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="5c64e-4153">stloc `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-4153">stloc `index`</span></span>|<span data-ttu-id="5c64e-4154">Dépile une valeur de la pile et la stocke dans la variable locale `index`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4154">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="5c64e-4155">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4155">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4156">Une valeur est dépilée et placée dans la variable locale `index`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4156">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="5c64e-4157">Le `stloc` instruction dépile la valeur la pile d’évaluation et la déplace dans le numéro de variable locale `index`, où les variables locales sont numérotées à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4157">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="5c64e-4158">Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4158">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="5c64e-4159">Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4159">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="5c64e-4160">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4160">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-4161">Les instructions de langage MSIL (Microsoft Intermediate Language) correctes requièrent que `index` soit un index local valid.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4161">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="5c64e-4162">Pour le `stloc` instruction, `index` doit être compris entre 0 et 65534 inclus (spécifiquement, 65535 n’est pas valide).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4162">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="5c64e-4163">La raison de l’exclusion de 65535 est pragmatique : susceptibles d’implémentations utilisent un entier de 2 octets pour effectuer le suivi d’un index de variable locale, ainsi que le nombre total de variables locales pour une méthode donnée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4163">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="5c64e-4164">Si un index 65 535 avait été rendu valide, un entier plus large pour suivre le nombre de variables locales dans une telle méthode serait nécessaire.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4164">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="5c64e-4165">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `stloc` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4165">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="5c64e-4167">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4167">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4168">Dépile la valeur actuelle du haut de la pile d'évaluation et la stocke dans la liste de variables locales à l'index 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4168">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4169">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4169">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4170">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4170">Format</span></span>|<span data-ttu-id="5c64e-4171">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4171">Assembly Format</span></span>|<span data-ttu-id="5c64e-4172">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4172">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4173">0A</span><span class="sxs-lookup"><span data-stu-id="5c64e-4173">0A</span></span>|<span data-ttu-id="5c64e-4174">stloc.0</span><span class="sxs-lookup"><span data-stu-id="5c64e-4174">stloc.0</span></span>|<span data-ttu-id="5c64e-4175">Dépile une valeur de la pile dans la variable locale 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4175">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="5c64e-4176">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4176">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4177">Une valeur est dépilée et placée dans la variable locale indexée par 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4177">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="5c64e-4178">La `stloc.0` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4178">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="5c64e-4179">Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4179">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="5c64e-4180">`stloc.0` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4180">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="5c64e-4181">Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4181">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="5c64e-4182">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4182">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-4183">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.0` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4183">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4184">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4184">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4185">Dépile la valeur actuelle du haut de la pile d’évaluation et la stocke dans la liste de variables locales à l’index 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4185">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4186">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4186">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4187">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4187">Format</span></span>|<span data-ttu-id="5c64e-4188">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4188">Assembly Format</span></span>|<span data-ttu-id="5c64e-4189">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4189">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4190">0B</span><span class="sxs-lookup"><span data-stu-id="5c64e-4190">0B</span></span>|<span data-ttu-id="5c64e-4191">stloc.1</span><span class="sxs-lookup"><span data-stu-id="5c64e-4191">stloc.1</span></span>|<span data-ttu-id="5c64e-4192">Dépile une valeur de la pile dans la variable locale 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4192">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="5c64e-4193">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4193">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4194">Une valeur est dépilée et placée dans la variable locale indexée par 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4194">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="5c64e-4195">La `stloc.1` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4195">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="5c64e-4196">Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4196">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="5c64e-4197">`stloc.1` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 1.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4197">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="5c64e-4198">Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4198">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="5c64e-4199">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4199">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-4200">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.1` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4202">Dépile la valeur actuelle du haut de la pile d’évaluation et la stocke dans la liste de variables locales à l’index 2.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4202">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4203">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4204">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4204">Format</span></span>|<span data-ttu-id="5c64e-4205">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4205">Assembly Format</span></span>|<span data-ttu-id="5c64e-4206">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4207">0C</span><span class="sxs-lookup"><span data-stu-id="5c64e-4207">0C</span></span>|<span data-ttu-id="5c64e-4208">stloc.2</span><span class="sxs-lookup"><span data-stu-id="5c64e-4208">stloc.2</span></span>|<span data-ttu-id="5c64e-4209">Dépile une valeur de la pile dans la variable locale 2</span><span class="sxs-lookup"><span data-stu-id="5c64e-4209">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="5c64e-4210">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4211">Une valeur est dépilée et placée dans la variable locale indexée par 2.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4211">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="5c64e-4212">La `stloc.2` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 2.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4212">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="5c64e-4213">Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4213">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="5c64e-4214">`stloc.2` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 2.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4214">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="5c64e-4215">Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4215">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="5c64e-4216">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4216">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-4217">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.2` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4217">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4218">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4218">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4219">Dépile la valeur actuelle du haut de la pile d’évaluation et la stocke dans la liste de variables locales à l’index 3.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4219">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4220">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4220">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4221">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4221">Format</span></span>|<span data-ttu-id="5c64e-4222">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4222">Assembly Format</span></span>|<span data-ttu-id="5c64e-4223">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4223">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4224">0D</span><span class="sxs-lookup"><span data-stu-id="5c64e-4224">0D</span></span>|<span data-ttu-id="5c64e-4225">stloc.3</span><span class="sxs-lookup"><span data-stu-id="5c64e-4225">stloc.3</span></span>|<span data-ttu-id="5c64e-4226">Dépile une valeur de la pile dans la variable locale 3</span><span class="sxs-lookup"><span data-stu-id="5c64e-4226">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="5c64e-4227">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4227">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4228">Une valeur est dépilée et placée dans la variable locale indexée par 3.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4228">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="5c64e-4229">La `stloc.3` instruction dépile la valeur la pile d’évaluation et la déplace dans la variable locale indexée par 3.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4229">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="5c64e-4230">Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4230">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="5c64e-4231">`stloc.3` est un encodage particulièrement efficace pour stocker des valeurs dans la variable locale 3.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4231">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="5c64e-4232">Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4232">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="5c64e-4233">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4233">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-4234">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stloc.3` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4234">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4235">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4235">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4236">Dépile la valeur actuelle du haut de la pile d’évaluation et la stocke dans une liste de variables locales à <paramref name="index" /> (forme abrégée).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4236">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4237">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4237">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4238">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4238">Format</span></span>|<span data-ttu-id="5c64e-4239">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4239">Assembly Format</span></span>|<span data-ttu-id="5c64e-4240">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4240">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4241">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4241">13 < `unsigned int8` ></span></span>|<span data-ttu-id="5c64e-4242">stloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="5c64e-4242">stloc.s `index`</span></span>|<span data-ttu-id="5c64e-4243">Dépile une valeur de la pile et la stocke dans la variable locale `index`, forme abrégée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4243">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="5c64e-4244">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4244">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4245">Une valeur est dépilée et placée dans la variable locale `index`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4245">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="5c64e-4246">Le `stloc.s` instruction dépile la valeur la pile d’évaluation et la déplace dans le numéro de variable locale `index`, où les variables locales sont numérotées à partir de 0.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4246">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="5c64e-4247">Le type de la valeur doit correspondre au type de la variable locale, comme spécifié dans la signature locale de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4247">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="5c64e-4248">La `stloc.s` instruction fournit un codage efficace pour les variables locales de 0 à 255.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4248">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="5c64e-4249">Stocker dans les variables locales contenant une valeur entière inférieure à 4 octets tronque lorsqu’il passe à partir de la pile à la variable locale.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4249">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="5c64e-4250">Les valeurs à virgule flottante sont arrondies à partir de leur taille native (type `F`) à la taille associée à l’argument.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4250">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="5c64e-4251">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `stloc.s` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="5c64e-4253">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4253">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4254">Copie une valeur d'un type spécifié de la pile d'évaluation vers une adresse mémoire fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4254">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4255">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4255">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4256">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4256">Format</span></span>|<span data-ttu-id="5c64e-4257">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4257">Assembly Format</span></span>|<span data-ttu-id="5c64e-4258">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4258">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4259">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4259">81 < `T` ></span></span>|<span data-ttu-id="5c64e-4260">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="5c64e-4260">stobj `class`</span></span>|<span data-ttu-id="5c64e-4261">Stocke une valeur de type `class` à partir de la pile en mémoire.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4261">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="5c64e-4262">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4262">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4263">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4263">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4264">Un objet de type de valeur de type `class` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4264">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4265">L’objet et l’adresse sont dépilés de la pile ; l’objet de type valeur est stocké à l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4265">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="5c64e-4266">Le `stobj` instruction copie l’objet de type valeur vers l’adresse spécifiée par l’adresse (un pointeur de type `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4266">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="5c64e-4267">Le nombre d’octets copiés dépend de la taille de la classe représentée par `class`, un jeton de métadonnées représentant un type valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4267">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="5c64e-4268">L’opération de la `stobj` instruction peut être modifiée par une instruction <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instruction de préfixe.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4268">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4269"><xref:System.TypeLoadException> est levée si la classe est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4269"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="5c64e-4270">Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif plutôt qu’au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4270">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="5c64e-4271">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stobj` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4271">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4272">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4272">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4273">Remplace la valeur d'un champ statique par une valeur de la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4273">Replaces the value of a static field with a value from the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4274">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4274">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4275">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4275">Format</span></span>|<span data-ttu-id="5c64e-4276">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4276">Assembly Format</span></span>|<span data-ttu-id="5c64e-4277">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4277">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4278">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4278">80 < `T` ></span></span>|<span data-ttu-id="5c64e-4279">stsfld `field`</span><span class="sxs-lookup"><span data-stu-id="5c64e-4279">stsfld `field`</span></span>|<span data-ttu-id="5c64e-4280">Remplace la valeur dans `field` avec une valeur fournie.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4280">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="5c64e-4281">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4281">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4282">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4282">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4283">Une valeur est dépilée et stockée dans `field`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4283">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="5c64e-4284">La `stsfld` instruction remplace la valeur d’un champ statique avec une valeur de la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4284">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="5c64e-4285">`field` est un jeton de métadonnées qui doit faire référence à un membre de champ statique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4285">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="5c64e-4286">Le `stsfld` instruction peut-être être précédée <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4286">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="5c64e-4287"><xref:System.MissingFieldException> est levée si le champ est introuvable dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4287"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="5c64e-4288">Cette option est généralement activée lorsque des instructions de langage MSIL (Microsoft Intermediate Language) en code natif, pas en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4288">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="5c64e-4289">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `stsfld` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4289">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4290">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4290">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4291">Soustrait une valeur d'une autre et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4291">Subtracts one value from another and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4292">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4292">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4293">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4293">Format</span></span>|<span data-ttu-id="5c64e-4294">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4294">Assembly Format</span></span>|<span data-ttu-id="5c64e-4295">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4295">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4296">59</span><span class="sxs-lookup"><span data-stu-id="5c64e-4296">59</span></span>|<span data-ttu-id="5c64e-4297">sub</span><span class="sxs-lookup"><span data-stu-id="5c64e-4297">sub</span></span>|<span data-ttu-id="5c64e-4298">Soustrait une valeur d’un autre, en retournant une nouvelle valeur numérique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4298">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="5c64e-4299">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4299">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4300">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4300">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4301">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4301">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4302">`value2` et `value1` sont dépilés de la pile ; `value2` est soustraite de `value1`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4302">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="5c64e-4303">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4303">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4304">Dépassement de capacité n’est pas détecté pour les opérations sur les entiers (pour la gestion du dépassement de capacité, consultez <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4304">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="5c64e-4305">Soustraction de nombres entiers encapsule, au lieu de saturer.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4305">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="5c64e-4306">Par exemple : entiers 8 bits, où `value1` est définie sur 0 et `value2` est définie sur 1, le résultat « encapsulé » sera 255.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4306">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="5c64e-4307">Dépassement de capacité à virgule flottante retourne `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4307">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="5c64e-4308">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sub` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4308">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4309">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4309">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4310">Soustrait une valeur entière d'une autre, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4310">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4311">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4311">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4312">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4312">Format</span></span>|<span data-ttu-id="5c64e-4313">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4313">Assembly Format</span></span>|<span data-ttu-id="5c64e-4314">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4314">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4315">DA</span><span class="sxs-lookup"><span data-stu-id="5c64e-4315">DA</span></span>|<span data-ttu-id="5c64e-4316">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="5c64e-4316">sub.ovf</span></span>|<span data-ttu-id="5c64e-4317">Soustrait une valeur entière d’un autre avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4317">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="5c64e-4318">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4318">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4319">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4319">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4320">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4320">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4321">`value2` et `value1` sont dépilés de la pile ; `value2` est soustraite de `value1` avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4321">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="5c64e-4322">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4322">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4323"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4323"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-4324">Cette opération est effectuée sur les entiers signés ; pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4324">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="5c64e-4325">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sub.ovf` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4325">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4326">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4326">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4327">Soustrait une valeur entière non signée d'une autre, effectue un contrôle de dépassement de capacité et exécute un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4327">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4328">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4328">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4329">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4329">Format</span></span>|<span data-ttu-id="5c64e-4330">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4330">Assembly Format</span></span>|<span data-ttu-id="5c64e-4331">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4331">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4332">DB</span><span class="sxs-lookup"><span data-stu-id="5c64e-4332">DB</span></span>|<span data-ttu-id="5c64e-4333">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="5c64e-4333">sub.ovf.un</span></span>|<span data-ttu-id="5c64e-4334">Soustrait une valeur d’entier non signé à partir d’un autre avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4334">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="5c64e-4335">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4335">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4336">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4336">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4337">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4337">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4338">`value2` et `value1` sont dépilés de la pile ; `value2` est soustraite de `value1` avec une vérification de dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4338">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="5c64e-4339">Le résultat est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4339">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4340"><xref:System.OverflowException> est levée si le résultat ne peut pas être représenté dans le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4340"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="5c64e-4341">Cette opération est effectuée sur les entiers signés ; pour les valeurs à virgule flottante, utilisez <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4341">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="5c64e-4342">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `sub.ovf.un` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4342">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4343">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4343">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4344">Implémente un tableau de saut.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4344">Implements a jump table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4345">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4345">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4346">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4346">Format</span></span>|<span data-ttu-id="5c64e-4347">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4347">Assembly Format</span></span>|<span data-ttu-id="5c64e-4348">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4348">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="5c64e-4350">Basculer (`N`, `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4350">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="5c64e-4351">Accède à un des `N` valeurs.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4351">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="5c64e-4352">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4352">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4353">Une valeur est envoyée à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4353">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4354">La valeur est dépilée et l’exécution est transférée à l’instruction à l’offset indexé par la valeur, où la valeur est inférieure à `N`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4354">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="5c64e-4355">La `switch` instruction implémente un tableau de saut.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4355">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="5c64e-4356">Le format de l’instruction est une `unsigned int32` représentant le nombre de cibles `N`, suivi par `N` valeurs int32 qui spécifient les cibles de saut.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4356">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="5c64e-4357">Ces cibles sont représentées en tant qu’offsets (positifs ou négatifs) à partir du début de l’instruction suivant ce `switch` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4357">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4358">Le `switch` instruction Dépile une valeur de la pile et la compare, comme un entier non signé, à `N`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4358">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="5c64e-4359">Si la valeur est inférieure à `N`, l’exécution est transférée à la cible indexée par valeur, où les cibles sont numérotés de 0 (par exemple, une valeur de 0 est la première cible, une valeur de 1 est la deuxième cible et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4359">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="5c64e-4360">Si la valeur est supérieure ou égale à `N`, l’exécution se poursuit à l’instruction suivante (passage).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4360">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="5c64e-4361">Si l’instruction cible contient un ou plusieurs codes de préfixe, le contrôle peut uniquement être transféré à la première de ces préfixes.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4361">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="5c64e-4362">Le contrôle est transféré dans et hors du `try`, `catch`, `filter`, et `finally` blocs ne peut pas être effectuées par cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4362">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="5c64e-4363">(Ces transferts sont strictement limités et doivent plutôt utiliser l’instruction leave).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4363">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="5c64e-4364">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `switch` opcode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4364">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="5c64e-4365">Le `Label[]` argument est un tableau d’étiquettes représentant des offsets de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4365">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="5c64e-4366">ILGenerator.Emit(OpCode, Label[])</span><span class="sxs-lookup"><span data-stu-id="5c64e-4366">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c64e-4367">L’exemple de code suivant illustre l’utilisation de la `Switch` opcode pour générer un tableau de saut à l’aide d’un tableau de <xref:System.Reflection.Emit.Label>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4367">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4368">Exécute une instruction d'appel de méthode suffixée afin que le frame de pile de la méthode actuelle soit supprimé avant cette exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4368">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4369">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4370">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4370">Format</span></span>|<span data-ttu-id="5c64e-4371">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4371">Assembly Format</span></span>|<span data-ttu-id="5c64e-4372">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4373">FE 14</span><span class="sxs-lookup"><span data-stu-id="5c64e-4373">FE 14</span></span>|<span data-ttu-id="5c64e-4374">tail.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4374">tail.</span></span>|<span data-ttu-id="5c64e-4375">L’appel suivant met fin à des méthodes actuelles</span><span class="sxs-lookup"><span data-stu-id="5c64e-4375">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="5c64e-4376">Il n’existe aucun comportement de transition de pile défini pour cette instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4376">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="5c64e-4377">Le `tail` instruction de préfixe doit précéder immédiatement un <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, ou <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4377">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="5c64e-4378">Il indique que le frame de pile de la méthode actuelle doit être supprimé avant l’exécution de l’instruction d’appel.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4378">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="5c64e-4379">Il implique également que la valeur retournée par l’appel suivant est également la valeur retournée par la méthode actuelle, et l’appel peut donc être convertie en un saut croisé-method.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4379">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="5c64e-4380">La pile doit être vide sauf pour les arguments transférés par l’appel suivant.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4380">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="5c64e-4381">L’instruction qui suit l’instruction d’appel doit être un ret. Par conséquent, la séquence de code valide uniquement est `tail. call` (ou `calli` ou `callvirt`).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4381">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="5c64e-4382">Les instructions de langage MSIL (Microsoft Intermediate Language) correctes ne doivent pas créer de branche à la `call` instruction, mais ils peuvent créer une branche à le <xref:System.Reflection.Emit.OpCodes.Ret>.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4382">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="5c64e-4383">Le frame actuel ne peut pas être ignoré lorsque le contrôle est transféré à partir du code non approuvé à code de confiance, car cela compromettrait la sécurité d’identité du code.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4383">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="5c64e-4384">Vérifications de la sécurité de .NET Framework peuvent donc entraîner la `tail` doivent être ignorés, en laissant une norme <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4384">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="5c64e-4385">De même, dans l’ordre pour autoriser la sortie d’une région synchronisée après le retour de l’appel, le `tail` est ignoré lorsqu’il est utilisé pour quitter une méthode marquée comme synchronisée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4385">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="5c64e-4386">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `tail` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4386">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4387">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4387">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst"><span data-ttu-id="5c64e-4388">Une instance d’un objet Opcode.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4388">An instance of an Opcode object.</span></span></param>
        <summary><span data-ttu-id="5c64e-4389">Retourne true ou false si l’opcode fourni utilise un argument à octet unique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4389">Returns true or false if the supplied opcode takes a single byte argument.</span></span></summary>
        <returns><span data-ttu-id="5c64e-4390"><see langword="true" /> ou <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4390"><see langword="true" /> or <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4391">Cette méthode peut être utilisée pour rechercher les opcodes MSIL qui constituent « court », pour une utilisation dans le code optimisé.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4391">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="5c64e-4392">`TakesSingleByteArgument` Retourne `true` si le <xref:System.Reflection.Emit.OpCode> instance accepte un argument à octet unique dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4392">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="5c64e-4393">L’opcode exécute une instruction de branchement à une adresse en octets (par exemple, <xref:System.Reflection.Emit.OpCodes.Br_S> et <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4393">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="5c64e-4394">L’opcode exécute un push d’une valeur d’octet dans la pile (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4394">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="5c64e-4395">L’opcode fait référence à une variable ou un argument via la « forme abrégée » en octets (par exemple, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> et <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4395">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="5c64e-4396">Sinon, il retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4396">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="5c64e-4397">L’exemple ci-dessous illustre l’utilisation de `TakesSingleByteArgument` en réfléchissant le `OpCodes` classe et test pour voir si chaque `OpCode` champ prend un argument à octet unique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4397">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4398">Lève l'objet exception actuellement situé dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4398">Throws the exception object currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4399">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4399">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4400">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4400">Format</span></span>|<span data-ttu-id="5c64e-4401">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4401">Assembly Format</span></span>|<span data-ttu-id="5c64e-4402">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4402">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4403">7A</span><span class="sxs-lookup"><span data-stu-id="5c64e-4403">7A</span></span>|<span data-ttu-id="5c64e-4404">throw</span><span class="sxs-lookup"><span data-stu-id="5c64e-4404">throw</span></span>|<span data-ttu-id="5c64e-4405">Lève une exception.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4405">Throws an exception.</span></span>|  
  
 <span data-ttu-id="5c64e-4406">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4406">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4407">Une référence d’objet (une exception) est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4407">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4408">La référence d’objet est dépilée de la pile et l’exception levée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4408">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="5c64e-4409">Le `throw` instruction lève l’objet exception (type `O`) actuellement sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4409">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4410"><xref:System.NullReferenceException> est levé si la référence d’objet est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4410"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-4411">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `throw` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4411">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4412">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4412">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4413">Indique qu’une adresse actuellement située en haut de la pile d’évaluation peut ne pas être alignée avec la taille naturelle de la suite des <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, ou <see langword="cpblk" /> instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4413">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4414">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4414">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4415">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4415">Format</span></span>|<span data-ttu-id="5c64e-4416">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4416">Assembly Format</span></span>|<span data-ttu-id="5c64e-4417">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4417">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4418">FE 12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4418">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="5c64e-4419">non alignés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4419">unaligned.</span></span> `alignment`|<span data-ttu-id="5c64e-4420">Indique que l’instruction de pointeur suivantes peut-être ne pas être alignée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4420">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="5c64e-4421">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4421">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4422">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4422">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4423">`Unaligned` Spécifie que l’adresse (un pointeur non managé, `native int`) sur la pile peut ne pas être alignée avec la taille naturelle de la suite des `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4423">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="5c64e-4424">Autrement dit, pour un <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction l’alignement de l’adresse ne peut pas être à une limite de 4 octets.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4424">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="5c64e-4425">Pour `initblk` et `cpblk` l’alignement par défaut est dépend de l’architecture (4 octets sur les processeurs 32 bits, 8 octets sur les unités centrales 64 bits).</span><span class="sxs-lookup"><span data-stu-id="5c64e-4425">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="5c64e-4426">Les générateurs de code qui ne limitent pas leur sortie à une taille de mot de 32 bits doivent utiliser `unaligned` si l’alignement n’est pas connu au moment de la compilation à 8 octets.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4426">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="5c64e-4427">La valeur de l’alignement doit être 1, 2 ou 4 et signifie que le code généré doit supposer que l’adresse est l’octet, deux octets, ou à quatre octets, respectivement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4427">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="5c64e-4428">Notez que temporaire des pointeurs (type `*`) sont toujours alignés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4428">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="5c64e-4429">Tandis que l’alignement d’un `cpblk` instruction nécessite logiquement deux nombres (un pour la source) et l’autre pour la destination, il n’existe aucun impact significatif sur les performances si seul le nombre inférieur est spécifié.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4429">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="5c64e-4430">Le `unaligned` et `volatile` préfixes peuvent être combinées dans les deux sens.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4430">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="5c64e-4431">Ils doivent précéder immédiatement un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4431">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="5c64e-4432">Uniquement les <xref:System.Reflection.Emit.OpCodes.Volatile> est autorisé pour le <xref:System.Reflection.Emit.OpCodes.Ldsfld> et <xref:System.Reflection.Emit.OpCodes.Stsfld> obtenir des instructions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4432">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="5c64e-4433">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> les surcharges de méthode peuvent utiliser le `unaligned` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4434">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4434">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="5c64e-4435">ILGenerator.Emit(Opcode, Byte)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4435">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4436">Convertit la représentation boxed d'un type de valeur dans sa forme unboxed.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4436">Converts the boxed representation of a value type to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4437">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4438">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4438">Format</span></span>|<span data-ttu-id="5c64e-4439">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4439">Assembly Format</span></span>|<span data-ttu-id="5c64e-4440">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4441">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4441">79 < `T` ></span></span>|<span data-ttu-id="5c64e-4442">effectuer une conversion unboxing `valType`</span><span class="sxs-lookup"><span data-stu-id="5c64e-4442">unbox `valType`</span></span>|<span data-ttu-id="5c64e-4443">Extrait les données de type valeur à partir de `obj`, ses boxed de représentation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4443">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="5c64e-4444">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4445">Une référence d’objet est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4445">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4446">La référence d’objet est dépilée et unboxed en un pointeur de type valeur.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4446">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="5c64e-4447">Le pointeur de type valeur est envoyé à la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4447">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4448">Un type valeur a deux représentations distinctes au sein de l’Infrastructure (CLI) :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4448">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="5c64e-4449">Un formulaire « brut » utilisé lorsqu’un type valeur est incorporé dans un autre objet.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4449">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="5c64e-4450">Un formulaire « boxed », où les données dans le type de valeur sont encapsulées (boxed) dans un objet afin qu’il peut exister une entité indépendante.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4450">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="5c64e-4451">Le `unbox` instruction convertit la référence d’objet (type `O`), le boxed de représentation d’un type valeur, un pointeur de type valeur (un pointeur managé, type `&`), sa forme unboxed.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4451">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="5c64e-4452">Le type de valeur fourni (`valType`) est un jeton de métadonnées indiquant le type du type de valeur contenue dans l’objet converti.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4452">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="5c64e-4453">Contrairement aux <xref:System.Reflection.Emit.OpCodes.Box>, qui est nécessaire pour effectuer une copie d’un type de valeur pour une utilisation dans l’objet, `unbox` n’est pas nécessaire pour copier le type de valeur à partir de l’objet.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4453">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="5c64e-4454">En règle générale, il calcule simplement l’adresse du type valeur qui est déjà présent dans l’objet converti.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4454">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="5c64e-4455"><xref:System.InvalidCastException> est levée si l’objet n’est pas converti (boxed) en tant que `valType`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4455"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="5c64e-4456"><xref:System.NullReferenceException> est levé si la référence d’objet est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4456"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-4457"><xref:System.TypeLoadException> est levée si la valeur de type `valType` est introuvable.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4457"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="5c64e-4458">Cela est généralement détecté lorsque les instructions de langage MSIL (Microsoft Intermediate Language) sont converties en code natif, plutôt que lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4458">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="5c64e-4459">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `unbox` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4460">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4460">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4461">Convertit la représentation boxed d’un type spécifié dans l’instruction dans sa forme unboxed.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4461">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4462">Le tableau suivant répertorie les instructions format hexadécimal et Microsoft intermediate language (MSIL) assembly, ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4462">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4463">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4463">Format</span></span>|<span data-ttu-id="5c64e-4464">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4464">Assembly Format</span></span>|<span data-ttu-id="5c64e-4465">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4466">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="5c64e-4466">A5 < `T` ></span></span>|<span data-ttu-id="5c64e-4467">unbox.Any `typeTok`</span><span class="sxs-lookup"><span data-stu-id="5c64e-4467">unbox.any `typeTok`</span></span>|<span data-ttu-id="5c64e-4468">Extraire les données à partir de `obj`, ses boxed de représentation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4468">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="5c64e-4469">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4470">Une référence d’objet `obj` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4470">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4471">La référence d’objet est dépilée et unboxed au type spécifié dans l’instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4471">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="5c64e-4472">Le type de référence ou valeur d’objet qui en résulte est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4472">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4473">Lorsqu’il est appliqué à la forme boxed d’un type valeur, le `unbox.any` instruction extrait la valeur contenue dans `obj` (de type `O`) et n’est donc équivalent à `unbox` suivie `ldobj`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4473">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="5c64e-4474">Lorsqu’il est appliqué à un type référence, le `unbox.any` instruction a le même effet que `castclass` `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4474">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="5c64e-4475">Si l’opérande `typeTok` est un paramètre de type générique, puis le comportement d’exécution est déterminé par le type qui est spécifié pour ce paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4475">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="5c64e-4476"><xref:System.InvalidCastException> est levée si `obj` n’est pas un type boxed.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4476"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="5c64e-4477"><xref:System.NullReferenceException> est levée si `obj` est une référence null.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4477"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="5c64e-4478">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `unbox.any` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4478">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4479">ILGenerator.Emit (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4479">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4480">Spécifie qu'une adresse actuellement située en haut de la pile d'évaluation peut être volatile et que les résultats de la lecture de cet emplacement ne peuvent pas être mis en cache ou que plusieurs magasins situés à cet emplacement ne peuvent pas être supprimés.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4480">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4481">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4481">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4482">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4482">Format</span></span>|<span data-ttu-id="5c64e-4483">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4483">Assembly Format</span></span>|<span data-ttu-id="5c64e-4484">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4484">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4485">FE 13</span><span class="sxs-lookup"><span data-stu-id="5c64e-4485">FE 13</span></span>|<span data-ttu-id="5c64e-4486">volatile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4486">volatile.</span></span>|<span data-ttu-id="5c64e-4487">Indique que la référence de pointeur suivante est volatile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4487">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="5c64e-4488">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4488">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4489">Une adresse est placée sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4489">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4490">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4490">`volatile`.</span></span> <span data-ttu-id="5c64e-4491">Spécifie que l’adresse est une adresse volatile (en d’autrement dit, il peut être référencé d’en externe pour le thread en cours d’exécution) et les résultats de la lecture qu’emplacement ne peut pas être mis en cache ou que plusieurs magasins situés à cet emplacement ne peut pas être supprimées.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4491">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="5c64e-4492">Marquer un accès en tant que `volatile` n’affecte que cet accès unique ; d’autres accès au même emplacement doivent être marqués séparément.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4492">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="5c64e-4493">Accès aux emplacements volatiles ne doivent pas être effectuée atomiquement.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4493">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="5c64e-4494">Le <xref:System.Reflection.Emit.OpCodes.Unaligned> et `volatile` préfixes peuvent être combinées dans les deux sens.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4494">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="5c64e-4495">Ils doivent précéder immédiatement un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instruction.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4495">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="5c64e-4496">Uniquement les `volatile` est autorisé pour le <xref:System.Reflection.Emit.OpCodes.Ldsfld> et <xref:System.Reflection.Emit.OpCodes.Stsfld> obtenir des instructions.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4496">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="5c64e-4497">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `volatile` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4497">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4498">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4498">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c64e-4499">Calcule l'opération de bits XOR des deux premières valeurs de la pile d'évaluation en exécutant un push du résultat dans la pile d'évaluation.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4499">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c64e-4500">Le tableau suivant répertorie les instructions hexadécimal et format d’assembly de langage MSIL (Microsoft Intermediate Language), ainsi que d’un bref résumé de référence :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4500">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="5c64e-4501">Format</span><span class="sxs-lookup"><span data-stu-id="5c64e-4501">Format</span></span>|<span data-ttu-id="5c64e-4502">Format d’assembly</span><span class="sxs-lookup"><span data-stu-id="5c64e-4502">Assembly Format</span></span>|<span data-ttu-id="5c64e-4503">Description</span><span class="sxs-lookup"><span data-stu-id="5c64e-4503">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="5c64e-4504">61</span><span class="sxs-lookup"><span data-stu-id="5c64e-4504">61</span></span>|<span data-ttu-id="5c64e-4505">xor</span><span class="sxs-lookup"><span data-stu-id="5c64e-4505">xor</span></span>|<span data-ttu-id="5c64e-4506">Calcule l’opération de bits XOR des deux valeurs entières et retourne un entier.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4506">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="5c64e-4507">Le comportement de transition de pile, dans un ordre séquentiel, est :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4507">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="5c64e-4508">`value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4508">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="5c64e-4509">`value2` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4509">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="5c64e-4510">`value2` et `value1` sont dépilés à partir de la pile et leurs opérations de bits XOR est calculée.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4510">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="5c64e-4511">L’opération de bits XOR de `value2` et `value1` est placé sur la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4511">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4512">La `xor` instruction calcule l’opération de bits XOR des deux premières valeurs de la pile et laisse le résultat dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4512">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="5c64e-4513">`Xor` est une opération spécifique aux entiers.</span><span class="sxs-lookup"><span data-stu-id="5c64e-4513">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="5c64e-4514">Ce qui suit <xref:System.Reflection.Emit.ILGenerator.Emit%2A> surcharge de méthode permettre utiliser le `xor` opcode :</span><span class="sxs-lookup"><span data-stu-id="5c64e-4514">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="5c64e-4515">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="5c64e-4515">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>