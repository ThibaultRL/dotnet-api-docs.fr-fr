<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f71f19f818c7bf30fbcfe76ff72b1a848912959d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65001087" /></Metadata><TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <TypeSignature Language="F#" Value="type DataContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente le point d’entrée principal de l’infrastructure LINQ to SQL.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Linq.DataContext> est la source de toutes les entités sont mappées sur une connexion de base de données. Suivi des modifications que vous avez apportées à toutes les entités récupérées et maintient un « cache d’identité » qui garantit que les entités récupérées plusieurs fois est représentées par à l’aide de la même instance d’objet.  
  
 En règle générale, un <xref:System.Data.Linq.DataContext> instance est conçue pour durer une « unité de travail » Toutefois, votre application définit ce terme. Un <xref:System.Data.Linq.DataContext> est légère et n’est pas coûteux à créer. Classique [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] application crée <xref:System.Data.Linq.DataContext> instances à portée de la méthode ou en tant que membre de classes de courte durée de vie qui représentent un ensemble logique de liées des opérations de base de données.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Linq.DataContext" />. La chaîne de connexion que vous utilisez peut être une chaîne de connexion ADO.NET. Vous pouvez également spécifier un nom de fichier dans un fichier SQL Server Express ou SQL Server Compact.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">La connexion utilisée par le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Data.Linq.DataContext" /> classe en référençant la connexion utilisée par le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.Linq.DataContext> s’ouvre et ferme une connexion de base de données en fonction des besoins si vous fournissez une connexion fermée ou une chaîne de connexion. En règle générale, vous ne devriez jamais avoir à appeler `Dispose` sur un <xref:System.Data.Linq.DataContext>. Si vous fournissez une connexion ouverte, le <xref:System.Data.Linq.DataContext> fermera pas. Par conséquent, n’instanciez pas un <xref:System.Data.Linq.DataContext> avec une connexion ouverte à moins d’avoir une bonne raison à cela. Dans un <xref:System.Transactions> transaction, un <xref:System.Data.Linq.DataContext> ne sera pas ouvrir ou fermer une connexion pour éviter la promotion.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (connection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">La connexion utilisée par le .NET Framework.</param>
        <param name="mapping">Source pour le mappage.</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Data.Linq.DataContext" /> classe en référençant une connexion et une source de mappage.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (fileOrServerOrConnection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Cet argument peut prendre l’une des opérations suivantes : 
Le nom d’un fichier contenant une base de données SQL Server Express.  
  
Le nom d’un serveur où se trouve une base de données. Dans ce cas, le fournisseur utilise la base de données par défaut pour un utilisateur.  
  
Une chaîne de connexion complète. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] passe juste la chaîne au fournisseur sans modification.</param>
        <param name="mapping">Source pour le mappage.</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Data.Linq.DataContext" /> classe en référençant une source de fichier et une source de mappage.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Cet argument peut prendre l’une des opérations suivantes : Le nom d’un fichier contenant une base de données SQL Server Express.

Le nom d’un serveur où se trouve une base de données. Dans ce cas, le fournisseur utilise la base de données par défaut pour un utilisateur.  
  
Une chaîne de connexion complète. LINQ to SQL passe juste la chaîne au fournisseur sans modification.</param>
        <param name="connectionString">Cet argument peut prendre l’une des opérations suivantes : Le nom d’un fichier contenant une base de données SQL Server Express.

Le nom d’un serveur où se trouve une base de données. Dans ce cas, le fournisseur utilise la base de données par défaut pour un utilisateur.  
  
Une chaîne de connexion complète. LINQ to SQL passe juste la chaîne au fournisseur sans modification.</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Data.Linq.DataContext" /> classe en faisant référence à une source de fichier.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChangeConflicts : System.Data.Linq.ChangeConflictCollection" Usage="System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection d’objets qui ont provoqué des conflits d’accès concurrentiel lorsque <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> a été appelée.</summary>
        <value>Collection d’objets qui ont provoqué des conflits d’accès concurrentiel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’exemple suivant montre comment la collection peut être itérée pour récupérer des informations sur les conflits.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : int with get, set" Usage="System.Data.Linq.DataContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur entière qui augmente le délai d’attente (en secondes) pour les requêtes qui, sinon, expireraient pendant le délai d’attente par défaut.</summary>
        <value>Valeur entière qui augmente le délai d’attente (en secondes) pour les requêtes qui, sinon, expireraient pendant le délai d’attente par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété obtient ou définit le délai d’attente de commande (en secondes) utilisé pour exécuter les commandes générées (`IDbCommands`). Pour plus d'informations, consultez <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Lorsque cette propriété est non définie, la valeur par défaut de <xref:System.Data.IDbCommand.CommandTimeout%2A> est utilisé pour l’exécution de commande de requête. Cette valeur par défaut est définie par le fournisseur de stockage. Notez que certains fournisseurs peuvent lever des exceptions si cette valeur est définie sur une valeur différente de zéro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Linq.DataContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la connexion utilisée par l’infrastructure.</summary>
        <value>La connexion utilisée par l’infrastructure.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour interagir avec le code ADO.NET relationnel.  
  
 La connexion retournée va être fermée, sauf si elle a été ouverte explicitement par l’utilisateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="dataContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une base de données sur le serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom de la base de données est dérivé à l’aide de l’algorithme suivant :  
  
1. Si une base de données est identifiée dans la chaîne de connexion, son nom est utilisé.  
1. Si un <xref:System.Data.Linq.Mapping.DatabaseAttribute> attribut n’est présent, sa <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> propriété est utilisée comme nom de la base de données.  
1. S’il n’existe aucune balise de base de données dans la chaîne de connexion et fortement typé <xref:System.Data.Linq.DataContext> est utilisé, une base de données qui a le même nom que le <xref:System.Data.Linq.DataContext> qui hérite de classe est créée.  
1. Si un faiblement typée <xref:System.Data.Linq.DataContext> est utilisé, une exception est levée.  
1. Si le <xref:System.Data.Linq.DataContext> a été créé en utilisant un nom de fichier, la base de données correspondant à ce nom de fichier est créé.  
     
  
## Examples  
 Le code suivant montre comment configurer une base de données temporaire et les supprimer.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fb7f23c4-4572-4c38-9898-a287807d070c">Procédure : Créer dynamiquement une base de données (LINQ to SQL)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4ed76327-54a7-414b-82a9-7579bfcec04b">Mappage de type SQL-CLR (LINQ to SQL)</related>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodCallQuery : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="dataContext.CreateMethodCallQuery (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Le type des éléments dans la collection retournée.</typeparam>
        <param name="instance">L’instance de l’appel de méthode (l’objet actuel).</param>
        <param name="methodInfo"><see cref="T:System.Reflection.MethodInfo" /> qui identifie la méthode .NET qui correspond à une méthode de base de données.</param>
        <param name="parameters">Le tableau de paramètres à passer à la commande.</param>
        <summary>Exécute la fonction de base de données table associée à la méthode .NET spécifiée.</summary>
        <returns>Une collection de valeurs résultantes retournée par la requête de base de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> méthode est utilisée dans le code généré automatiquement et agit comme un proxy pour les fonctions de base de données.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="dataContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si la base de données associé peut être ouvert.</summary>
        <returns><see langword="true" /> Si la base de données spécifié peut être ouvert ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la connexion dans le <xref:System.Data.Linq.DataContext.Connection%2A> propriété pour essayer d’ouvrir la base de données associée.  
  
   
  
## Examples  
 L’exemple suivant utilise cette méthode pour déterminer si une base de données existe déjà.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DeferredLoadingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique s’il faut charger en différé les relations un-à-plusieurs ou un à un.</summary>
        <value><see langword="true" /> Si le chargement différé est activé ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le code accède à une de ces relations, null est retournée si la relation est-à-un, et une collection vide est retournée s’il s’agit d’un-à-plusieurs. Les relations peuvent toujours être renseignées en définissant le <xref:System.Data.Linq.DataContext.LoadOptions%2A> propriété.  
  
 Le scénario principal de cette propriété est de vous permettent d’extraire une partie du modèle objet et l’envoyer (par exemple, pour un service Web).  
  
> [!NOTE]
>  Si cette propriété est définie sur `false` après l’exécution d’une requête, une exception est levée. Consultez le **Modes valides** section ci-dessous pour plus d’informations.  
  
## <a name="valid-modes"></a>Modes valides  
 Chargement différé requiert le suivi de l’objet. Seuls les trois modes suivants sont valides :  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> est ignoré et déduit comme étant `false`. Ce comportement correspond en lecture seule <xref:System.Data.Linq.DataContext>.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Cette situation correspond à un <xref:System.Data.Linq.DataContext> permettant aux utilisateurs de charger un graphique d’objet à l’aide <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> directives, mais il ne permet pas de chargement différé.  
  
-   Les deux sont définis sur `true`. Il s'agit de la valeur par défaut.  
  
 Les indicateurs ne peuvent pas être modifiées après l’exécution d’une requête. Toute modification apportée après l’exécution de la première requête qui utilise ce <xref:System.Data.Linq.DataContext> lève une exception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="dataContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime la base de données associée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la connexion dans le <xref:System.Data.Linq.DataContext.Connection%2A> propriété pour identifier la base de données à supprimer.  
  
   
  
## Examples  
 L’exemple suivant montre comment supprimer une base de données qui a été créé temporairement.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par la classe <see cref="T:System.Data.Linq.DataContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="dataContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="dataContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par la <see cref="T:System.Data.Linq.DataContext" /> classe et libère éventuellement les ressources gérées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteCommand : string * obj[] -&gt; int" Usage="dataContext.ExecuteCommand (command, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Commande SQL à exécuter.</param>
        <param name="parameters">Le tableau de paramètres à passer à la commande. Notez le comportement suivant : 
Si le nombre d’objets dans le tableau est inférieur au nombre le plus élevé identifié dans la chaîne de commande, une exception est levée.  
  
Si le tableau contient des objets qui ne sont pas référencés dans la chaîne de commande, aucune exception n’est levée.  
  
Si l’un des paramètres est null, il est converti en <see langword="DBNull.Value" />.</param>
        <summary>Exécute les commandes SQL directement sur la base de données.</summary>
        <returns>Le nombre de lignes modifiées par la commande exécutée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est un mécanisme direct pour les cas où [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] ne fournit pas suffisamment pour un scénario particulier.  
  
 La syntaxe de la commande est presque identique à la syntaxe utilisée pour créer un élément ADO.NET `DataCommand`. La seule différence est dans la façon dont les paramètres sont spécifiés. Plus précisément, vous spécifiez des paramètres en les plaçant entre accolades ({...}) et les énumérer à partir de 0. Le paramètre est associé à l’objet de même numéro dans le tableau de paramètres.  
  
 `ExecuteQuery` et `ExecuteCommand` vous permettent de spécifier un nombre variable d’arguments pour la substitution de paramètre. Par exemple, vous pouvez spécifier les paramètres lors de l’appel ExecuteQuery\<TResult > :  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 Et un autre exemple :  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 L’exemple suivant ouvre une connexion et passe une instance SQL `UPDATE` commande au moteur SQL.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicDelete : obj -&gt; unit" Usage="dataContext.ExecuteDynamicDelete entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">L’entité à supprimer.</param>
        <summary>S’exécute, à l’intérieur des méthodes override de suppression pour redéléguer à [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] la tâche de génération et exécution de SQL dynamique pour les opérations de suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicInsert : obj -&gt; unit" Usage="dataContext.ExecuteDynamicInsert entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">L’entité à insérer.</param>
        <summary>S’exécute à l’intérieur des méthodes override d’insertion pour redéléguer à [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] la tâche de génération et d’exécution d’instructions SQL dynamique pour les opérations d’insertion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez les points suivants :  
  
-   Étant donné que la méthode a un modificateur protected, son utilisation requiert le sous-classement <xref:System.Data.Linq.DataContext>.  
  
-   Une exception est levée si cette opération n’est pas appelée à l’intérieur d’un <xref:System.Data.Linq.DataContext.SubmitChanges%2A> opération. Il ne vise pas à être appelé comme une opération autonome à l’extérieur de l’étendue d’un <xref:System.Data.Linq.DataContext.SubmitChanges%2A> opération. <xref:System.Data.Linq.DataContext.SubmitChanges%2A> lui-même appelle des méthodes override si elles sont implémentées et que les méthodes précédentes sont destinées à être appelées dans les méthodes de remplacement.  
  
-   Il incombe au développeur de passer de l’entité correcte. L’implémentation vérifie que l’entité dans le passé est suivie. Toutefois, il incombe au développeur de conserver l’ordre ou de passer dans la même entité deux fois.  
  
-   Il incombe au développeur d’appeler l’API dynamique appropriée. Par exemple, dans le `Update` substituer la méthode, uniquement le <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> méthode peut être appelée. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] ne détecte pas ni ne vérifie si la méthode dynamique appelée correspond à l'opération applicable. Les résultats ne sont pas définis si une méthode inapplicable est appelée (par exemple, l’appel <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> pour un objet à mettre à jour).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicUpdate : obj -&gt; unit" Usage="dataContext.ExecuteDynamicUpdate entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">L’entité à mettre à jour.</param>
        <summary>S’exécute, à l’intérieur des méthodes override de mise à jour pour redéléguer à [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] la tâche de génération et exécution de SQL dynamique pour les opérations de mise à jour.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteMethodCall : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Data.Linq.IExecuteResult" Usage="dataContext.ExecuteMethodCall (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">L’instance de l’appel de méthode (l’objet actuel).</param>
        <param name="methodInfo">Identifie la méthode .NET qui correspond à une méthode de base de données.</param>
        <param name="parameters">Le tableau de paramètres à passer à la commande.</param>
        <summary>Exécute la procédure de base de données stockée ou la fonction scalaire associée à la méthode .NET spécifiée.</summary>
        <returns>Le résultat (la valeur de retour et les paramètres de sortie) de l’exécution de la méthode spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> méthode est utilisée dans le code généré automatiquement et agit comme un proxy pour les fonctions de base de données.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : Type * string * obj[] -&gt; System.Collections.IEnumerable" Usage="dataContext.ExecuteQuery (elementType, query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Le type de la <see cref="T:System.Collections.Generic.IEnumerable`1" /> à retourner.  
  
L’algorithme pour les colonnes correspondantes dans le résultat de la requête aux champs ou propriétés de l’objet fonctionne comme suit : 
Si un champ ou une propriété est mappée à un nom de colonne particulier, ce nom de colonne est attendu dans le jeu de résultats.  
  
Si un champ ou propriété n’est pas mappée, une colonne avec le même nom que le champ ou la propriété est attendue dans le jeu de résultats.  
  
La comparaison est effectuée en recherchant une correspondance sensible à tout d’abord. Si cette correspondance n’est trouvée, une recherche ultérieure est effectuée pour une correspondance de non-respect de la casse.  
  
La requête doit retourner tous les champs suivis et les propriétés de l’objet (à l’exception de ceux qui sont chargés sur une base différée) lorsque toutes les conditions suivantes sont remplies : 
 <c>T</c> est une entité faisant explicitement l’objet d’un suivi par <see cref="T:System.Data.Linq.DataContext" />.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> a la valeur <see langword="true" />.  
  
L’entité a une clé primaire.  
  
Sinon, une exception est levée.</param>
        <param name="query">La requête SQL à exécuter.</param>
        <param name="parameters">Le tableau de paramètres à passer à la commande. Notez le comportement suivant : 
Si le nombre d’objets dans le tableau est inférieur au nombre le plus élevé identifié dans la chaîne de commande, une exception est levée.  
  
Si le tableau contient des objets qui ne sont pas référencés dans la chaîne de commande, aucune exception n’est levée.  
  
Si un paramètre est <see langword="null" />, il est converti en <see langword="DBNull.Value" />.</param>
        <summary>Exécute des requêtes SQL directement sur la base de données.</summary>
        <returns>Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection d’objets retournés par la requête.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result (requires 'Result : (new : unit -&gt; 'Result))&gt; (requires 'Result : (new : unit -&gt; 'Result))" Usage="dataContext.ExecuteQuery (query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Le type des éléments dans la collection retournée.</typeparam>
        <param name="query">La requête SQL à exécuter.</param>
        <param name="parameters">Le tableau de paramètres à passer à la commande. Notez le comportement suivant : 
Si le nombre d’objets dans le tableau est inférieur au nombre le plus élevé identifié dans la chaîne de commande, une exception est levée.  
  
Si le tableau contient des objets qui ne sont pas référencés dans la chaîne de commande, aucune exception n’est levée.  
  
Si un paramètre est null, il est converti en <see langword="DBNull.Value" />.</param>
        <summary>Exécute des requêtes SQL directement sur la base de données et retourne des objets.</summary>
        <returns>Une collection d’objets retournés par la requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est un mécanisme direct pour les cas où [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] ne fournit pas pour un scénario particulier.  
  
 L’algorithme pour les colonnes correspondantes dans le résultat de la requête aux champs et propriétés de l’objet fonctionne comme suit :  
  
-   Si un champ ou une propriété est mappée à un nom de colonne particulier, ce nom de colonne est attendu dans le jeu de résultats.  
  
-   Si un champ ou propriété n’est pas mappée, une colonne avec le même nom que le champ ou la propriété est attendue dans le jeu de résultats.  
  
-   La comparaison est effectuée en recherchant en premier une correspondance qui respecte la casse. Si une telle correspondance est introuvable, une recherche ultérieure est effectuée pour une correspondance non sensible à.  
  
-   La requête doit retourner tous les champs suivis et les propriétés de l’objet (à l’exception de ceux soumis à chargement différé) lorsque toutes les conditions suivantes sont remplies :  
  
    -   Si `<T>` est une entité suivie explicitement par le <xref:System.Data.Linq.DataContext>.  
  
    -   ObjectTrackingEnabled a la valeur true.  
  
    -   L’entité a une clé primaire.  
  
     Sinon, une exception est levée.  
  
-   Dans tous les autres cas, la requête peut récupérer uniquement un sous-ensemble des champs suivis et des propriétés pour l’objet.  
  
 L’extrait de code c# suivant montre une utilisation de cette méthode :  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 Dans Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberSignature Language="F#" Value="member this.GetChangeSet : unit -&gt; System.Data.Linq.ChangeSet" Usage="dataContext.GetChangeSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les objets modifiés suivis par <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <returns>Le jeu d’objets est retourné sous forme de trois collections en lecture seule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez les points suivants :  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> peut avoir des effets secondaires, tels que l’inférence d’insertion et supprimer des opérations qui sont généralement effectuées au moment de <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Par exemple, les objets qui sont utilisés dans les opérations suivantes peuvent créer des opérations déduites correspondantes dans la liste suivante :  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A> à <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601> affectation de null (peut-être en raison de <xref:System.Data.Linq.EntitySet%601.Remove%2A> à <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.  
  
-   Le jeu n’a pas peut-être être classé en fonction des contraintes de clé étrangère.  
  
-   Valeurs générées à la base de données (par exemple, les valeurs de clés primaires et étrangères, les horodateurs et ainsi de suite) ne sont pas disponibles. Ces informations nécessite l’exécution de la commande de base de données et peut-être la propagation des informations récupérées (par exemple, la clé étrangère à partir de la clé primaire).  
  
-   L’ensemble des objets modifiés est calculée au moment de l’appel. Les appels suivants à <xref:System.Data.Linq.DataContext.SubmitChanges%2A> peut produire un ensemble différent si des modifications supplémentaires sont apportées.  
  
 Sortie lorsqu’aucune modification a été apportée apparaît comme suit :  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetCommand : System.Linq.IQueryable -&gt; System.Data.Common.DbCommand" Usage="dataContext.GetCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">La requête d’informations sur les commandes dont SQL doit être récupéré.</param>
        <summary>Obtient les informations sur les commandes SQL générées par [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)].</summary>
        <returns>L’objet d’informations de la commande demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est uniquement un accesseur Get et n’affecte pas <xref:System.Data.Linq.DataContext> état.  
  
 Notez les points suivants :  
  
-   L’argument doit être non null. Sinon, une exception d’argument null est levée.  
  
-   Exceptions de traduction de requête normales levées pendant [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] l’exécution des requêtes s’appliquent à une requête qui ne peut pas être traduite.  
  
-   La première commande de requête est retournée. Plus précisément, les commandes supplémentaires qui sont utilisés pour le chargement hâtif (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) ne sont pas inclus.  
  
-   <xref:System.Data.Linq.DataContext> ne suit pas ce que fait l’utilisateur avec la commande. Par exemple, les résultats de l’exécution de la commande retournée ne sont pas suivies et n’affectent pas <xref:System.Data.Linq.DataContext> état.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetIDbCommand : System.Linq.IQueryable -&gt; System.Data.IDbCommand" Usage="dataContext.GetIDbCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTable : Type -&gt; System.Data.Linq.ITable" Usage="dataContext.GetTable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Le type des objets à retourner.</param>
        <summary>Retourne une collection d’objets d’un type particulier, où le type est défini par le <paramref name="type" /> paramètre.</summary>
        <returns>Une collection d’objets définis par le <paramref name="type" /> paramètre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une version faiblement typée de <xref:System.Data.Linq.DataContext.GetTable%2A>. Il est important de disposer d’une version faiblement typée, car il est relativement courant pour construire des requêtes dynamiquement. Il serait peu pratique forcer l’application à utiliser la réflexion pour appeler la méthode générique correcte.  
  
 S’il n’existe pas de collection pour un type particulier, une exception est levée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberSignature Language="F#" Value="member this.GetTable : unit -&gt; System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="dataContext.GetTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Le type des objets à retourner.</typeparam>
        <summary>Retourne une collection d’objets d’un type particulier, où le type est défini par le <paramref name="TEntity" /> paramètre.</summary>
        <returns>Une collection d’objets définis par le <paramref name="TEntity" /> paramètre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est le point d’entrée principal pour l’interrogation. Lorsqu’il est fortement typé <xref:System.Data.Linq.DataContext> est créées, de nouvelles propriétés générées encapsulent les appels à cette méthode. Par exemple, un `Customers` propriété est générée qui retourne `GetTable<Customer>`.  
  
 S’il n’existe pas de collection pour un type particulier, une exception est levée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LoadOptions : System.Data.Linq.DataLoadOptions with get, set" Usage="System.Data.Linq.DataContext.LoadOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Data.Linq.DataLoadOptions" /> associé à cet <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <value>La charge de prérécupération options pour les données associées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété obtient ou définit les options qui permettent de définir le comportement de prérécupération pour les membres à chargement différé et l’appartenance des collections connexes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : System.IO.TextWriter with get, set" Usage="System.Data.Linq.DataContext.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la destination pour écrire la requête SQL ou la commande.</summary>
        <value>Le <see cref="T:System.IO.TextReader" /> à utiliser pour écrire la commande.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur `null` pour désactiver la journalisation de la commande.  
  
   
  
## Examples  
 L’exemple suivant affiche le SQL généré dans la fenêtre de console avant d’afficher les résultats de la requête.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mapping : System.Data.Linq.Mapping.MetaModel" Usage="System.Data.Linq.DataContext.Mapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Data.Linq.Mapping.MetaModel" /> sur lequel est basé le mappage.</summary>
        <value>Le mappage entre des objets de base de données et de domaine.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectTrackingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le suivi de l’objet est activé.</summary>
        <value><see langword="true" /> Si l’objet de suivi est activé ; Sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété `false` améliore les performances au moment de la récupération, car il existe moins d’éléments pour effectuer le suivi.  
  
 Une exception est levée :  
  
-   Si la propriété est définie sur `false` après l’exécution d’une requête.  
  
     Pour plus d’informations, consultez la section Modes valides dans <xref:System.Data.Linq.DataContext>.  
  
-   Si la propriété est définie sur `false` et <xref:System.Data.Linq.DataContext.SubmitChanges%2A> est appelée.  
  
 Si <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> est `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> est ignorée et traitée en tant que `false`. Dans ce cas, le <xref:System.Data.Linq.DataContext> est en lecture seule.  
  
 Si <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> est `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> est `false`. Dans ce cas, <xref:System.Data.Linq.DataContext> vous permet de charger un graphique d’objet à l’aide <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> directives, mais n’active pas le chargement différé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.QueryCacheEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualise l’état de l’objet à l’aide des données dans la base de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile après une erreur d’accès concurrentiel optimiste pour placer des éléments dans un état pour une autre tentative. Il met à jour l’état des champs primitifs et des propriétés sur les objets.  
  
> [!NOTE]
>  Si un objet est sur le *nombreux* côté d’une relation un-à-plusieurs, la clé étrangère sur l’objet est définie et que le pointeur d’objet de l’autre côté de la relation est fixé à la nouvelle valeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Une valeur qui spécifie les conflits d’accès concurrentiel optimiste comment sont gérées.</param>
        <param name="entities">La collection d’entités à actualiser.</param>
        <summary>Actualise une collection d’objets d’entité selon le mode spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj -&gt; unit" Usage="dataContext.Refresh (mode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Une valeur qui spécifie les conflits d’accès concurrentiel optimiste comment sont gérées.</param>
        <param name="entity">Objet à actualiser.</param>
        <summary>Actualise un objet d’entité selon le mode spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj[] -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Une valeur qui spécifie les conflits d’accès concurrentiel optimiste comment sont gérées.</param>
        <param name="entities">Tableau d’objets d’entité à actualiser.</param>
        <summary>Actualise un tableau d’objets d’entité selon le mode spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule le jeu d’objets modifiés pour être inséré, mis à jour ou supprimé et exécute les commandes appropriées pour implémenter les modifications apportées à la base de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les méthodes override sont présentes pour insert, update ou delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> exécute ces méthodes au lieu de la valeur par défaut [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] commandes.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> démarre une transaction et sera annulée si une exception se produit alors que <xref:System.Data.Linq.DataContext.SubmitChanges%2A> s’exécute. Toutefois, cela n’annule pas les modifications en mémoire ou suivies par le <xref:System.Data.Linq.DataContext>; ces modifications devront être restaurées manuellement. Vous pouvez démarrer avec une nouvelle instance de la <xref:System.Data.Linq.DataContext> si les modifications en mémoire doivent être ignorées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberSignature Language="F#" Value="member this.SubmitChanges : unit -&gt; unit" Usage="dataContext.SubmitChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Calcule le jeu d’objets modifiés pour être inséré, mis à jour ou supprimé et exécute les commandes appropriées pour implémenter les modifications apportées à la base de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les méthodes override sont présentes pour insert, update ou delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> exécute ces méthodes au lieu de la valeur par défaut [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] commandes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberSignature Language="F#" Value="abstract member SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit&#xA;override this.SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit" Usage="dataContext.SubmitChanges failureMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">L’action à entreprendre si la soumission échoue. Les arguments valides sont les suivantes : 
 <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Envoie les modifications qui ont été apportées à récupérer des objets à la base de données sous-jacente et spécifie l’action à entreprendre si la soumission échoue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mode d’échec par défaut est <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transaction : System.Data.Common.DbTransaction with get, set" Usage="System.Data.Linq.DataContext.Transaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une transaction locale pour le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] à utiliser pour accéder à la base de données.</summary>
        <value>L’objet de transaction utilisé par le <see cref="T:System.Data.Linq.DataContext" /> lors de l’exécution des requêtes et des commandes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le scénario principal de cette propriété est l’interopérabilité avec relationnelles [!INCLUDE[vstecado](~/includes/vstecado-md.md)] code. Par exemple, utilisez cette propriété lorsque vous écrivez votre propre `Create` / `Update` / `Delete` méthodes permettant de définir le `Transaction` propriété sur ADO `Command` objet.  
  
 Notez les points suivants :  
  
-   Si cette propriété n’a pas été explicitement définie, la méthode getter retourne la valeur null.  
  
-   Si l’exécution du code dans un <xref:System.Transactions.Transaction> contexte, la définition de cette propriété lève une exception.  
  
-   Si cette propriété est définie et un nouveau <xref:System.Transactions.Transaction> est ouvert, une exception est levée lorsqu’une requête ou une mise à jour est exécutée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit un existant <see cref="T:System.Data.IDataReader" /> aux objets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque ligne dans le <xref:System.Data.IDataReader> est convertie en un objet dans le <xref:System.Collections.Generic.IEnumerable%601>.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Description : Cette méthode est utilisée pour convertir un existant <xref:System.Data.Common.DbDataReader> aux objets. Chaque ligne dans le <xref:System.Data.Common.DbDataReader> est convertie en un objet dans le <xref:System.Collections.Generic.IEnumerable%601>.  
  
 **Paramètres génériques :**  
  
 `T`: Consultez <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Paramètres :**  
  
 `Query`: Consultez la description de la commande sous <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 `Parameters`: Consultez la description des paramètres sous <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 **Type de retour :**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: collection d’objets retournés par la conversion.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Linq.IMultipleResults" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> à convertir.</param>
        <summary>Convertit un existant <see cref="T:System.Data.Common.DbDataReader" /> aux objets.</summary>
        <returns>Une liste d’objets retournés par la conversion.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : Type * System.Data.Common.DbDataReader -&gt; System.Collections.IEnumerable" Usage="dataContext.Translate (elementType, reader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Le type de la <see cref="T:System.Collections.Generic.IEnumerable`1" /> à retourner.  
  
L’algorithme pour les colonnes correspondantes dans le résultat aux champs et propriétés de l’objet fonctionne comme suit : 
Si un champ ou une propriété est mappée à un nom de colonne particulier, ce nom de colonne est attendu dans le jeu de résultats.  
  
Si un champ ou propriété n’est pas mappée, une colonne avec le même nom que le champ ou la propriété est attendue dans le jeu de résultats.  
  
La comparaison est effectuée en recherchant une correspondance sensible à tout d’abord. Si cette correspondance est introuvable, une recherche ultérieure est effectuée pour une correspondance de non-respect de la casse.  
  
La requête doit retourner tous les champs suivis et les propriétés de l’objet (à l’exception de ceux qui sont chargés sur une base différée) lorsque toutes les conditions suivantes sont remplies : 
 <c>T</c> est une entité faisant explicitement l’objet d’un suivi par <see cref="T:System.Data.Linq.DataContext" />.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> a la valeur <see langword="true" />.  
  
L’entité a une clé primaire.  
  
Sinon, une exception est levée.</param>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> à convertir.</param>
        <summary>Convertit un existant <see cref="T:System.Data.Common.DbDataReader" /> aux objets.</summary>
        <returns>Une liste d’objets retournés par la conversion.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; seq&lt;'Result&gt;" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Le type de la <see cref="T:System.Collections.Generic.IEnumerable`1" /> à retourner.</typeparam>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> à convertir.</param>
        <summary>Convertit un existant <see cref="T:System.Data.Common.DbDataReader" /> aux objets.</summary>
        <returns>Une collection d’objets retournés par la conversion.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>