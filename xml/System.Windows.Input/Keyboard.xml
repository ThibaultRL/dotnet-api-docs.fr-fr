<Type Name="Keyboard" FullName="System.Windows.Input.Keyboard">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f86c9bedb646354cdd97f445a1426be77f4b45c1" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65004691" /></Metadata><TypeSignature Language="C#" Value="public static class Keyboard" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Keyboard extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.Keyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Keyboard" />
  <TypeSignature Language="C++ CLI" Value="public ref class Keyboard abstract sealed" />
  <TypeSignature Language="F#" Value="type Keyboard = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente le périphérique clavier.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.Keyboard> classe fournit des événements associés au clavier, méthodes et propriétés qui fournissent des informations concernant l’état du clavier.  
  
 Chacun des événements qui <xref:System.Windows.Input.Keyboard> définit comme un événement attaché est a également été ré-exposé par les classes d’élément de base <xref:System.Windows.UIElement> et <xref:System.Windows.ContentElement> en tant qu’un nouvel événement routé. En règle générale, il est plus pratique gérer les événements de clavier pour une application sur <xref:System.Windows.UIElement> et <xref:System.Windows.ContentElement>, au lieu d’utiliser le <xref:System.Windows.Input.Keyboard> événements. Pour plus d’informations, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Dans l’ordre d’un élément recevoir l’entrée de clavier, l’élément doit pouvoir être actif. La plupart des <xref:System.Windows.UIElement> objets dérivés sont pouvant prendre le focus par défaut. Sinon, pour rendre un élément actif, définissez la <xref:System.Windows.UIElement.Focusable%2A> propriété sur l’élément de base `true`.  Pour plus d’informations sur les éléments de base, consultez [vue d’ensemble des éléments de Base](~/docs/framework/wpf/advanced/base-elements-overview.md).  
  
 <xref:System.Windows.Controls.Panel> classes, telles que <xref:System.Windows.Controls.StackPanel> et <xref:System.Windows.Controls.Canvas>, définissez la valeur par défaut de <xref:System.Windows.UIElement.Focusable%2A> à `false`. Par conséquent, pour ces objets à obtenir le focus clavier, <xref:System.Windows.UIElement.Focusable%2A> doit être définie sur `true`.  
  
 Le focus clavier fait référence à l’objet qui reçoit l’entrée au clavier. L’élément ayant le focus clavier a <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> défini sur `true`.  Il peut y avoir qu’un seul élément ayant le focus clavier sur l’intégralité du bureau.  Le focus logique fait référence à l’objet dans une portée de focus qui a le focus.  Pour plus d’informations sur le focus, le focus clavier et le focus logique, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md) et [vue d’ensemble du Focus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 Les membres statiques de la <xref:System.Windows.Input.Keyboard> délégué de classe vers le serveur principal <xref:System.Windows.Input.KeyboardDevice> du thread appelant, donc ils ne sont pas nécessairement thread-safe.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Input.Keyboard.IsKeyToggled%2A> méthode pour déterminer si une touche est basculée. Si le <xref:System.Windows.Input.Key> transmis à <xref:System.Windows.Input.Keyboard.IsKeyToggled%2A> est activé ou désactivé, l’arrière-plan d’un bouton est modifié.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardIsToggled](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardistoggled)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardIsToggled](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardistoggled)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
    <altmember cref="T:System.Windows.Input.KeyEventArgs" />
  </Docs>
  <Members>
    <Member MemberName="AddGotKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddGotKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddGotKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddGotKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKeyboardInputProviderAcquireFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddKeyboardInputProviderAcquireFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddKeyboardInputProviderAcquireFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddKeyboardInputProviderAcquireFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddKeyboardInputProviderAcquireFocusHandler (element As DependencyObject, handler As KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddKeyboardInputProviderAcquireFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardInputProviderAcquireFocusEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddKeyboardInputProviderAcquireFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddKeyboardInputProviderAcquireFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKeyDownHandler">
      <MemberSignature Language="C#" Value="public static void AddKeyDownHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddKeyDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddKeyDownHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddKeyDownHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddKeyDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddKeyDownHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddKeyDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKeyUpHandler">
      <MemberSignature Language="C#" Value="public static void AddKeyUpHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddKeyUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddKeyUpHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddKeyUpHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddKeyUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddKeyUpHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddKeyUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddLostKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddLostKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddLostKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewGotKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewGotKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewGotKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddPreviewGotKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewGotKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewGotKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewGotKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddPreviewGotKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewKeyboardInputProviderAcquireFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewKeyboardInputProviderAcquireFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewKeyboardInputProviderAcquireFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddPreviewKeyboardInputProviderAcquireFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewKeyboardInputProviderAcquireFocusHandler (element As DependencyObject, handler As KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewKeyboardInputProviderAcquireFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardInputProviderAcquireFocusEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewKeyboardInputProviderAcquireFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddPreviewKeyboardInputProviderAcquireFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewKeyDownHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewKeyDownHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewKeyDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddPreviewKeyDownHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewKeyDownHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewKeyDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewKeyDownHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddPreviewKeyDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewKeyUpHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewKeyUpHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewKeyUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddPreviewKeyUpHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewKeyUpHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewKeyUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewKeyUpHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddPreviewKeyUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewLostKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewLostKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewLostKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.AddPreviewLostKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewLostKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewLostKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewLostKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.AddPreviewLostKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à ajouter.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès de code et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] traitement de l’attribut de la <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearFocus">
      <MemberSignature Language="C#" Value="public static void ClearFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.ClearFocus" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearFocus();" />
      <MemberSignature Language="F#" Value="static member ClearFocus : unit -&gt; unit" Usage="System.Windows.Input.Keyboard.ClearFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface le focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le focus se trouve dans une fenêtre Win32, WPF appelle le <xref:System.Windows.Input.Keyboard.ClearFocus%2A> méthode sur la restauration de focus lorsqu’un menu est fermé.  
  
 Lorsque vous quittez le mode de menu, le focus Win32 est retourné au HWND enfant hébergé, et aucun élément n’a le focus WPF.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultRestoreFocusMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RestoreFocusMode DefaultRestoreFocusMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.RestoreFocusMode DefaultRestoreFocusMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Keyboard.DefaultRestoreFocusMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultRestoreFocusMode As RestoreFocusMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RestoreFocusMode DefaultRestoreFocusMode { System::Windows::Input::RestoreFocusMode get(); void set(System::Windows::Input::RestoreFocusMode value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultRestoreFocusMode : System.Windows.Input.RestoreFocusMode with get, set" Usage="System.Windows.Input.Keyboard.DefaultRestoreFocusMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RestoreFocusMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le comportement de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] lors de la restauration de focus.</summary>
        <value>Valeur d’énumération qui spécifie le comportement de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] lors de la restauration de focus. La valeur par défaut dans <see cref="F:System.Windows.Input.RestoreFocusMode.Auto" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement Focus (System.Windows.IInputElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.IInputElement Focus(class System.Windows.IInputElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.Focus(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Focus (element As IInputElement) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::IInputElement ^ Focus(System::Windows::IInputElement ^ element);" />
      <MemberSignature Language="F#" Value="static member Focus : System.Windows.IInputElement -&gt; System.Windows.IInputElement" Usage="System.Windows.Input.Keyboard.Focus element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">L’élément sur lequel définir le focus clavier.</param>
        <summary>Définit le focus clavier sur l’élément spécifié.</summary>
        <returns>L’élément ayant le focus clavier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour un élément recevoir l’entrée de clavier, l’élément doit pouvoir être actif. Pour rendre un élément actif, donnez le <xref:System.Windows.UIElement.Focusable%2A> propriété sur l’élément de base `true`.  Pour plus d’informations sur les éléments de base, consultez [vue d’ensemble des éléments de Base](~/docs/framework/wpf/advanced/base-elements-overview.md).  <xref:System.Windows.Controls.Panel> classes, telles que <xref:System.Windows.Controls.StackPanel> et <xref:System.Windows.Controls.Canvas>, définissez la valeur par défaut de <xref:System.Windows.UIElement.Focusable%2A> à `false`; par conséquent, pour ces objets à obtenir le focus clavier, <xref:System.Windows.UIElement.Focusable%2A> doit être définie sur `true`.  
  
 Le focus clavier fait référence à l’objet qui reçoit l’entrée au clavier. L’élément ayant le focus clavier a <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> défini sur `true`.  Il peut y avoir qu’un seul élément ayant le focus clavier sur l’intégralité du bureau.  Le focus logique fait référence à l’objet dans une portée de focus qui a le focus.  Pour plus d’informations sur le focus, le focus clavier et le focus logique, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md) et [vue d’ensemble du Focus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 Un élément ayant le focus clavier a également le focus logique pour la portée de focus que l’élément appartient.  Un élément avec le focus logique peut ou ne peut pas avoir le focus clavier.  
  
   
  
## Examples  
 L’exemple suivant montre un <xref:System.Windows.FrameworkElement.Loaded> Gestionnaire d’événements qui définit le focus clavier sur un <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[focussample#FocusSampleSetFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplesetfocus)]
 [!code-vb[focussample#FocusSampleSetFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplesetfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElement">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement FocusedElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement FocusedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Keyboard.FocusedElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property FocusedElement As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ FocusedElement { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FocusedElement : System.Windows.IInputElement" Usage="System.Windows.Input.Keyboard.FocusedElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’élément qui a le focus clavier.</summary>
        <value>Élément ayant le focus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le focus clavier fait référence à l’objet qui reçoit l’entrée au clavier. L’élément ayant le focus clavier a <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> défini sur `true`.  Il peut y avoir qu’un seul élément ayant le focus clavier sur l’intégralité du bureau.  Le focus logique fait référence à l’objet dans une portée de focus qui a le focus.  Pour plus d’informations sur le focus, le focus clavier et le focus logique, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md) et [vue d’ensemble du Focus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 Un élément ayant le focus clavier a également le focus logique pour la portée de focus que l’élément appartient.  Un élément avec le focus logique peut ou ne peut pas avoir le focus clavier.  
  
   
  
## Examples  
 L’exemple suivant obtient l’élément ayant le focus clavier et le caste vers un <xref:System.Windows.Controls.Control>.  Si l’élément ayant le focus clavier est un <xref:System.Windows.Controls.Control>, l’arrière-plan de l’élément est modifié.  
  
 [!code-csharp[focussample#GetKeyboardFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#getkeyboardfocusedelement)]
 [!code-vb[focussample#GetKeyboardFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#getkeyboardfocusedelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeyStates">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.KeyStates GetKeyStates (System.Windows.Input.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Input.KeyStates GetKeyStates(valuetype System.Windows.Input.Key key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.GetKeyStates(System.Windows.Input.Key)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Input::KeyStates GetKeyStates(System::Windows::Input::Key key);" />
      <MemberSignature Language="F#" Value="static member GetKeyStates : System.Windows.Input.Key -&gt; System.Windows.Input.KeyStates" Usage="System.Windows.Input.Keyboard.GetKeyStates key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyStates</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.Input.Key" />
      </Parameters>
      <Docs>
        <param name="key">La clé spécifiée.</param>
        <summary>Obtient l’ensemble des États de touche pour la clé spécifiée.</summary>
        <returns>Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Input.KeyStates" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.KeyStates> est un peu champ énumération ; Par conséquent, il est possible pour une clé peut avoir plusieurs États.  Par exemple, une clé peut être dans un état appuyé ainsi que dans l’état basculé.  Utilisez les opérations de comparaison de bits pour déterminer l’état exact ou la clé se trouve dans les États.  
  
 Le <xref:System.Windows.Input.Keyboard> classe fournit plusieurs méthodes statiques qui peuvent également être utilisé pour obtenir des informations d’état de la clé.  Les méthodes sont : <xref:System.Windows.Input.Keyboard.IsKeyDown%2A>, <xref:System.Windows.Input.Keyboard.IsKeyUp%2A>, et <xref:System.Windows.Input.Keyboard.IsKeyToggled%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> méthode pour déterminer si le <xref:System.Windows.Input.Key.Return> clé se trouve dans le <xref:System.Windows.Input.KeyStates.Down> état.  Opération AND est utilisée pour comparer la <xref:System.Windows.Input.KeyStates> retourné à partir de <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> et <xref:System.Windows.Input.Key.Down> état. Si la touche est enfoncée, l’arrière-plan d’un <xref:System.Windows.Controls.Button> est modifiée.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardgetkeystates)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardgetkeystates)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventArgs" />
        <altmember cref="P:System.Windows.Input.KeyEventArgs.KeyStates" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="see AddGotKeyboardFocusHandler, and RemoveGotKeyboardFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotKeyboardFocusHandler, and RemoveGotKeyboardFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="see AddGotKeyboardFocusHandler, and RemoveGotKeyboardFocusHandler" />
      <MemberSignature Language="F#" Value="see AddGotKeyboardFocusHandler, and RemoveGotKeyboardFocusHandler" Usage="see AddGotKeyboardFocusHandler, and RemoveGotKeyboardFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand un élément reçoit le focus clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Le focus clavier fait référence à l’objet qui reçoit l’entrée au clavier. L’élément ayant le focus clavier a <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> défini sur `true`.  Il peut y avoir qu’un seul élément ayant le focus clavier sur l’intégralité du bureau.  Le focus logique fait référence à l’objet dans une portée de focus qui a le focus.  Pour plus d’informations sur le focus, le focus clavier et le focus logique, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md) et [vue d’ensemble du Focus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 Si le <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus> événement ou la <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus> est géré, le focus clavier ne change pas.  
  
<a name="routedEventInfo_GotKeyboardFocusEvent"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.GotKeyboardFocusEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.TextBox> et attache les gestionnaires d’événements pour le <xref:System.Windows.UIElement.GotKeyboardFocus> événement et le <xref:System.Windows.Input.Keyboard.LostKeyboardFocus> événement.  Lorsque le <xref:System.Windows.Controls.TextBox> Obtient le focus clavier, la couleur d’arrière-plan est modifiée et le texte de la <xref:System.Windows.Controls.TextBox> est désactivée.  Lorsque le <xref:System.Windows.Controls.TextBlock> perd le focus clavier, la couleur d’arrière-plan est modifiée et une méthode est appelée, qui réinitialise les variables utilisées dans l’exemple.  
  
 [!code-xml[keyboardsample#KeyboardSampleXAMLHandlerHookup](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyboardSample/CSharp/Window1.xaml#keyboardsamplexamlhandlerhookup)]  
  
 [!code-csharp[keyboardsample#KeyboardSampleGotFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyboardSample/CSharp/Window1.xaml.cs#keyboardsamplegotfocus)]
 [!code-vb[keyboardsample#KeyboardSampleGotFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyboardSample/visualbasic/window1.xaml.vb#keyboardsamplegotfocus)]  
  
 [!code-csharp[keyboardsample#KeyboardSampleLostFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyboardSample/CSharp/Window1.xaml.cs#keyboardsamplelostfocus)]
 [!code-vb[keyboardsample#KeyboardSampleLostFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyboardSample/visualbasic/window1.xaml.vb#keyboardsamplelostfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyDown">
      <MemberSignature Language="C#" Value="public static bool IsKeyDown (System.Windows.Input.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyDown(valuetype System.Windows.Input.Key key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.IsKeyDown(System.Windows.Input.Key)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyDown(System::Windows::Input::Key key);" />
      <MemberSignature Language="F#" Value="static member IsKeyDown : System.Windows.Input.Key -&gt; bool" Usage="System.Windows.Input.Keyboard.IsKeyDown key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.Input.Key" />
      </Parameters>
      <Docs>
        <param name="key">La clé spécifiée.</param>
        <summary>Détermine si la clé spécifiée est enfoncée.</summary>
        <returns><see langword="true" /> Si <paramref name="key" /> est enfoncé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> méthode peut être utilisée pour déterminer l’ensemble des États d’une clé spécifique.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Input.Keyboard.IsKeyDown%2A> méthode pour déterminer l’état d’une clé spécifique.  Le <xref:System.Windows.Input.Key.Return> clé est passée à la <xref:System.Windows.Input.Keyboard.IsKeyDown%2A> (méthode).  Si la méthode retourne `true`, l’arrière-plan d’un <xref:System.Windows.Controls.Button> est modifiée.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardIsKeyDown](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardiskeydown)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardIsKeyDown](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardiskeydown)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventArgs" />
        <altmember cref="P:System.Windows.Input.KeyEventArgs.IsDown" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyToggled">
      <MemberSignature Language="C#" Value="public static bool IsKeyToggled (System.Windows.Input.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyToggled(valuetype System.Windows.Input.Key key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.IsKeyToggled(System.Windows.Input.Key)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyToggled(System::Windows::Input::Key key);" />
      <MemberSignature Language="F#" Value="static member IsKeyToggled : System.Windows.Input.Key -&gt; bool" Usage="System.Windows.Input.Keyboard.IsKeyToggled key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.Input.Key" />
      </Parameters>
      <Docs>
        <param name="key">La clé spécifiée.</param>
        <summary>Détermine si la clé spécifiée est basculée.</summary>
        <returns><see langword="true" /> Si <paramref name="key" /> est basculé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> méthode peut être utilisée pour déterminer l’ensemble des États d’une clé spécifique.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Input.Keyboard.IsKeyToggled%2A> méthode pour déterminer l’état d’une clé spécifique. Le <xref:System.Windows.Input.Key.Return> clé est passée à la <xref:System.Windows.Input.Keyboard.IsKeyToggled%2A> (méthode).  Si la méthode retourne `true`, puis l’arrière-plan d’un <xref:System.Windows.Controls.Button> est modifiée.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardIsToggled](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardistoggled)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardIsToggled](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardistoggled)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventArgs" />
        <altmember cref="P:System.Windows.Input.KeyEventArgs.IsToggled" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyUp">
      <MemberSignature Language="C#" Value="public static bool IsKeyUp (System.Windows.Input.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyUp(valuetype System.Windows.Input.Key key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.IsKeyUp(System.Windows.Input.Key)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyUp(System::Windows::Input::Key key);" />
      <MemberSignature Language="F#" Value="static member IsKeyUp : System.Windows.Input.Key -&gt; bool" Usage="System.Windows.Input.Keyboard.IsKeyUp key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.Input.Key" />
      </Parameters>
      <Docs>
        <param name="key">Clé à vérifier.</param>
        <summary>Détermine si la touche spécifiée est relâchée.</summary>
        <returns><see langword="true" /> Si <paramref name="key" /> est relâché ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> méthode peut être utilisée pour déterminer l’ensemble des États d’une clé spécifique.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Input.Keyboard.IsKeyUp%2A> méthode pour déterminer l’état d’une clé spécifique.  Le <xref:System.Windows.Input.Key.Return> clé est passée à la <xref:System.Windows.Input.Keyboard.IsKeyUp%2A> (méthode).  Si la méthode retourne `true`, puis l’arrière-plan d’un <xref:System.Windows.Controls.Button> est modifiée.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardIsKeyUp](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardiskeyup)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardIsKeyUp](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardiskeyup)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventArgs" />
        <altmember cref="P:System.Windows.Input.KeyEventArgs.IsUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyboardInputProviderAcquireFocus">
      <MemberSignature Language="C#" Value="see AddKeyboardInputProviderAcquireFocusHandler, and RemoveKeyboardInputProviderAcquireFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddKeyboardInputProviderAcquireFocusHandler, and RemoveKeyboardInputProviderAcquireFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocus" />
      <MemberSignature Language="VB.NET" Value="see AddKeyboardInputProviderAcquireFocusHandler, and RemoveKeyboardInputProviderAcquireFocusHandler" />
      <MemberSignature Language="F#" Value="see AddKeyboardInputProviderAcquireFocusHandler, and RemoveKeyboardInputProviderAcquireFocusHandler" Usage="see AddKeyboardInputProviderAcquireFocusHandler, and RemoveKeyboardInputProviderAcquireFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque le fournisseur d’entrée au clavier acquiert le focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_KeyboardInputProviderAcquireFocus"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocusEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocus>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyboardInputProviderAcquireFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyboardInputProviderAcquireFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyboardInputProviderAcquireFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyboardInputProviderAcquireFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyboardInputProviderAcquireFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyboardInputProviderAcquireFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="see AddKeyDownHandler, and RemoveKeyDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddKeyDownHandler, and RemoveKeyDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.KeyDown" />
      <MemberSignature Language="VB.NET" Value="see AddKeyDownHandler, and RemoveKeyDownHandler" />
      <MemberSignature Language="F#" Value="see AddKeyDownHandler, and RemoveKeyDownHandler" Usage="see AddKeyDownHandler, and RemoveKeyDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand l’utilisateur appuie sur une touche du clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.KeyDownEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Keyboard.PreviewKeyDown>.  
  
   
  
## Examples  
 L’exemple suivant crée <xref:System.Windows.Controls.TextBox> qui attache un gestionnaire d’événements pour le <xref:System.Windows.UIElement.KeyDown> événement.  Lorsque le <xref:System.Windows.Input.Key.Return> est enfoncée, l’événement gestionnaire affiche le texte dans le <xref:System.Windows.Controls.TextBox> dans un <xref:System.Windows.Controls.TextBlock>.  
  
 [!code-xml[keydown#KeyDownUI](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyDown/CSharp/Window1.xaml#keydownui)]  
  
 [!code-csharp[keydown#KeyDownSample](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyDown/CSharp/Window1.xaml.cs#keydownsample)]
 [!code-vb[keydown#KeyDownSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyDown/VisualBasic/Window1.xaml.vb#keydownsample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.KeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="see AddKeyUpHandler, and RemoveKeyUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddKeyUpHandler, and RemoveKeyUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.KeyUp" />
      <MemberSignature Language="VB.NET" Value="see AddKeyUpHandler, and RemoveKeyUpHandler" />
      <MemberSignature Language="F#" Value="see AddKeyUpHandler, and RemoveKeyUpHandler" Usage="see AddKeyUpHandler, and RemoveKeyUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand l’utilisateur relâche une touche du clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.KeyUpEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Keyboard.PreviewKeyUp>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.KeyUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="see AddLostKeyboardFocusHandler, and RemoveLostKeyboardFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostKeyboardFocusHandler, and RemoveLostKeyboardFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="see AddLostKeyboardFocusHandler, and RemoveLostKeyboardFocusHandler" />
      <MemberSignature Language="F#" Value="see AddLostKeyboardFocusHandler, and RemoveLostKeyboardFocusHandler" Usage="see AddLostKeyboardFocusHandler, and RemoveLostKeyboardFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand un élément perd le focus clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Le focus clavier fait référence à l’objet qui reçoit l’entrée au clavier. L’élément ayant le focus clavier a <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> défini sur `true`.  Il peut y avoir qu’un seul élément ayant le focus clavier sur l’intégralité du bureau.  Le focus logique fait référence à l’objet dans une portée de focus qui a le focus.  Pour plus d’informations sur le focus, le focus clavier et le focus logique, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md) et [vue d’ensemble du Focus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 Si le <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus> événement ou la <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus> est géré, le focus clavier ne change pas.  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.LostKeyboardFocusEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.TextBox> et attache les gestionnaires d’événements pour le <xref:System.Windows.UIElement.GotKeyboardFocus> événement et le <xref:System.Windows.Input.Keyboard.LostKeyboardFocus> événement.  Lorsque le <xref:System.Windows.Controls.TextBox> Obtient le focus clavier, la couleur d’arrière-plan est modifiée et le texte de la <xref:System.Windows.Controls.TextBox> est désactivée.  Lorsque le <xref:System.Windows.Controls.TextBlock> perd le focus clavier, la couleur d’arrière-plan est modifiée et une méthode est appelée et réinitialise les variables utilisées dans l’exemple.  
  
 [!code-xml[keyboardsample#KeyboardSampleXAMLHandlerHookup](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyboardSample/CSharp/Window1.xaml#keyboardsamplexamlhandlerhookup)]  
  
 [!code-csharp[keyboardsample#KeyboardSampleGotFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyboardSample/CSharp/Window1.xaml.cs#keyboardsamplegotfocus)]
 [!code-vb[keyboardsample#KeyboardSampleGotFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyboardSample/visualbasic/window1.xaml.vb#keyboardsamplegotfocus)]  
  
 [!code-csharp[keyboardsample#KeyboardSampleLostFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyboardSample/CSharp/Window1.xaml.cs#keyboardsamplelostfocus)]
 [!code-vb[keyboardsample#KeyboardSampleLostFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyboardSample/visualbasic/window1.xaml.vb#keyboardsamplelostfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Modifiers">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.ModifierKeys Modifiers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.ModifierKeys Modifiers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Keyboard.Modifiers" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Modifiers As ModifierKeys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::ModifierKeys Modifiers { System::Windows::Input::ModifierKeys get(); };" />
      <MemberSignature Language="F#" Value="member this.Modifiers : System.Windows.Input.ModifierKeys" Usage="System.Windows.Input.Keyboard.Modifiers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ModifierKeys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le jeu de <see cref="T:System.Windows.Input.ModifierKeys" /> qui est actuellement enfoncé.</summary>
        <value>Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Input.ModifierKeys" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.ModifierKeys> est un peu énumération de champ, il est donc possible de plusieurs touches de modification à enfoncer en même temps.  Utilisez des opérations de bits pour déterminer l’ensemble exact de touches de modification enfoncées.  
  
   
  
## Examples  
 L’exemple suivant utilise un peu de comparaison pour déterminer si le <xref:System.Windows.Input.ModifierKeys.Control> touche est enfoncée.  
  
 [!code-csharp[keyargssnippetsample#KeyboardModifiersBitOperation](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyboardmodifiersbitoperation)]
 [!code-vb[keyargssnippetsample#KeyboardModifiersBitOperation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyboardmodifiersbitoperation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="see AddPreviewGotKeyboardFocusHandler, and RemovePreviewGotKeyboardFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewGotKeyboardFocusHandler, and RemovePreviewGotKeyboardFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewGotKeyboardFocusHandler, and RemovePreviewGotKeyboardFocusHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewGotKeyboardFocusHandler, and RemovePreviewGotKeyboardFocusHandler" Usage="see AddPreviewGotKeyboardFocusHandler, and RemovePreviewGotKeyboardFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand un élément est sur le point d’acquérir le focus clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Si le <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus> événement ou la <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus> est géré, le focus clavier ne change pas.  
  
 Le focus clavier fait référence à l’objet qui reçoit l’entrée au clavier. L’élément ayant le focus clavier a <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> défini sur `true`.  Il peut y avoir qu’un seul élément ayant le focus clavier sur l’intégralité du bureau.  Le focus logique fait référence à l’objet dans une portée de focus qui a le focus.  Pour plus d’informations sur le focus, le focus clavier et le focus logique, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md) et [vue d’ensemble du Focus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
<a name="routedEventInfo_PreviewGotKeyborad"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocusEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Keyboard.GotKeyboardFocus>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyboardInputProviderAcquireFocus">
      <MemberSignature Language="C#" Value="see AddPreviewKeyboardInputProviderAcquireFocusHandler, and RemovePreviewKeyboardInputProviderAcquireFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewKeyboardInputProviderAcquireFocusHandler, and RemovePreviewKeyboardInputProviderAcquireFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocus" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewKeyboardInputProviderAcquireFocusHandler, and RemovePreviewKeyboardInputProviderAcquireFocusHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewKeyboardInputProviderAcquireFocusHandler, and RemovePreviewKeyboardInputProviderAcquireFocusHandler" Usage="see AddPreviewKeyboardInputProviderAcquireFocusHandler, and RemovePreviewKeyboardInputProviderAcquireFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque le fournisseur d’entrée au clavier est en cours d’acquisition du focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewKeyboardInputProviderAcquireFocus"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocusEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocus>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyboardInputProviderAcquireFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyboardInputProviderAcquireFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyboardInputProviderAcquireFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyboardInputProviderAcquireFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyboardInputProviderAcquireFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyboardInputProviderAcquireFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="see AddPreviewKeyDownHandler, and RemovePreviewKeyDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewKeyDownHandler, and RemovePreviewKeyDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewKeyDownHandler, and RemovePreviewKeyDownHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewKeyDownHandler, and RemovePreviewKeyDownHandler" Usage="see AddPreviewKeyDownHandler, and RemovePreviewKeyDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand l’utilisateur appuie sur une touche du clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.PreviewKeyDownEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Keyboard.KeyDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="see AddPreviewKeyUpHandler, and RemovePreviewKeyUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewKeyUpHandler, and RemovePreviewKeyUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewKeyUpHandler, and RemovePreviewKeyUpHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewKeyUpHandler, and RemovePreviewKeyUpHandler" Usage="see AddPreviewKeyUpHandler, and RemovePreviewKeyUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand l’utilisateur relâche une touche du clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.PreviewKeyUpEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Keyboard.KeyUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="see AddPreviewLostKeyboardFocusHandler, and RemovePreviewLostKeyboardFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewLostKeyboardFocusHandler, and RemovePreviewLostKeyboardFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewLostKeyboardFocusHandler, and RemovePreviewLostKeyboardFocusHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewLostKeyboardFocusHandler, and RemovePreviewLostKeyboardFocusHandler" Usage="see AddPreviewLostKeyboardFocusHandler, and RemovePreviewLostKeyboardFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit quand un élément est en train de perdre le focus clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Si le <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus> événement ou la <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus> est géré, le focus clavier ne change pas.  
  
 Le focus clavier fait référence à l’objet qui reçoit l’entrée au clavier. L’élément ayant le focus clavier a <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> défini sur `true`.  Il peut y avoir qu’un seul élément ayant le focus clavier sur l’intégralité du bureau.  Le focus logique fait référence à l’objet dans une portée de focus qui a le focus.  Pour plus d’informations sur le focus, le focus clavier et le focus logique, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md) et [vue d’ensemble du Focus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocusEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Keyboard.LostKeyboardFocus>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Keyboard.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Keyboard.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryDevice">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.KeyboardDevice PrimaryDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.KeyboardDevice PrimaryDevice" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Keyboard.PrimaryDevice" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PrimaryDevice As KeyboardDevice" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::KeyboardDevice ^ PrimaryDevice { System::Windows::Input::KeyboardDevice ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryDevice : System.Windows.Input.KeyboardDevice" Usage="System.Windows.Input.Keyboard.PrimaryDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le périphérique d’entrée au clavier principal.</summary>
        <value>Périphérique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété prend en charge l'infrastructure [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] et n'est pas destinée à être directement utilisée à partir de votre code.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyboardDevice" />
      </Docs>
    </Member>
    <Member MemberName="RemoveGotKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemoveGotKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemoveGotKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveKeyboardInputProviderAcquireFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveKeyboardInputProviderAcquireFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveKeyboardInputProviderAcquireFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemoveKeyboardInputProviderAcquireFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveKeyboardInputProviderAcquireFocusHandler (element As DependencyObject, handler As KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveKeyboardInputProviderAcquireFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardInputProviderAcquireFocusEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveKeyboardInputProviderAcquireFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemoveKeyboardInputProviderAcquireFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.KeyboardInputProviderAcquireFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveKeyDownHandler">
      <MemberSignature Language="C#" Value="public static void RemoveKeyDownHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveKeyDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemoveKeyDownHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveKeyDownHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveKeyDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveKeyDownHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemoveKeyDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveKeyUpHandler">
      <MemberSignature Language="C#" Value="public static void RemoveKeyUpHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveKeyUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemoveKeyUpHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveKeyUpHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveKeyUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveKeyUpHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemoveKeyUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemoveLostKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemoveLostKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewGotKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewGotKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewGotKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemovePreviewGotKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewGotKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewGotKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewGotKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemovePreviewGotKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewKeyboardInputProviderAcquireFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewKeyboardInputProviderAcquireFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewKeyboardInputProviderAcquireFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemovePreviewKeyboardInputProviderAcquireFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewKeyboardInputProviderAcquireFocusHandler (element As DependencyObject, handler As KeyboardInputProviderAcquireFocusEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewKeyboardInputProviderAcquireFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardInputProviderAcquireFocusEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewKeyboardInputProviderAcquireFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemovePreviewKeyboardInputProviderAcquireFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.PreviewKeyboardInputProviderAcquireFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewKeyDownHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewKeyDownHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewKeyDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemovePreviewKeyDownHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewKeyDownHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewKeyDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewKeyDownHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemovePreviewKeyDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewKeyUpHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewKeyUpHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewKeyUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemovePreviewKeyUpHandler(System.Windows.DependencyObject,System.Windows.Input.KeyEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewKeyUpHandler (element As DependencyObject, handler As KeyEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewKeyUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewKeyUpHandler : System.Windows.DependencyObject * System.Windows.Input.KeyEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemovePreviewKeyUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewLostKeyboardFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewLostKeyboardFocusHandler (System.Windows.DependencyObject element, System.Windows.Input.KeyboardFocusChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewLostKeyboardFocusHandler(class System.Windows.DependencyObject element, class System.Windows.Input.KeyboardFocusChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Keyboard.RemovePreviewLostKeyboardFocusHandler(System.Windows.DependencyObject,System.Windows.Input.KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewLostKeyboardFocusHandler (element As DependencyObject, handler As KeyboardFocusChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewLostKeyboardFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::KeyboardFocusChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewLostKeyboardFocusHandler : System.Windows.DependencyObject * System.Windows.Input.KeyboardFocusChangedEventHandler -&gt; unit" Usage="System.Windows.Input.Keyboard.RemovePreviewLostKeyboardFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.KeyboardFocusChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d’événements à supprimer.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus" /> événement attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des accesseurs de propriété jointe pour l’accès du code à la <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> événement attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>