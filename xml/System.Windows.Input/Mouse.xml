<Type Name="Mouse" FullName="System.Windows.Input.Mouse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b74c1fc91dbccb0eaeef3d5dc5f2451716a7a24f" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65004677" /></Metadata><TypeSignature Language="C#" Value="public static class Mouse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Mouse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.Mouse" />
  <TypeSignature Language="VB.NET" Value="Public Class Mouse" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mouse abstract sealed" />
  <TypeSignature Language="F#" Value="type Mouse = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente la souris pour un thread spécifique.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.Mouse> fournit la classe de souris des événements, méthodes et propriétés qui fournissent des informations concernant l’état de la souris associés.  
  
 Chaque événement qui <xref:System.Windows.Input.Mouse> définit comme un événement attaché est a également été ré-exposé par les classes d’élément de base <xref:System.Windows.UIElement> et <xref:System.Windows.ContentElement> en tant qu’un nouvel événement routé. En règle générale, il est plus pratique gérer les événements de souris pour une application <xref:System.Windows.UIElement> et <xref:System.Windows.ContentElement>, au lieu d’utiliser le <xref:System.Windows.Input.Mouse> événements. Pour plus d’informations, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Les membres statiques de la <xref:System.Windows.Input.Mouse> délégué vers le serveur principal de la classe <xref:System.Windows.Input.MouseDevice> de gestionnaire d’entrée du thread appelant.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseDown" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseMove" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseUp" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void AddQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Ajoute un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Capture">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Capture l'entrée de la souris à l'élément spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un élément capture la souris, il reçoit l’entrée de la souris si le curseur se trouve dans ses limites.  
  
 Si un <xref:System.Windows.Input.CaptureMode> n’est pas spécifié, la valeur par défaut <xref:System.Windows.Input.CaptureMode> est <xref:System.Windows.Input.CaptureMode.Element>.  
  
 Pour libérer la capture de la souris, appelez <xref:System.Windows.Input.Mouse.Capture%2A> passant `null` comme élément à capturer.  
  
 Si la souris est capturée lorsqu’un <xref:System.Windows.Input.Mouse.MouseDown> ou <xref:System.Windows.Input.Mouse.MouseUp> événement est déclenché et l’entrée ne va pas à l’élément sous la souris, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> et <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> sont déclenchés en premier.  Cela permet à l’élément une chance de capture avant de libérer le <xref:System.Windows.Input.Mouse.MouseDown> et <xref:System.Windows.Input.Mouse.MouseUp> les événements sont routés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement -&gt; bool" Usage="System.Windows.Input.Mouse.Capture element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Élément pour capturer la souris.</param>
        <summary>Capture l'entrée de la souris à l'élément spécifié.</summary>
        <returns><see langword="true" /> si l'élément a pu capturer la souris ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un élément capture la souris, il reçoit l’entrée de la souris si le curseur se trouve dans ses limites.  
  
 Si un <xref:System.Windows.Input.CaptureMode> n’est pas spécifié, la valeur par défaut <xref:System.Windows.Input.CaptureMode> est <xref:System.Windows.Input.CaptureMode.Element>.  
  
 Pour libérer la capture de la souris, appelez <xref:System.Windows.Input.Mouse.Capture%2A> passant `null` comme élément à capturer.  
  
 Si la souris est capturée lorsqu’un <xref:System.Windows.Input.Mouse.MouseDown> ou <xref:System.Windows.Input.Mouse.MouseUp> événement est déclenché et l’entrée ne va pas à l’élément sous la souris, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> et <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> sont déclenchés en premier.  Cela permet à l’élément une chance de capture avant de libérer le <xref:System.Windows.Input.Mouse.MouseDown> et <xref:System.Windows.Input.Mouse.MouseUp> les événements sont routés.  
  
   
  
## Examples  
 L’exemple suivant montre comment capturer la souris pour un élément spécifique à l’aide de la <xref:System.Windows.Input.Mouse.Capture%2A> (méthode).  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element, System.Windows.Input.CaptureMode captureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element, valuetype System.Windows.Input.CaptureMode captureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement,System.Windows.Input.CaptureMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element, System::Windows::Input::CaptureMode captureMode);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement * System.Windows.Input.CaptureMode -&gt; bool" Usage="System.Windows.Input.Mouse.Capture (element, captureMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="captureMode" Type="System.Windows.Input.CaptureMode" />
      </Parameters>
      <Docs>
        <param name="element">Élément pour capturer la souris.</param>
        <param name="captureMode">Stratégie de capture à utiliser.</param>
        <summary>Capture l'entrée de la souris à l'élément spécifié à l'aide du <see cref="T:System.Windows.Input.CaptureMode" />spécifié.</summary>
        <returns><see langword="true" /> si l'élément a pu capturer la souris ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un élément capture la souris, il reçoit l’entrée de la souris si le curseur se trouve dans ses limites.  
  
 Pour libérer la capture de la souris, appelez <xref:System.Windows.Input.Mouse.Capture%2A> passant `null` comme élément à capturer.  
  
 Si la souris est capturée lorsqu’un <xref:System.Windows.Input.Mouse.MouseDown> ou <xref:System.Windows.Input.Mouse.MouseUp> événement est déclenché et l’entrée ne va pas à l’élément sous la souris, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> et <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> sont déclenchés en premier.  Cela permet à l’élément une chance de capture avant de libérer le <xref:System.Windows.Input.Mouse.MouseDown> et <xref:System.Windows.Input.Mouse.MouseUp> les événements sont routés.  
  
   
  
## Examples  
 L’exemple suivant montre comment capturer la souris pour un élément spécifique à l’aide de la <xref:System.Windows.Input.Mouse.Capture%2A> (méthode).  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Captured">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement Captured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement Captured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.Captured" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Captured As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ Captured { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Captured : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.Captured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'élément qui a capturé la souris.</summary>
        <value>Élément capturé par la souris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un élément capture la souris, il reçoit l’entrée de la souris si le curseur se trouve dans ses limites. La souris est généralement capturée de cette manière uniquement pendant les opérations de glisser-déplacer et ce jusqu'à la fin de l’opération de glisser-déplacer, l’action de déplacement.  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir l’élément qui possède la capture de la souris.  
  
 [!code-csharp[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecapturemousecaptured)]
 [!code-vb[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecapturemousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyOver">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement DirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement DirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.DirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DirectlyOver As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ DirectlyOver { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectlyOver : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.DirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'élément sur lequel se trouve le pointeur de la souris.</summary>
        <value>Élément au dessus duquel se trouve le pointeur de la souris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les contrôles peuvent être composés de plusieurs éléments. <xref:System.Windows.Input.Mouse.DirectlyOver%2A> signale l’élément spécifique dans le contrôle composite, sur que le pointeur de la souris est et non le contrôle lui-même. Par exemple, en fonction de quelle partie d’un <xref:System.Windows.Controls.Button> le pointeur est terminé, le <xref:System.Windows.Input.Mouse.DirectlyOver%2A> propriété peut générer un rapport le <xref:System.Windows.Controls.TextBox> de la <xref:System.Windows.Controls.ContentControl.Content%2A> propriété ou le <xref:Microsoft.Windows.Themes.ButtonChrome>.  
  
 Utilisez le <xref:System.Windows.IInputElement.IsMouseOver%2A> propriété sur <xref:System.Windows.UIElement> et <xref:System.Windows.ContentElement> pour déterminer si la souris est au-dessus d’un élément, ce qui inclut ses éléments enfants visuels ou de composition du contrôle.  
  
 Si un élément a la capture de la souris, le pointeur de la souris est considéré comme directement au-dessus de l’élément, quel que soit l’emplacement où est le pointeur de la souris.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseOver" />
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="GetIntermediatePoints">
      <MemberSignature Language="C#" Value="public static int GetIntermediatePoints (System.Windows.IInputElement relativeTo, System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetIntermediatePoints(class System.Windows.IInputElement relativeTo, valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetIntermediatePoints(System.Windows.IInputElement,System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIntermediatePoints (relativeTo As IInputElement, points As Point()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetIntermediatePoints(System::Windows::IInputElement ^ relativeTo, cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="static member GetIntermediatePoints : System.Windows.IInputElement * System.Windows.Point[] -&gt; int" Usage="System.Windows.Input.Mouse.GetIntermediatePoints (relativeTo, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Les éléments <paramref name="points" /> sont liés.</param>
        <param name="points">Tableau d'objets.</param>
        <summary>Récupère jusqu'à 64 coordonnées précédentes du pointeur de la souris depuis le dernier événement de déplacement de la souris.</summary>
        <returns>Nombre de points retournés.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPosition">
      <MemberSignature Language="C#" Value="public static System.Windows.Point GetPosition (System.Windows.IInputElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point GetPosition(class System.Windows.IInputElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetPosition(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPosition (relativeTo As IInputElement) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point GetPosition(System::Windows::IInputElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="static member GetPosition : System.Windows.IInputElement -&gt; System.Windows.Point" Usage="System.Windows.Input.Mouse.GetPosition relativeTo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Espace de coordonnées dans lequel calculer la position de la souris.</param>
        <summary>Obtient la position de la souris par rapport à un élément spécifié.</summary>
        <returns>Position de la souris par rapport au paramètre <paramref name="relativeTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La position du pointeur de la souris est calculée par rapport à l’élément spécifié avec le coin supérieur gauche de l’élément qui est le point d’origine, 0,0.  
  
 Lors des opérations de glisser-déplacer, la position de la souris ne peut pas être déterminée de manière fiable via <xref:System.Windows.Input.Mouse.GetPosition%2A>. Il s’agit, car le contrôle de la souris (pouvant inclure la capture) est maintenu par l’élément d’origine de l’opération glisser jusqu'à la fin de la liste déroulante, en grande partie le comportement contrôlé par sous-jacent [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] appels. Essayez plutôt les approches suivantes :  
  
-   Appelez le <xref:System.Windows.DragEventArgs.GetPosition%2A> méthode de la <xref:System.Windows.DragEventArgs> qui est passé aux événements glisser (<xref:System.Windows.ContentElement.DragEnter>, <xref:System.Windows.ContentElement.DragOver>, <xref:System.Windows.ContentElement.DragLeave>).  
  
-   Appelez [GetCursorPos http://msdn.Microsoft.com/fr-fr/library/ms648390](https://msdn.microsoft.com/library/default.asp?url=/library/winui/winui/windowsuserinterface/resources/cursors/cursorreference/cursorfunctions/getcursorpos.asp), à l’aide de P/Invoke.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Windows.Input.Mouse.GetPosition%2A> pour déterminer la position du pointeur de la souris.  La position du pointeur de la souris est stockée dans un <xref:System.Windows.Point> structure.  Le <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> les valeurs de la <xref:System.Windows.Point> objet sont affichés dans un <xref:System.Windows.Controls.TextBox>.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetspositionmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetspositionmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.MouseEventArgs.GetPosition(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" Usage="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsqu'un élément capture la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un élément capture la souris, il reçoit l’entrée de la souris si le curseur se trouve dans ses limites.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 En raison du routage par propagation, l’élément réel qui a la capture peut être un élément enfant, mais pas nécessairement l’élément où le Gestionnaire d’événements est en fait attaché. Vérifier le <xref:System.Windows.RoutedEventArgs.Source%2A> de l’événement capture les arguments pour déterminer l’élément qui a la souris.  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.GotMouseCaptureEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Il n’existe aucun événement de tunneling correspondant défini.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState LeftButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState LeftButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.LeftButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LeftButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState LeftButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.LeftButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.LeftButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état du bouton gauche de la souris.</summary>
        <value>État du bouton gauche de la souris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment déterminer si le bouton gauche de la souris est enfoncé en vérifiant si l’état de la <xref:System.Windows.Input.Mouse.LeftButton%2A> est égale à la <xref:System.Windows.Input.MouseButtonState> valeur d’énumération <xref:System.Windows.Input.MouseButtonState.Pressed>.  Si le bouton est enfoncé, une méthode est appelée, les mises à jour affichent les éléments dans l’exemple.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" Usage="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsqu'un élément perd la capture de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un élément capture la souris, il reçoit l’entrée de la souris si le curseur se trouve dans ses limites. T  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 En raison du routage par propagation, l’élément réel qui perd la capture peut être un élément enfant, mais pas nécessairement l’élément où le Gestionnaire d’événements est en fait attaché. Vérifiez le <xref:System.Windows.RoutedEventArgs.Source%2A> dans les arguments d’événement pour déterminer l’élément réel qui perd la capture.  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.LostMouseCaptureEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Il n’existe aucun événement de tunneling correspondant défini.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MiddleButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState MiddleButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState MiddleButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.MiddleButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MiddleButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState MiddleButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.MiddleButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.MiddleButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état du bouton central de la souris.</summary>
        <value>État du bouton central de la souris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment déterminer si le bouton central de la souris est enfoncé en vérifiant si l’état de la <xref:System.Windows.Input.Mouse.MiddleButton%2A> est égale à la <xref:System.Windows.Input.MouseButtonState> valeur d’énumération <xref:System.Windows.Input.MouseButtonState.Pressed>.  Si le bouton est enfoncé, une méthode est appelée, les mises à jour affichent les éléments dans l’exemple.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetmiddlebuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetmiddlebuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" Usage="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsqu'un bouton de la souris est enfoncé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer quel bouton de la souris a été enfoncé, vérifiez le <xref:System.Windows.Input.MouseButtonEventArgs.ChangedButton%2A> propriété dans le <xref:System.Windows.Input.MouseButtonEventArgs> passé au gestionnaire.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework s’appuie sur cet événement attaché signale comme deux [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] événements sur <xref:System.Windows.UIElement> et <xref:System.Windows.ContentElement>: <xref:System.Windows.UIElement.MouseLeftButtonDown> et <xref:System.Windows.UIElement.MouseRightButtonDown>. Ces implémentations gèrent sous-jacent <xref:System.Windows.Input.Mouse.MouseDown> événement et lire les arguments de l’événement pour déterminer si le bouton gauche ou droit de la souris a été impliqué. Pour une souris à trois boutons, il n’existe aucune prise en charge des événements au niveau du framework pour le bouton central. Vous devez utiliser le <xref:System.Windows.Input.Mouse.MouseDown> événement et vérifiez la <xref:System.Windows.Input.MouseEventArgs.MiddleButton%2A> arguments de l’événement d’état.  
  
> [!IMPORTANT]
>  Quelques <xref:System.Windows.ContentElement> dérivées des classes qui ont le comportement de type contrôle, par exemple, <xref:System.Windows.Documents.Hyperlink>, peut-être inhérente gestion de classe pour les événements de bouton de la souris. La pression du bouton gauche de la souris est le plus probable pour que la gestion de classe dans un contrôle. La gestion souvent de classe marque sous-jacent <xref:System.Windows.Input.Mouse> événement de classe comme étant géré. Une fois que l’événement est marqué comme géré, les autres gestionnaires d’instance qui sont attachés à cet élément ne sont généralement pas déclenchés. N’importe quel autres instance ou la classe gestionnaires d’associés aux éléments dans la direction de propagation vers la racine dans l’arborescence de l’interface utilisateur sont également pas généralement déclenchés.  
  
 Vous pouvez résoudre le problème décrit dans la Remarque importante précédente et recevez toujours <xref:System.Windows.UIElement.MouseDown> événements pour le bouton gauche de la souris vers le bas sur une classe dérivée qui a l’aide d’une de ces solutions de gestion de classe :  
  
-   Joindre des gestionnaires pour les <xref:System.Windows.UIElement.PreviewMouseDown> événement, qui n’est pas marqué comme géré par les contrôles. Notez que, comme il s’agit d’un événement d’aperçu, l’itinéraire démarre à la racine et tunnels au contrôle.  
  
-   Enregistrez un gestionnaire sur le contrôle en appelant <xref:System.Windows.UIElement.AddHandler%2A> et en choisissant l’option de signature qui permet aux gestionnaires d’écouter des événements même s’ils sont déjà marqués comme gérés dans les données d’événement routé.  
  
 Pour les événements routés qui se rapportent à la souris, veillez à comment ou quand vous les marquer comme gérés. La difficulté de faire les choix appropriés si éléments parents doivent également être informés chaque action de la souris en fait, pourquoi le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework a choisi le l’événement de souris routée sous-jacent être exposés en tant que [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] événements le long de l’itinéraire. Il existe des problèmes similaires avec le tunneling des événements de souris.  Doit gérer l’événement et ne pas être gérée par les autres enfants en direction de la source, et quel serait l’impact sur composition un contrôle dont les éléments peuvent attendre des comportements de souris ?  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.MouseDownEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Mouse.PreviewMouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.MouseDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="F#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" Usage="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque le pointeur de la souris pénètre dans les limites d'un élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Cet événement utilise la gestion de stratégie de routage d’événement direct. Les événements routés directs ne sont pas déclenchés sur un itinéraire (ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés).  Ils ne, toutefois, activent les autres aspects de comportements de l’événement routé, telles que les déclencheurs d’événements dans les styles.  
  
 Bien que cet événement est utilisé pour effectuer le suivi lorsque la souris entre dans un élément, il signale également le <xref:System.Windows.UIElement.IsMouseOver%2A> propriété a été modifiée à partir de `false` à `true` sur cet élément.  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.MouseEnterEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.MouseEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" Usage="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque le pointeur de la souris quitte les limites d'un élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Cet événement utilise la gestion de stratégie de routage d’événement direct. Les événements routés directs ne suivent pas un itinéraire (ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés).  Ils ne, toutefois, activent les autres aspects de comportements de l’événement routé, telles que les déclencheurs d’événements dans les styles.  
  
 Bien que cet événement est utilisé pour effectuer le suivi lorsque la souris quitte un élément, il signale également que la <xref:System.Windows.UIElement.IsMouseOver%2A> valeur de propriété est devenue `true` à `false` sur cet élément.  
  
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.MouseLeaveEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.MouseLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" Usage="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque le pointeur de la souris se déplace.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.MouseMoveEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Mouse.PreviewMouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.MouseMove" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" Usage="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsqu’un bouton de la souris est relâché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bouton de la souris a été publiée est déterminée en vérifiant les arguments de l’événement.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework s’appuie sur cet événement attaché signale comme deux [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] événements sur <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.MouseLeftButtonUp> et <xref:System.Windows.UIElement.MouseRightButtonUp>. Ces implémentations gèrent sous-jacent <xref:System.Windows.Input.Mouse.MouseUp> événement et lire les arguments de l’événement pour déterminer si le bouton gauche ou droit de la souris a été impliqué. Pour les trois boutons, il n’existe aucune prise en charge des événements au niveau du framework pour le bouton central, et vous devez utiliser le <xref:System.Windows.Input.Mouse.MouseUp> événements et recherchez le bouton central de condition de l’événement arguments.  
  
 Pour les événements routés qui se rapportent à la souris, veillez à comment ou quand vous les marquer comme gérés. La difficulté de faire les choix appropriés si éléments parents doivent également être informés chaque action de la souris en fait, pourquoi le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework a choisi le modèle sous-jacents <xref:System.Windows.Input.Mouse> événement routé être exposés en tant que [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] événements long de l’itinéraire.  
  
 Il existe des problèmes similaires avec le tunneling des événements de souris.  Doit gérer l’événement et ne pas être gérée par les autres enfants en direction de la source, et quel serait l’impact sur composition dans un contrôle dont les éléments peuvent attendre des comportements de souris ?  
  
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.MouseUpEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 L’événement de tunneling correspondant est <xref:System.Windows.Input.Mouse.PreviewMouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.MouseUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" Usage="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque la roulette de la souris est actionnée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capture le focus ou de la souris sont prioritaires sur où le pointeur de la souris est.  Si vous recevez cet événement à partir d’un élément ayant le focus ou la capture, le pointeur de la souris peut en fait être sur un autre élément en temps.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.MouseWheelEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   L’événement de tunneling correspondant est <xref:System.Windows.Input.Mouse.PreviewMouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelDeltaForOneLine">
      <MemberSignature Language="C#" Value="public const int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MouseWheelDeltaForOneLine = (120)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberSignature Language="VB.NET" Value="Public Const MouseWheelDeltaForOneLine As Integer  = 120" />
      <MemberSignature Language="C++ CLI" Value="public: int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="F#" Value="val mutable MouseWheelDeltaForOneLine : int" Usage="System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>120</MemberValue>
      <Docs>
        <summary>Représente le nombre d'unités de déplacement de la roulette de la souris pour faire défiler une ligne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le courant [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)], la valeur de ce champ est 120. L’intention de l’exposition du champ est de permettre aux fournisseurs générer la molette de souris de résolution à l’avenir, notamment peut-être un défilement libre sans crans. L’attente est que ce périphérique envoie davantage de messages par rotation, mais avec une valeur inférieure dans chaque message. Pour prendre en charge cette éventualité, vous devez ajouter les valeurs delta entrantes jusqu'à ce que le <xref:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine> écoulé (de sorte que pour une rotation delta, vous obtenez la même réponse), ou faites défiler les lignes partielles en réponse aux messages plus fréquents. Vous pouvez également choisir votre propre granularité de défilement et cumuler les deltas de votre choix jusqu'à ce que ce delta est atteinte, ou peut-être référencer des paramètres système contrôlable par l’utilisateur pour la sensibilité de la souris et d’extrapoler ces seuils de delta de roulette de la souris.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseWheelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.MouseWheel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverrideCursor">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.Cursor OverrideCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.Cursor OverrideCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.OverrideCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OverrideCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::Cursor ^ OverrideCursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OverrideCursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.Input.Mouse.OverrideCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le curseur pour toute l'application.</summary>
        <value>Curseur de remplacement ou <see langword="null" /> si le <see cref="P:System.Windows.Input.Mouse.OverrideCursor" /> n'est pas défini.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.Cursor> qui <xref:System.Windows.Input.Mouse.OverrideCursor%2A> est défini sur s’appliqueront à l’application entière.  
  
 Pour effacer le remplacement <xref:System.Windows.Input.Cursor>, affectez la valeur <xref:System.Windows.Input.Mouse.OverrideCursor%2A> à `null`.  
  
 Paramètre <xref:System.Windows.Input.Mouse.OverrideCursor%2A> à <xref:System.Windows.Input.Cursors.None%2A> force le curseur de souris ne pas à afficher, mais les événements de souris sont toujours traités.  
  
   
  
## Examples  
 L’exemple suivant montre un gestionnaire d’événements pour un <xref:System.Windows.Controls.RadioButton> qui est utilisé pour activer/désactiver l’étendue d’un changement de curseur entre un élément unique et l’application entière.  Si le contrôle qui a déclenché l’événement est le `rbScopeElement` <xref:System.Windows.Controls.RadioButton>, un indicateur qui signale la portée de la modification de curseur est défini et <xref:System.Windows.Input.Mouse.OverrideCursor%2A> est défini sur `null`.  Si le contrôle qui a déclenché l’événement est le `rbScopeApplication` <xref:System.Windows.Controls.RadioButton>, un indicateur qui signale la portée de la modification de curseur est défini et <xref:System.Windows.Input.Mouse.OverrideCursor%2A> est défini sur le <xref:System.Windows.FrameworkElement.Cursor%2A> propriété de la <xref:System.Windows.Controls.Border> contrôle nommé `DisplayArea`.  
  
 [!code-csharp[cursors#CursorsSampleOverrideCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#cursorssampleoverridecursor)]
 [!code-vb[cursors#CursorsSampleOverrideCursor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#cursorssampleoverridecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" Usage="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsqu'un bouton de la souris est enfoncé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bouton de la souris a été enfoncé est déterminé en vérifiant les arguments de l’événement. Il s’agit d’un événement attaché (à l’aide de la stratégie de routage de tunneling) qui vise à référencer par existant via la syntaxe de l’événement attaché [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] éléments qui acceptent une entrée.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework s’appuie sur cet événement attaché signale comme deux [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] événements sur <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> et <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>. Ces implémentations gèrent sous-jacent <xref:System.Windows.Input.Mouse.PreviewMouseDown> événement et lire les arguments de l’événement pour déterminer si le bouton gauche ou droit de la souris a été impliqué. Pour les trois boutons, il n’existe aucune prise en charge des événements au niveau du framework pour le bouton central, et vous devez utiliser le <xref:System.Windows.Input.Mouse.PreviewMouseDown> événements et recherchez le bouton central de condition de l’événement arguments.  
  
 Pour les événements routés qui se rapportent à la souris, veillez à comment ou quand vous les marquer comme gérés. La gestion de l’événement près de la racine et il par un enfant en direction de la source peut-être pas appropriées pour les contrôles composés, où les éléments peuvent attendre des comportements de la souris. La difficulté de faire les choix appropriés si autres éléments doivent également être informés chaque action de la souris en fait, pourquoi le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework a choisi le modèle sous-jacents <xref:System.Windows.Input.Mouse> événement routé être exposés en tant que [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] événements le long de l’itinéraire.  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.PreviewMouseDownEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Mouse.MouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" Usage="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque le bouton principal de la souris est enfoncé en dehors de l'élément qui capture des événements de souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Cet événement n’est pas remonté sur des éléments de base. Il est particulièrement important pour les auteurs de contrôles qui tente de rapprocher la capture de la souris et l’entrée de la souris dans la composition de leur contrôle.  
  
<a name="routedEventInfo_PreviewMouseDownOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" Usage="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque la souris se déplace sur un élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement produit lorsque le pointeur de la souris est déplacé qui vient d’être dans les limites de l’élément, et également lorsque le pointeur de la souris se déplace tout en restant dans les limites de l’élément.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.PreviewMouseMoveEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Mouse.MouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" Usage="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsqu’un bouton de la souris est relâché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bouton de la souris a été publiée est déterminée en vérifiant les arguments de l’événement.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework s’appuie sur cet événement attaché signale comme deux [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] événements sur <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> et <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>. Ces implémentations gèrent sous-jacent <xref:System.Windows.Input.Mouse.PreviewMouseUp> événement et lire les arguments de l’événement pour déterminer si le bouton gauche ou droit de la souris a été impliqué. Pour les trois boutons, il n’existe aucune prise en charge des événements au niveau du framework pour le bouton central, et vous devez utiliser le <xref:System.Windows.Input.Mouse.PreviewMouseUp> événements et recherchez le bouton central de condition de l’événement arguments.  
  
 Pour les événements routés qui se rapportent à la souris, veillez à comment ou quand vous les marquer comme gérés. La gestion de l’événement près de la racine et ne pas par un enfant en direction de la source peut-être pas appropriées pour les contrôles composés, où les éléments peuvent attendre des comportements de la souris. La difficulté de faire les choix appropriés si autres éléments doivent également être informés chaque action de la souris en fait, pourquoi le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework a choisi le modèle sous-jacents <xref:System.Windows.Input.Mouse> événement routé être exposés en tant que [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] événements le long de l’itinéraire.  
  
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.PreviewMouseUpEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Mouse.MouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" Usage="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque le bouton principal de la souris est relâché en dehors de l'élément qui capture des événements de souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Cet événement n’est pas remonté sur des éléments de base. Il est particulièrement important pour les auteurs de contrôles qui tente de rapprocher la capture de la souris et l’entrée de la souris dans la composition de leur contrôle.  
  
<a name="routedEventInfo_PreviewMouseUpOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Il n’existe aucun événement de propagation correspondante.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" Usage="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsque la roulette de la souris est actionnée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capture le focus ou de la souris sont prioritaires sur où se trouve le pointeur de souris ; Par conséquent, si vous recevez cet événement à partir d’un élément ayant le focus ou la capture, le pointeur de souris en fait peut-être sur un autre élément à la fois.  
  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.PreviewMouseWheelEvent>|  
|Stratégie de routage|Le tunneling|  
|délégué|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   L’événement de propagation correspondante est <xref:System.Windows.Input.Mouse.MouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryDevice">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseDevice PrimaryDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.MouseDevice PrimaryDevice" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PrimaryDevice As MouseDevice" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseDevice ^ PrimaryDevice { System::Windows::Input::MouseDevice ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryDevice : System.Windows.Input.MouseDevice" Usage="System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le périphérique souris principal.</summary>
        <value>Périphérique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété prend en charge l’infrastructure Windows Presentation Foundation et n’est pas destinée à être utilisée directement depuis votre code.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="ILAsm" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="F#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" Usage="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produit lorsqu'un élément demande le curseur actuel de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un événement attaché. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente les événements attachés en tant qu’événements routés. Événements attachés sont fondamentalement un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] concept de langage pour faire référence à des événements qui peuvent être gérés sur des objets qui ne définissent pas cet événement, ce qui [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] étend en permettant également l’événement à parcourir un itinéraire. Événements attachés n’ont pas de syntaxe de gestion directe dans le code ; Pour attacher des gestionnaires pour un événement routé dans le code, vous utilisez un ajouter désigné * méthode de gestionnaire. Pour plus d’informations, consultez [vue d’ensemble des événements attachés](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_Querycursor"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Input.Mouse.QueryCursorEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
 Il n’existe aucun événement de tunneling correspondant défini.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement attaché <see cref="E:System.Windows.Input.Mouse.QueryCursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’événements routés sont créés lorsque les événements routés sont inscrits, et le résultat est stocké en tant que champ sur la classe qui inscrit l’événement routé. Ces identificateurs contiennent un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement. Vous utilisez souvent ces identificateurs comme paramètres aux méthodes de système d’événements, pour identifier un événement routé particulier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseDown" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseMove" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseUp" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void RemoveQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> qui écoute cet événement.</param>
        <param name="handler">Gestionnaire d'événements.</param>
        <summary>Supprime un gestionnaire pour le <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> événement attaché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState RightButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState RightButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.RightButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RightButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState RightButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.RightButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.RightButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état du bouton droit.</summary>
        <value>État du bouton droit de la souris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment déterminer si le bouton droit de la souris est enfoncé en vérifiant si l’état de la <xref:System.Windows.Input.Mouse.RightButton%2A> est égale à la <xref:System.Windows.Input.MouseButtonState> valeur d’énumération <xref:System.Windows.Input.MouseButtonState.Pressed>.  Si le bouton est enfoncé, une méthode est appelée, les mises à jour affichent les éléments dans l’exemple.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetrightbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetrightbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SetCursor">
      <MemberSignature Language="C#" Value="public static bool SetCursor (System.Windows.Input.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetCursor(class System.Windows.Input.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.SetCursor(System.Windows.Input.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetCursor(System::Windows::Input::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="static member SetCursor : System.Windows.Input.Cursor -&gt; bool" Usage="System.Windows.Input.Mouse.SetCursor cursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cursor" Type="System.Windows.Input.Cursor" />
      </Parameters>
      <Docs>
        <param name="cursor">Curseur auquel définir le pointeur de souris.</param>
        <summary>Définit le pointeur de la souris sur le <see cref="T:System.Windows.Input.Cursor" /> spécifié.</summary>
        <returns><see langword="true" /> si le curseur a été défini ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le curseur défini ne s’applique pas à n’importe quel élément particulier, mais au lieu de cela, elle s’applique à toute l’application.  Par conséquent, si une fois le curseur sur que le pointeur de la souris se déplace au-dessus d’un objet qui définit le curseur, le curseur devient à nouveau.  
  
 Pour forcer le pointeur de la souris à un spécifique <xref:System.Windows.Input.Cursor> et forcer cette <xref:System.Windows.Input.Cursor> sur tous les éléments, définissez la <xref:System.Windows.Input.Mouse.OverrideCursor%2A> propriété.  
  
 Pour définir le curseur sur un élément spécifique, utilisez le <xref:System.Windows.FrameworkElement.Cursor%2A> propriété soit <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>.  Pour plus d’informations sur les éléments de base, consultez le [vue d’ensemble des éléments de Base](~/docs/framework/wpf/advanced/base-elements-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursors" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="Synchronize">
      <MemberSignature Language="C#" Value="public static void Synchronize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Synchronize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Synchronize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Synchronize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Synchronize();" />
      <MemberSignature Language="F#" Value="static member Synchronize : unit -&gt; unit" Usage="System.Windows.Input.Mouse.Synchronize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Force la resynchronisation de la souris.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
        <altmember cref="M:System.Windows.Input.Mouse.Synchronize" />
      </Docs>
    </Member>
    <Member MemberName="UpdateCursor">
      <MemberSignature Language="C#" Value="public static void UpdateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.UpdateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UpdateCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateCursor();" />
      <MemberSignature Language="F#" Value="static member UpdateCursor : unit -&gt; unit" Usage="System.Windows.Input.Mouse.UpdateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Force la mise à jour du curseur de la souris.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XButton1">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton1" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton1 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton1 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton1 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état actuel du premier bouton étendu.</summary>
        <value>État du premier bouton étendu de la souris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment déterminer si le premier bouton étendu de la souris est enfoncé en vérifiant si l’état de <xref:System.Windows.Input.Mouse.XButton1%2A> est égale à la <xref:System.Windows.Input.MouseButtonState> valeur d’énumération <xref:System.Windows.Input.MouseButtonState.Pressed>.  Si le bouton est enfoncé, une méthode est appelée, les mises à jour affichent les éléments dans l’exemple.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx1buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx1buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="XButton2">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton2" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton2 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton2 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton2 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état du deuxième bouton étendu.</summary>
        <value>État du deuxième bouton étendu de la souris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment déterminer si le deuxième bouton étendu de la souris est enfoncé en vérifiant si l’état de <xref:System.Windows.Input.Mouse.XButton2%2A> est égale à la <xref:System.Windows.Input.MouseButtonState> valeur d’énumération <xref:System.Windows.Input.MouseButtonState.Pressed>.  Si le bouton est enfoncé, une méthode est appelée, les mises à jour affichent les éléments dans l’exemple.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx2buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx2buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
  </Members>
</Type>