<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="37250b1651d5943ef4919b9ad6f4ea73ea95ee5d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65004762" /></Metadata><TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente une liaison entre un <see cref="T:System.Windows.Input.InputGesture" /> et une commande. La commande est potentiellement un <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez spécifier que l’entrée d’utilisateur appelle une commande en créant un <xref:System.Windows.Input.InputBinding>. Lorsque l’utilisateur effectue l’entrée spécifiée, le <xref:System.Windows.Input.ICommand> dont la valeur est le <xref:System.Windows.Input.InputBinding.Command%2A> propriété est exécutée.  
  
 Vous pouvez spécifier que le <xref:System.Windows.Input.InputBinding> appelle une commande qui est définie sur un objet en créant une liaison sur le <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, et <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriétés. Cela vous permet de définir une commande personnalisée et l’associer à l’entrée d’utilisateur. Pour plus d’informations, consultez le deuxième exemple dans la section Exemples.  
  
 Un <xref:System.Windows.Input.InputBinding> peut être défini sur un objet spécifique ou au niveau de la classe en enregistrant un <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> avec le <xref:System.Windows.Input.CommandManager>.  
  
 Le <xref:System.Windows.Input.InputBinding> classe lui-même ne prend pas en charge l’utilisation XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et peuvent donc définir des propriétés sur la classe dérivée qui sont héritées de <xref:System.Windows.Input.InputBinding> avec une utilisation XAML. Deux existant <xref:System.Windows.Input.InputBinding>-les classes dérivées qui peuvent être instanciées dans XAML et définir des propriétés en XAML sont <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>. La propriété classique en [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] de programmation qui est défini dans XAML et prend un ou plusieurs <xref:System.Windows.Input.InputBinding> objets sous forme de valeurs est le <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> propriété.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Utilisation d'éléments objet XAML  
 \<*inputBindingDerivedClass…/*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Input.KeyBinding> pour lier un <xref:System.Windows.Input.KeyGesture> à la <xref:System.Windows.Input.ApplicationCommands.Open%2A> commande. Lors de la combinaison de touches est effectuée, la commande Ouvrir est appelée.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 Les exemples suivants montrent comment lier une commande personnalisée à <xref:System.Windows.Input.InputBinding> objets. Ces exemples créent une application qui permet à l’utilisateur modifier la couleur d’arrière-plan en effectuant l’une des actions suivantes :  
  
-   En cliquant sur un bouton.  
  
-   En appuyant sur CTRL + C.  
  
-   Clic droit sur un <xref:System.Windows.Controls.StackPanel> (en dehors de la <xref:System.Windows.Controls.ListBox>).  
  
 Le premier exemple crée une classe nommée `SimpleDelegateCommand`. Cette classe accepte un délégué afin que l’objet de création de la commande peut définir l’action qui se produit lorsque la commande s’exécute. `SimpleDelegateCommand` définit également des propriétés qui spécifient ce que la clé et de la souris entrée appelle la commande. `GestureKey` et `GestureModifier` spécifier l’entrée de clavier ; `MouseGesture` Spécifie l’entrée de la souris.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 L’exemple suivant crée et initialise le `ColorChangeCommand`, qui est un `SimpleDelegateCommand`. L’exemple définit également la méthode qui s’exécute lorsque la commande est appelée et définit les `GestureKey`, `GestureModifier`, et `MouseGesture` propriétés. Une application appelle la `InitializeCommand` méthode lorsque le programme commence, comme dans le constructeur d’un <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Enfin, l’exemple suivant crée l’interface utilisateur. L’exemple ajoute un <xref:System.Windows.Input.KeyBinding> et un <xref:System.Windows.Input.MouseBinding> à un <xref:System.Windows.Controls.StackPanel> qui contient un <xref:System.Windows.Controls.Button> et un <xref:System.Windows.Controls.ListBox>. Lorsque l’utilisateur sélectionne un élément dans le <xref:System.Windows.Controls.ListBox>, il ou elle peut modifier la couleur d’arrière-plan pour la couleur sélectionnée. Dans chaque cas, le `CommandParameter` propriété est liée à l’élément sélectionné dans le <xref:System.Windows.Controls.ListBox>et le `Command` propriété est liée à la `ColorChangeCommand`. Le <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, et <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> propriétés sont liées aux propriétés correspondantes la `SimpleDelegateCommand` classe.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Input.InputBinding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Fournit l’initialisation de base pour les classes dérivées de <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> n’est pas techniquement une classe abstraite, mais le constructeur par défaut est délibérément un accès protégé. Cela a pour effet de rendre <xref:System.Windows.Input.InputBinding> une classe « abstract » pour XAML. Il existe des propriétés dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] qui ont des utilisations de XAML qui attendent des objets de type <xref:System.Windows.Input.InputBinding>, mais vous ne pouvez pas spécifier un <xref:System.Windows.Input.InputBinding> instance dans XAML. Au lieu de cela, vous pouvez spécifier un des spécifiques au périphérique <xref:System.Windows.Input.InputBinding> les classes dérivées en tant que valeurs, par exemple <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous implémentez un personnalisé <see cref="T:System.Windows.Input.InputBinding" /> qui prend en charge une utilisation XAML, utilisez ce constructeur pour l’initialisation de base.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">La commande à associer à <paramref name="gesture" />.</param>
        <param name="gesture">Le mouvement d’entrée à associer à <paramref name="command" />.</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Windows.Input.InputBinding" /> classe avec la commande spécifiée et le mouvement d’entrée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous êtes un développeur de logiciels à l’aide des classes de liaison d’entrée existantes, vous généralement pas utilisera ce constructeur, même si vous définissez des commandes personnalisées. Au lieu de cela, vous utilisez des constructeurs de classes dérivées (<xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>), ou vous utilisez ce constructeur comme instanciation de base d’une classe personnalisée. Bien que le <xref:System.Windows.Input.InputBinding> classe prend en charge les périphériques d’entrée différents en principe, dans la pratique, vous devez choisir un périphérique qui représente la liaison d’entrée. Vous ne pouvez définir qu’un seul <xref:System.Windows.Input.InputBinding.Gesture%2A> valeur sur la liaison d’entrée et les mouvements sont spécifiques au périphérique.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser ce constructeur pour associer un <xref:System.Windows.Input.KeyGesture> avec un <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcommand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcommand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" /> ou <paramref name="gesture" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Copie les valeurs de base (non animées) des propriétés de l’objet spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Copie les valeurs actuelles des propriétés de l’objet spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Input.ICommand" /> associé à cette liaison d’entrée.</summary>
        <value>Commande associée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.InputBinding> classe ne prend pas en charge l’utilisation XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et peuvent donc utiliser des propriétés qui sont héritées de <xref:System.Windows.Input.InputBinding>. Deux existant <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciées dans XAML et peuvent définir des propriétés avec les utilisations XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> fait référence à un convertisseur de type qui permet à certaines préexistant <xref:System.Windows.Input.ICommand> implémentations pour spécifier des valeurs sous la forme d’une chaîne. Ce comportement de conversion de type définit la forme de valeur d’attribut de cette propriété. Vous pouvez également lier le <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, et <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriétés à un <xref:System.Windows.Input.ICommand> qui est défini sur un objet. Cela vous permet de définir une commande personnalisée et l’associer à l’entrée d’utilisateur. Pour plus d’informations, consultez le deuxième exemple dans <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
 <`inputBindingDerivedClass` `Command`="<xref:System.Windows.Input.ICommand>"/>  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `iCommandImplementation`  
 Implémentation d’objet de <xref:System.Windows.Input.ICommand> qui prend en charge la syntaxe d’élément objet (a un constructeur public par défaut).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Input.KeyBinding> pour lier un <xref:System.Windows.Input.KeyGesture> à la <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> commande. Lors de la combinaison de touches est effectuée, la commande Ouvrir est appelée.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Input.InputBinding.Command" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les données spécifiques à la commande pour une commande particulière.</summary>
        <value>Les données spécifiques à la commande. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.InputBinding.CommandParameter%2A> propriété est utilisée pour passer des informations spécifiques à la commande lorsqu’elle est exécutée. Le type de données est défini par la commande. Nombre de commandes n’attendre pas de paramètres de commande ; pour ces commandes, les paramètres de commande passés seront ignorés.  
  
 Si la commande qui est associée à une liaison d’entrée est un <xref:System.Windows.Input.RoutedCommand>, le <xref:System.Windows.Input.InputBinding.CommandParameter%2A> de la liaison d’entrée est passé à la <xref:System.Windows.Input.RoutedCommand> gestionnaires via le <xref:System.Windows.Input.ExecutedRoutedEventArgs> et le <xref:System.Windows.Input.CanExecuteRoutedEventArgs> les données d’événement lors du traitement de la commande.  
  
 Le type de données et l’objectif du paramètre de commande sont définis différemment pour chaque commande et peut être `null`. Vous pouvez lier le <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, et <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriétés à un <xref:System.Windows.Input.ICommand> qui est défini sur un objet. Cela vous permet de définir une commande personnalisée et l’associer à l’entrée d’utilisateur. Pour plus d’informations, consultez le deuxième exemple dans <xref:System.Windows.Input.InputBinding>.  
  
 Le <xref:System.Windows.Input.InputBinding> classe ne prend pas en charge l’utilisation XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et par conséquent, peut définir des propriétés qui sont héritées de <xref:System.Windows.Input.InputBinding> avec l’utilisation XAML. Deux existant <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciées dans XAML et définir des propriétés en XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `commandParameterString`  
 Chaîne qui est traitée par une commande particulière. Les chaînes sont le type commun utilisé pour les paramètres de commande, car elles peuvent être facilement définies dans XAML. Pour le format de chaîne attendu et son objectif, consultez la documentation pour la commande spécifique qui est associée à la liaison d’entrée. De nombreuses commandes n’attendent pas de paramètres.  
  
 `commandParameterObject`  
 Objet qui est traité par une commande particulière. Toutes les [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] commandes utilisent des chaînes. Par conséquent, cette syntaxe d’élément de propriété est uniquement pertinente pour les scénarios de commande personnalisée. Pour prendre en charge cette syntaxe, la `commandParameterObject` objet doit prendre également en charge la syntaxe d’élément objet (doit disposer d’un constructeur public par défaut).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Input.InputBinding.CommandParameter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Input.InputBinding.Command" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’élément cible de la commande.</summary>
        <value>La cible de la commande. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans Windows Presentation Foundation commandes système, le <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriété sur une <xref:System.Windows.Input.ICommandSource> objet est applicable uniquement lorsque le <xref:System.Windows.Input.ICommand> est un <xref:System.Windows.Input.RoutedCommand>. Si <xref:System.Windows.Input.InputBinding.CommandTarget%2A> est défini sur <xref:System.Windows.Input.ICommandSource> et si la commande correspondante n’est pas <xref:System.Windows.Input.RoutedCommand>, la cible de commande est ignorée.  
  
 Lorsqu’il est utilisé avec un <xref:System.Windows.Input.RoutedCommand>, la cible de commande est l’objet sur lequel le <xref:System.Windows.Input.CommandManager.Executed> et <xref:System.Windows.Input.CommandManager.CanExecute> sont déclenchés. Si le <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriété n’est pas définie, l’élément ayant le focus clavier est utilisé comme cible.  
  
 Le <xref:System.Windows.Input.InputBinding> classe lui-même ne prend pas en charge l’utilisation XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et affecter ainsi les propriétés héritées de <xref:System.Windows.Input.InputBinding> avec une utilisation XAML. Deux existant <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciées dans XAML et définir des propriétés en XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `bindingToTarget`  
 Élément nommé de chaîne qui utilise un type de syntaxe de liaison qui peut retourner une référence d’objet à un existant. Consultez la section Notes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Input.InputBinding.CommandTarget" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une instance d’un <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <returns>Nouvel objet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Input.InputGesture" /> associé à cette liaison d’entrée.</summary>
        <value>Combinaison associée. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mouvement d’entrée est l’action qui appelle la commande. Exemples de mouvements d’entrée dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sont <xref:System.Windows.Input.KeyGesture> et <xref:System.Windows.Input.MouseGesture>. Un <xref:System.Windows.Input.KeyGesture> est une combinaison d’un <xref:System.Windows.Input.Key> et un ensemble de <xref:System.Windows.Input.ModifierKeys>. Un <xref:System.Windows.Input.MouseGesture> est une combinaison d’un <xref:System.Windows.Input.MouseAction> et un ensemble de <xref:System.Windows.Input.ModifierKeys>.  
  
 Le <xref:System.Windows.Input.InputBinding> classe lui-même ne prend pas en charge l’utilisation XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et affecter ainsi les propriétés héritées de <xref:System.Windows.Input.InputBinding> avec une utilisation XAML. Deux existant <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciées dans XAML et définir des propriétés en XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`="<xref:System.Windows.Input.KeyGesture>"/>  
  
ou
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`="<xref:System.Windows.Input.MouseGesture>"/>  
  
ou
  
 <`inputBindingDerivedClass` `Gesture`="<xref:System.Windows.Input.InputGesture>"/>  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `inputGestureImplementation`  
 Classe de dérivée personnalisée <xref:System.Windows.Input.InputGesture> qui prend en charge la syntaxe d’élément objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Input.KeyBinding> pour lier un <xref:System.Windows.Input.KeyGesture> à un <xref:System.Windows.Input.RoutedCommand>. Lorsque le <xref:System.Windows.Input.KeyGesture> appuyé sur ALT + L, le <xref:System.Windows.Input.ApplicationCommands.Close%2A> commande est appelée.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Convertit l’instance en clone figé du spécifié <see cref="T:System.Windows.Freezable" /> à l’aide des valeurs de propriété (non-animées) de base.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Convertit l’instance actuelle en un clone figé du <see cref="T:System.Windows.Freezable" /> spécifié. Si l’objet a des propriétés de dépendance animées, leurs valeurs animées actuelles sont copiées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>