<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata><Meta Name="ms.openlocfilehash" Value="840287af60b0e7f2b012259e3913dc4478e6041f" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66007604" /></Metadata><TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Le module <see langword="Interaction" /> contient les procédures utilisées pour interagir avec les objets, les applications et les systèmes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce module prend en charge les mots clés du langage Visual Basic et les membres de bibliothèque Runtime qui exécutent d’autres programmes, appellent une méthode ou propriété, émettent un signal sonore à partir de l’ordinateur, fournissent une chaîne de ligne de commande, manipulent des objets COM et contrôlent les boîtes de dialogue.  
  
## Examples  
 L’exemple suivant utilise le `Shell` fonction à exécuter une application spécifiée par l’utilisateur. En spécifiant <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> comme deuxième argument ouvre l’application dans sa taille d’origine et lui donne le focus.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/information-and-interaction-summary.md">Liste des informations et des interactions</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Mots clés (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membres de la bibliothèque d’exécution Visual Basic</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Active une application qui est déjà en cours d'exécution.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="ProcessId"><see langword="Integer" /> spécifiant le numéro d'ID de processus Win32 assigné à ce processus. Vous pouvez utiliser l'ID retourné par la <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />, à condition que sa valeur soit différente de zéro.</param>
        <summary>Active une application qui est déjà en cours d'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez `AppActivate` pour placer le focus de la fenêtre active d’une application. Peut ne pas avoir de handle ou une référence à la fenêtre active, ou même savoir quelle fenêtre est active à un moment donné. Dans ce cas, vous ne pouvez pas utiliser le <xref:System.Windows.Forms.Control.Focus%2A> (méthode).  
  
 Le `AppActivate` fonction le focus vers la fenêtre ou une application nommée, mais ne détermine pas si elle est agrandie ou réduite. Le focus se déplace en dehors de la fenêtre d’application activé lorsque l’utilisateur exécute une action pour modifier le focus ou fermez la fenêtre. Vous pouvez utiliser le `Shell` (fonction) pour démarrer une application et définir le style de fenêtre.  
  
 Si vous utilisez le `Title` paramètre, `AppActivate` utilise une comparaison respectant la casse, mais exige une correspondance exacte avec le contenu de la barre de titre. Tout d’abord, il recherche les fenêtres de niveau supérieur, puis les fenêtres enfants. S’il ne trouve une correspondance, elle lève une <xref:System.ArgumentException>.  
  
 Vous pouvez utiliser `AppActivate` qu’avec des processus qui possèdent de fenêtres. La plupart des applications de console ne possèdent pas de windows, ce qui signifie qu’ils n’apparaissent pas dans la liste des processus qui `AppActivate` recherches. Lors de l’exécution à partir d’une application console, le système crée un processus distinct pour exécuter l’application et renvoie la sortie vers le processus de la console. Par conséquent, lorsque vous demandez l’ID du processus actuel, vous obtenez l’ID de processus de ce processus distinct, plutôt que. de l’application de console  
  
 Au moment de l’exécution, le `AppActivate` fonction active toute application en cours d’exécution avec un titre qui correspond à `Title` ou avec un ID de processus qui correspond à `ProcessId`. Si aucune correspondance n’est exacte, elle active toute application dont la chaîne de titre se termine par `Title`. S’il existe plus d’une application nommée `Title`, le `AppActivate` fonction choisit arbitrairement une pour l’activer.  
  
> [!NOTE]
>  Le `AppActivate` fonction requiert `UIPermission` à la <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> niveau, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d'informations, consultez <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Cet exemple illustre différentes utilisations de la `AppActivate` fonction pour activer une fenêtre d’application. Si un processus Notepad n’est pas en cours d’exécution, l’exemple lève une <xref:System.ArgumentException>. Le `Shell` procédure suppose que les applications sont dans les chemins d’accès spécifiés.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Title">Expression <see langword="String" /> spécifiant le titre figurant dans la barre de titre de l'application que vous souhaitez activer. Vous pouvez utiliser le titre assigné à l'application lorsqu'elle a été lancée.</param>
        <summary>Active une application qui est déjà en cours d'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez `AppActivate` pour placer le focus de la fenêtre active d’une application. Peut ne pas avoir de handle ou une référence à la fenêtre active, ou même savoir quelle fenêtre est active à un moment donné. Dans ce cas, vous ne pouvez pas utiliser le <xref:System.Windows.Forms.Control.Focus%2A> (méthode).  
  
 Le `AppActivate` fonction le focus vers la fenêtre ou une application nommée, mais ne détermine pas si elle est agrandie ou réduite. Le focus se déplace en dehors de la fenêtre d’application activé lorsque l’utilisateur exécute une action pour modifier le focus ou fermez la fenêtre. Vous pouvez utiliser le `Shell` (fonction) pour démarrer une application et définir le style de fenêtre.  
  
 Si vous utilisez le `Title` paramètre, `AppActivate` utilise une comparaison respectant la casse, mais exige une correspondance exacte avec le contenu de la barre de titre. Tout d’abord, il recherche les fenêtres de niveau supérieur, puis les fenêtres enfants. S’il ne trouve une correspondance, elle lève une <xref:System.ArgumentException>.  
  
 Vous pouvez utiliser `AppActivate` qu’avec des processus qui possèdent de fenêtres. La plupart des applications de console ne possèdent pas de windows, ce qui signifie qu’ils n’apparaissent pas dans la liste des processus qui `AppActivate` recherches. Lors de l’exécution à partir d’une application console, le système crée un processus distinct pour exécuter l’application et renvoie la sortie vers le processus de la console. Par conséquent, lorsque vous demandez l’ID du processus actuel, vous obtenez l’ID de processus de ce processus distinct, plutôt que. de l’application de console  
  
 Au moment de l’exécution, le `AppActivate` fonction active toute application en cours d’exécution avec un titre qui correspond à `Title` ou avec un ID de processus qui correspond à `ProcessId`. Si aucune correspondance n’est exacte, elle active toute application dont la chaîne de titre se termine par `Title`. S’il existe plus d’une application nommée `Title`, le `AppActivate` fonction choisit arbitrairement une pour l’activer.  
  
> [!NOTE]
>  Le `AppActivate` fonction requiert `UIPermission` à la <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> niveau, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d'informations, consultez <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Cet exemple illustre différentes utilisations de la `AppActivate` fonction pour activer une fenêtre d’application. Si un processus Notepad n’est pas en cours d’exécution, l’exemple lève une <xref:System.ArgumentException>. Le `Shell` procédure suppose que les applications sont dans les chemins d’accès spécifiés.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Émet un signal sonore par le haut-parleur de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La hauteur et la durée du signal sonore dépendent de votre logiciel de matériel et du système et par conséquent varient selon les ordinateurs.  
  
> [!NOTE]
>  Le `Beep` fonction requiert `UIPermission` à la <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> niveau, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d'informations, consultez <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Cet exemple utilise le `Beep` fonction sonore via le haut-parleur de l’ordinateur.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membres de la bibliothèque d’exécution Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/playing-sounds.md">Lecture de sons</related>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Obligatoire. <see langword="Object" />. Pointeur qui désigne l'objet exposant la propriété ou la méthode.</param>
        <param name="ProcName">Obligatoire. <see langword="String" />. Expression de type chaîne contenant le nom de la propriété ou de la méthode sur l'objet.</param>
        <param name="UseCallType">Obligatoire. Membre de l'énumération de type <see cref="T:Microsoft.VisualBasic.CallType" /> représentant le type de la procédure appelée. La valeur de <see langword="CallType" /> peut être <see langword="Method" />, <see langword="Get" /> ou <see langword="Set" />.</param>
        <param name="Args">Optionnel. <see langword="ParamArray" />. Tableau de paramètres contenant les arguments à passer à la propriété ou la méthode appelée.</param>
        <summary>Applique une méthode à un objet, ou définit ou retourne une propriété d'un objet.</summary>
        <returns>Applique une méthode à un objet, ou définit ou retourne une propriété d'un objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `CallByName` fonction est utilisée lors de l’exécution pour obtenir une propriété, définir une propriété ou appeler une méthode.  
  
   
  
## Examples  
 Dans l’exemple suivant, la première ligne utilise `CallByName` pour définir le `Text` propriété d’une zone de texte, la deuxième ligne récupère la valeur de la `Text` propriété et la troisième ligne appelle la `Move` méthode pour déplacer la zone de texte.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 L’exemple suivant utilise le `CallByName` fonction à appeler le `Add` et `Item` méthodes d’un objet de collection.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Valeur <paramref name="UseCallType" /> non valide ; doit être <see langword="Method" />, <see langword="Get" /> ou <see langword="Set" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Tableaux de paramètres</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/early-late-binding/calling-a-property-or-method-using-a-string-name.md">Appel d'une propriété ou méthode à l'aide d'un nom de chaîne</related>
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Choice" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Obligatoire. <see langword="Double" />. Expression numérique qui produit une valeur comprise entre 1 et le nombre des éléments passés dans l'argument <paramref name="Choice" />.</param>
        <param name="Choice">Obligatoire. Tableau de paramètres <see langword="Object" />. Vous pouvez fournir une variable ou une expression unique qui correspond au type de données <see langword="Object" />, à une liste de variables ou d'expressions <see langword="Object" /> séparées par des virgules ou à un tableau unidimensionnel d'éléments <see langword="Object" />.</param>
        <summary>Sélectionne et retourne une valeur à partir d'une liste d'arguments.</summary>
        <returns>Sélectionne et retourne une valeur à partir d'une liste d'arguments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Choose` fonction retourne un membre de la liste passée dans `Choice()`, en fonction de la valeur de `Index`. Le premier membre de la liste est sélectionné lorsque `Index` est 1. Le dernier membre de la liste est sélectionné lorsque `Index` est `UBound`(`Choice()`). Si `Index` est en dehors de ces limites, `Choose` retourne `Nothing`.  
  
 Si `Index` n’est pas un nombre entier, il est arrondi au nombre entier le plus proche avant d’être évalué.  
  
 Vous pouvez utiliser `Choose` pour rechercher une valeur dans une liste de possibilités.  
  
> [!NOTE]
>  Les expressions dans la liste d’arguments peuvent inclure des appels de fonction. Dans le cadre de la préparation de la liste d’arguments pour l’appel à `Choose`, le compilateur Visual Basic appelle chaque fonction de chaque expression. Cela signifie que vous ne pouvez pas compter sur une fonction particulière n’est pas appelée si une expression distincte est sélectionnée par `Index`.  
  
   
  
## Examples  
 Cet exemple utilise le `Choose` (fonction) pour afficher un nom en réponse à un index passé à la procédure décrite dans la `Ind` paramètre.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case, instruction (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la partie argument de la ligne de commande utilisée pour démarrer Visual Basic ou un programme exécutable développé avec Visual Basic. La fonctionnalité <see langword="My" /> fournit une productivité et une performance supérieures à celles de la fonction <see langword="Command" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>La partie argument de la ligne de commande utilisée pour démarrer Visual Basic ou un programme exécutable développé avec Visual Basic.  
  
La fonctionnalité <see langword="My" /> fournit une productivité et une performance supérieures à celles de la fonction <see langword="Command" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois que les arguments sont retournés, vous pouvez rechercher des délimiteurs communs, tels que des espaces, ascendante ou descendante de barres obliques, des traits d’union ou des guillemets, pour fractionner ou rechercher la chaîne de paramètres individuels.  
  
 Pour les applications développées avec Visual Basic et compilées en un fichier .exe, le `Command` fonction retourne tous les arguments qui apparaissent après le nom de l’application sur la ligne de commande dans cet écran : `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 Cet exemple utilise le `Command` fonction pour retourner les arguments de ligne de commande dans un objet qui contient un tableau.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membres de la bibliothèque d’exécution Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/reference/command-line-compiler/index.md">Compilateur de ligne de commande de Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/program-structure/structure-of-a-visual-basic-program.md">Structure d'un programme Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ServerName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="ProgId">Obligatoire. <see langword="String" />. ID de programme de l'objet à créer.</param>
        <param name="ServerName">Optionnel. <see langword="String" />. Nom du serveur réseau où l'objet sera créé. Si <paramref name="ServerName" /> est une chaîne vide (""), l'ordinateur local est utilisé.</param>
        <summary>Crée et retourne une référence à un objet COM. <see langword="CreateObject" /> ne peut être utilisé pour créer des instances de classes en Visual Basic à moins que ces classes soient exposées explicitement en tant que composants COM.</summary>
        <returns>Crée et retourne une référence à un objet COM. <see langword="CreateObject" /> ne peut être utilisé pour créer des instances de classes en Visual Basic à moins que ces classes soient exposées explicitement en tant que composants COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer une instance d’un composant COM, assignez l’objet retourné par `CreateObject` à une variable objet :  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 Le type de variable d’objet que vous permet de stocker l’objet retourné peut affecter les performances de votre application. Déclarez une variable objet avec le `As Object` clause crée une variable qui peut contenir une référence à n’importe quel type d’objet. Toutefois, l’accès à l’objet via cette variable est *à liaison tardive*, autrement dit, la liaison se produit lorsque votre programme s’exécute. Il existe de nombreuses raisons, que vous devez éviter la liaison tardive, y compris les performances des applications plus lentes.  
  
 Vous pouvez créer une variable objet qui résulte dans une liaison anticipée - autrement dit, la liaison lorsque le programme est compilé. Pour ce faire, ajoutez une référence à la bibliothèque de types pour votre objet à partir de la **COM** onglet de la **ajouter une référence** boîte de dialogue sur le **projet** menu. Puis déclarez la variable objet du type spécifique de votre objet. Dans la plupart des cas, il est plus efficace d’utiliser le `Dim` instruction et un assembly PIA pour créer des objets qu’il est d’utiliser le `CreateObject` (fonction).  
  
## <a name="interacting-with-unmanaged-code"></a>Interaction avec du Code non managé  
 Un autre problème est que les objets COM utilisent le code non managé - code sans l’avantage du common language runtime. Un certain degré de complexité est impliqué dans le mélange de code managé de Visual Basic avec le code non managé à partir de COM. Lorsque vous ajoutez une référence à un objet COM, Visual Basic recherche d’un assembly d’interopérabilité primaire (PIA) pour cette bibliothèque ; s’il en trouve, puis il l’utilise. S’il ne trouve pas un assembly PIA, il crée ensuite un assembly d’interopérabilité qui contient les classes d’interopérabilité locales pour chaque classe dans la bibliothèque COM. Pour plus d’informations, consultez [interopérabilité COM dans les Applications .NET Framework](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 Vous devez généralement utiliser des objets étroitement liés et des assemblys PIA autant que possible. Les exemples ci-dessous utilisent le `CreateObject` à des fins de fonction avec des objets Microsoft Office pour la démonstration uniquement. Toutefois, ces objets sont plus faciles à utiliser et plus fiable lorsqu’il est utilisé avec l’assembly PIA approprié.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Création d’un objet sur un ordinateur distant  
 Vous pouvez créer un objet sur un ordinateur réseau distant en passant le nom de l’ordinateur à la `ServerName` argument de la `CreateObject` (fonction). Ce nom est identique à la partie du nom de l’ordinateur d’un nom de partage : pour un partage nommé «\\\MyServer\Public, « `ServerName` est « MyServer ».  
  
> [!NOTE]
>  Reportez-vous à la documentation de COM (voir Microsoft Developer Network) pour plus d’informations sur la création d’une application accessible sur un ordinateur distant du réseau. Vous devrez peut-être ajouter une clé de Registre pour votre application.  
  
 Le code suivant retourne le numéro de version d’une instance d’Excel en cours d’exécution sur un ordinateur distant nommé `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Si le nom de serveur distant est incorrect, ou si elle n’est pas disponible, une erreur d’exécution se produit.  
  
> [!NOTE]
>  Utilisez `CreateObject` lorsqu’il n’existe aucune instance en cours de l’objet. Si une instance de l’objet est déjà en cours d’exécution, une nouvelle instance est démarrée, et un objet du type spécifié est créé. Pour utiliser l’instance actuelle, ou pour démarrer l’application en chargeant un fichier, utilisez le `GetObject` (fonction). Si un objet s’est inscrit en tant qu’objet à instance unique, qu’une seule instance de l’objet est créée, quelle que soit la procédure autant de fois `CreateObject` est exécutée.  
  
## <a name="creating-framework-objects"></a>Création d’objets Framework  
 Vous pouvez utiliser le `CreateObject` uniquement pour créer un objet COM (fonction). Il n’existe aucun mécanisme équivalent exact pour créer un objet .NET Framework, le <xref:System.Activator> dans le <xref:System> espace de noms contient des méthodes pour créer des objets locaux ou distants. En particulier, le <xref:System.Activator.CreateInstance%2A> méthode ou le <xref:System.Activator.CreateInstanceFrom%2A> méthode peut être utile.  
  
> [!IMPORTANT]
>  Le `CreateObject` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 L’exemple suivant utilise le `CreateObject` de fonction pour créer une feuille de calcul Microsoft Excel et enregistre la feuille de calcul dans un fichier. Pour utiliser cet exemple, Excel doit être installé sur l’ordinateur sur lequel ce programme s’exécute. En outre, vous devez ajouter une référence à la bibliothèque de types à partir de la **COM** onglet de la **ajouter une référence** boîte de dialogue sur le **projet** menu. Le nom de la bibliothèque de types varie selon la version d’Excel installée sur votre ordinateur. Par exemple, la bibliothèque de types pour Microsoft Excel 2002 est nommée **bibliothèque d’objets Microsoft Excel 10.0**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Le serveur est indisponible.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Aucun objet du type spécifié n'existe</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/dim-statement.md">Dim, instruction (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">Interopérabilité COM dans les applications .NET Framework</related>
        <related type="Article" href="~/docs/framework/interop/index.md">Interopération avec du code non managé</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatoire. Expression <see langword="String" /> contenant le nom de l'application ou du projet auquel s'applique le paramètre de section ou de clé.</param>
        <param name="Section">Obligatoire. Expression <see langword="String" /> contenant le nom de la section à partir de laquelle le paramètre de clé est supprimé. Si seuls sont spécifiés <paramref name="AppName" /> et <paramref name="Section" />, la section spécifiée est supprimée avec tous les paramètres de clé connexes.</param>
        <param name="Key">Optionnel. Expression <see langword="String" /> contenant le nom du paramètre de clé supprimé.</param>
        <summary>Supprime un paramètre de section ou de clé pour une application dans la base de registres Windows. <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations de Registre que la fonction <see langword="DeleteSetting" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tous les arguments sont fournis, le paramètre spécifié est supprimé. Une erreur d’exécution se produit si vous essayez d’utiliser `DeleteSetting` sur une section qui n’existe pas ou le paramètre de clé.  
  
 `DeleteSetting` nécessite qu’un utilisateur soit connecté car elle fonctionne sous le `HKEY_LOCAL_USER` clé de Registre qui n’est pas actif jusqu'à ce qu’un utilisateur se connecte manière interactive.  
  
 Les paramètres de Registre qui sont accessibles à partir d’un processus non interactif (par exemple, Mtx.exe) doivent être stockés sous la `HKEY_LOCAL_MACHINE\Software\` ou `HKEY_USER\DEFAULT\Software` clés de Registre.  
  
   
  
## Examples  
 L’exemple suivant utilise d’abord la `SaveSetting` procédure pour créer des entrées dans le Registre Windows pour le `MyApp` application, puis utilise le `DeleteSetting` (fonction) pour les supprimer. Car aucun `Key` argument est spécifié, l’ensemble `Startup` section est supprimée, y compris le nom de section et toutes ses clés.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'utilisateur n'est pas connecté.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la chaîne associée à une variable d'environnement du système d'exploitation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Expression">Obligatoire. Expression qui évalue soit une chaîne contenant le nom d'une variable d'environnement, soit un entier correspondant à l'ordre numérique d'une chaîne d'environnement de la table de chaînes d'environnement.</param>
        <summary>Retourne la chaîne associée à une variable d'environnement du système d'exploitation.</summary>
        <returns>La chaîne associée à une variable d’environnement du système d’exploitation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Expression` contient une chaîne, le <xref:Microsoft.VisualBasic.Interaction.Environ%2A> fonction retourne le texte assigné à la chaîne d’environnement spécifiée - autrement dit, le texte qui suit le signe égal (=) dans la table de chaînes d’environnement pour cette variable d’environnement. Si la chaîne dans `Expression` est introuvable dans la table de chaînes d’environnement, une chaîne de longueur nulle (" ») est retournée.  
  
 Si `Expression` contient un entier, la chaîne qui occupe cette position numérique dans la table de chaînes d’environnement est retournée. Dans ce cas, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retourne tout le texte, y compris le nom de la variable d’environnement. S’il n’existe aucune chaîne d’environnement dans la position spécifiée, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retourne une chaîne de longueur nulle.  
  
> [!IMPORTANT]
>  Le <xref:Microsoft.VisualBasic.Interaction.Environ%2A> fonction requiert l’autorisation d’environnement, qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Cet exemple utilise le <xref:Microsoft.VisualBasic.Interaction.Environ%2A> (fonction) pour fournir le numéro d’entrée et la longueur de la `PATH` instruction à partir de la table de chaînes d’environnement.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Expression" /> est manquante.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membres de la bibliothèque d’exécution Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Expression">Obligatoire. Expression qui évalue soit une chaîne contenant le nom d'une variable d'environnement, soit un entier correspondant à l'ordre numérique d'une chaîne d'environnement de la table de chaînes d'environnement.</param>
        <summary>Retourne la chaîne associée à une variable d'environnement du système d'exploitation.</summary>
        <returns>La chaîne associée à une variable d’environnement du système d’exploitation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Expression` contient une chaîne, le <xref:Microsoft.VisualBasic.Interaction.Environ%2A> fonction retourne le texte assigné à la chaîne d’environnement spécifiée - autrement dit, le texte qui suit le signe égal (=) dans la table de chaînes d’environnement pour cette variable d’environnement. Si la chaîne dans `Expression` est introuvable dans la table de chaînes d’environnement, une chaîne de longueur nulle (" ») est retournée.  
  
 Si `Expression` contient un entier, la chaîne qui occupe cette position numérique dans la table de chaînes d’environnement est retournée. Dans ce cas, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retourne tout le texte, y compris le nom de la variable d’environnement. S’il n’existe aucune chaîne d’environnement dans la position spécifiée, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retourne une chaîne de longueur nulle.  
  
> [!IMPORTANT]
>  Le <xref:Microsoft.VisualBasic.Interaction.Environ%2A> fonction requiert l’autorisation d’environnement, qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Cet exemple utilise le <xref:Microsoft.VisualBasic.Interaction.Environ%2A> (fonction) pour fournir le numéro d’entrée et la longueur de la `PATH` instruction à partir de la table de chaînes d’environnement.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Expression" /> est manquante.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membres de la bibliothèque d’exécution Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatoire. Expression <see langword="String" /> contenant le nom de l'application ou du projet dont les paramètres de clé sont demandés.</param>
        <param name="Section">Obligatoire. Expression <see langword="String" /> qui contient le nom de la section dont les paramètres de clé sont demandés. <see langword="GetAllSettings" /> retourne un objet qui contient un tableau de chaînes à deux dimensions. Les chaînes contiennent tous les paramètres de clé dans la section spécifiée ainsi que leurs valeurs correspondantes.</param>
        <summary>Retourne une liste de paramètres de clé et leurs valeurs respectives (créées à l'origine avec <see langword="SaveSetting" />) pour une application dans la base de registres Windows. L'utilisation de la fonctionnalité <see langword="My" /> vous permet une meilleure productivité et de meilleures performances dans les opérations de Registre que <see langword="GetAllSettings" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Une liste de paramètres de clé et leurs valeurs respectives (créées à l’origine avec <see langword="SaveSetting" />) pour une application dans la base de registres Windows.  
  
L'utilisation de la fonctionnalité <see langword="My" /> vous permet une meilleure productivité et de meilleures performances dans les opérations de Registre que <see langword="GetAllSettings" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Retourne un non initialisé `Object` si `AppName` ou `Section` n’existe pas.  
  
 Étant donné qu’il fonctionne sous le `HKEY_LOCAL_USER` clé de Registre qui n’est pas actif jusqu'à ce qu’un utilisateur se connecte manière interactive, `GetAllSettings` nécessite qu’un utilisateur soit connecté.  
  
 Les paramètres de Registre qui sont accessibles à partir d’un processus non interactif (par exemple, Mtx.exe) doivent être stockés sous la `HKEY_LOCAL_MACHINE\Software\` ou `HKEY_USER\DEFAULT\Software` clés de Registre.  
  
   
  
## Examples  
 Cet exemple utilise d’abord la `SaveSetting` fonction permettant de créer des entrées dans le Registre Windows pour l’application spécifiée en tant que `AppName`, puis utilise le `GetAllSettings` (fonction) pour afficher les paramètres. Notez cette application noms et `Section` noms ne peut pas être récupérés avec `GetAllSettings`. Enfin, le `DeleteSetting` fonction supprime les entrées de l’application.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'utilisateur n'est pas connecté.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lecture et écriture dans le Registre (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Class" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="PathName">Optionnel. <see langword="String" />. Chemin d'accès complet et nom du fichier contenant l'objet à récupérer. Si <paramref name="PathName" /> est omis, <paramref name="Class" /> est requis.</param>
        <param name="Class">Requis si <paramref name="PathName" /> n'est pas fourni. <see langword="String" />. Chaîne représentant la classe de l'objet. L'argument <paramref name="Class" /> emploie la syntaxe et les paramètres suivants : 
 <c>appname</c><c>.</c> <c>objecttype</c>  
  
[1|1] Paramètre 
[1|2] Description 
[2|1] <c>appname</c>  
  
[2|2] requis. <see langword="String" />. Nom de l'application qui fournit l'objet.  
  
[3|1] <c>objecttype</c>  
  
[3|2] requis. <see langword="String" />. Type ou classe de l'objet à créer.</param>
        <summary>Retourne une référence à un objet fourni par un composant COM.</summary>
        <returns>Une référence à un objet fourni par un composant COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `GetObject` pour charger une instance d’un composant COM à partir d’un fichier. L'exemple suivant illustre ce comportement.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 Lorsque ce code s’exécute, l’application associée spécifié `PathName` est démarré et l’objet dans le fichier spécifié est activé.  
  
## <a name="default-cases"></a>Cas par défaut  
 Si `PathName` est une chaîne de longueur nulle (`""`), `GetObject` retourne une nouvelle instance d’objet du type classe spécifié. Si le `PathName` argument est omis, `GetObject` retourne un objet actuellement actif du type de classe spécifié dans `Class`. Si aucun objet du type spécifié n’existe, une erreur se produit.  
  
## <a name="accessing-a-subobject"></a>Accès à un sous-objet  
 Certaines applications permettent d’activer un sous-objet associé à un fichier. Pour ce faire, ajoutez un point d’exclamation (`!`) à la fin du nom de fichier et suivez avec une chaîne qui identifie la partie du fichier vous souhaitez activer. Pour plus d’informations sur la création de cette chaîne, consultez la documentation de l’application qui a créé l’objet.  
  
 Par exemple, dans une application de dessin, vous pouvez avoir plusieurs couches de dessin stockées dans un fichier. Vous pouvez utiliser le code suivant pour activer la couche d’un dessin nommé `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Spécification d’une classe  
 Si vous ne spécifiez pas l’objet `Class`, Automation détermine l’application à démarrer et l’objet à activer, en fonction du nom de fichier que vous fournissez. Toutefois, certains fichiers, peuvent prendre en charge plusieurs classes d’objet. Par exemple, un dessin peut prendre en charge trois types d’objets différents : un `Application` objet, un `Drawing` objet et un `Toolbar` objet, qui font partie du même fichier. Pour spécifier quel objet dans un fichier que vous souhaitez activer, utilisez le paramètre facultatif `Class` argument. L'exemple suivant illustre ce comportement.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 Dans l’exemple précédent, `Figment` est le nom d’une application de dessin et `Drawing` est un des types d’objets il prend en charge.  
  
## <a name="using-the-object"></a>À l’aide de l’objet  
 Une fois qu’un objet est activé, vous y faire référence en dans le code à l’aide de la variable objet déclarée. L’exemple précédent, vous accédez aux propriétés et méthodes du nouvel objet à l’aide de la variable objet `drawObj`. L'exemple suivant illustre ce comportement.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Utilisez le `GetObject` fonctionner lorsqu’il existe une instance en cours de l’objet ou si vous souhaitez créer l’objet avec un fichier chargé. S’il n’existe aucune instance en cours, et vous ne souhaitez pas que l’objet démarre avec un fichier chargé, utilisez la <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> (fonction).  
>   
>  Si un objet s’est inscrit en tant qu’objet ActiveX à instance unique, qu’une seule instance de l’objet est créée, quelle que soit la procédure autant de fois `CreateObject` est appelée. Avec un objet à instance unique, `GetObject` retourne toujours la même instance lorsqu’elle est appelée avec la chaîne de longueur nulle (`""`) syntaxe et provoque une erreur si le `PathName` argument est omis. Vous ne pouvez pas utiliser `GetObject` pour obtenir une référence à une classe créée avec Visual Basic.  
  
> [!IMPORTANT]
>  Le `GetObject` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 L’exemple suivant utilise le `GetObject` fonction pour obtenir une référence à une feuille de calcul Microsoft Excel spécifique (`excelObj`). Il utilise la feuille de calcul `Application` propriété à rendre Excel visible, fermez-la et effectuer d’autres actions. À l’aide de deux appels d’API, le `detectExcel` procédure recherche Excel et si elle est en cours d’exécution, l’insère dans la table des objets en cours d’exécution. Le premier appel à `GetObject` provoque une erreur si Excel n’est déjà fait, dans cet exemple provoque la `excelWasNotRunning` indicateur pour être définie sur `True`. Le deuxième appel à `GetObject` spécifie un fichier à ouvrir. Si Excel n’est pas déjà en cours d’exécution, le deuxième appel lance l’application et retourne une référence à la feuille de calcul représentée par le fichier spécifié, `test.xls`. Le fichier doit exister dans l’emplacement spécifié ; Sinon, Visual Basic lève une <xref:System.IO.FileNotFoundException>. Ensuite, l’exemple de code rend Excel et la fenêtre contenant la feuille de calcul spécifié visible.  
  
 Cet exemple nécessite `Option Strict Off` , car elle utilise la liaison tardive, où les objets sont affectées aux variables de type `Object`. Vous pouvez spécifier `Option Strict On` et déclarer des objets de types d’objet spécifiques si vous ajoutez une référence à la bibliothèque de types Excel à partir de la **COM** onglet de la **ajouter une référence** boîte de dialogue de la  **Projet** menu dans Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 Lorsque vous appelez le `getExcel` (fonction), une vérification est effectuée pour voir si Excel est déjà en cours d’exécution. Si elle n’est pas le cas, une instance est créée.  
  
> [!IMPORTANT]
>  Par souci de simplicité, l’exemple précédent suppose que n’importe quelle fenêtre appelée `XLMAIN` appartient à une instance de Microsoft Excel. Si un autre objet, peut-être lancé de manière illicite, a créé une fenêtre portant ce nom, il recevrait tous les messages destinés à Excel. Dans une application à utiliser pour la production, vous devez inclure des tests plus rigoureux pour vérifier que `XLMAIN` appartient réellement à Excel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Aucun objet du type spécifié n'existe.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Aucun objet avec le chemin d'accès spécifié et le nom de fichier n'existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Default" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatoire. Expression <see langword="String" /> contenant le nom de l'application ou du projet dont le paramètre de clé est demandé.</param>
        <param name="Section">Obligatoire. Expression <see langword="String" /> contenant le nom de la section dans laquelle le paramètre de clé est trouvé.</param>
        <param name="Key">Obligatoire. Expression <see langword="String" /> contenant le nom du paramètre de clé à retourner.</param>
        <param name="Default">Optionnel. Expression contenant la valeur à retourner si aucune valeur n'est définie dans le paramètre <paramref name="Key" />. S'il est omis, <paramref name="Default" /> est considéré comme une chaîne de longueur nulle ("").</param>
        <summary>Retourne une valeur de paramètre de clé pour une application dans la base de registres Windows. L'utilisation de la fonctionnalité <see langword="My" /> vous permet une meilleure productivité et de meilleures performances dans les opérations de Registre que <see langword="GetAllSettings" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Une valeur de paramètre de clé pour une application dans la base de registres Windows.  
  
L'utilisation de la fonctionnalité <see langword="My" /> vous permet une meilleure productivité et de meilleures performances dans les opérations de Registre que <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun des éléments nommés dans le `GetSetting` arguments n’existent pas, `GetSetting` retourne une valeur de `Default`.  
  
 Étant donné qu’il fonctionne sous le `HKEY_LOCAL_USER` clé de Registre qui n’est pas actif jusqu'à ce qu’un utilisateur se connecte manière interactive, `GetSetting` nécessite qu’un utilisateur soit connecté.  
  
 Les paramètres de Registre qui sont accessibles à partir d’un processus non interactif (par exemple, Mtx.exe) doivent être stockés sous la `HKEY_LOCAL_MACHINE\Software\` ou `HKEY_USER\DEFAULT\Software` clés de Registre.  
  
 `GetSetting` requiert `Read` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 Cet exemple utilise d’abord la `SaveSetting` fonction permettant de créer des entrées dans le Registre Windows pour l’application spécifiée en tant que `AppName`, puis utilise le `GetSetting` (fonction) pour afficher un des paramètres. Étant donné que le `Default` argument est spécifié, une valeur est garanti à retourner. Notez que `Section` noms ne peut pas être récupérés avec `GetSetting`. Enfin, le `DeleteSetting` fonction supprime toutes les entrées de l’application.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Au moins un argument n'est pas une expression <see langword="String" /> ou l'utilisateur n'est pas connecté.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lecture et écriture dans le Registre (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="TruePart" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="FalsePart" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Expression">Obligatoire. <see langword="Boolean" />. Expression à évaluer.</param>
        <param name="TruePart">Obligatoire. <see langword="Object" />. Retourné si <paramref name="Expression" /> a la valeur <see langword="True" />.</param>
        <param name="FalsePart">Obligatoire. <see langword="Object" />. Retourné si <paramref name="Expression" /> a la valeur <see langword="False" />.</param>
        <summary>Retourne un ou deux objets selon l'évaluation d'une expression.</summary>
        <returns>Retourne un ou deux objets selon l'évaluation d'une expression.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `IIf` fonction fournit un équivalent pour le ternaire [opérateur conditionnel : ? :](https://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) dans Visual C++.  
  
   
  
## Examples  
 Cet exemple utilise le `IIf` fonction à évaluer la `testMe` paramètre de la `checkIt` procédure et retourne if « Large » word le montant est supérieur à 1 000 ; sinon, elle retourne le mot « Petite ».  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Notez que si `Option Strict` est `On`, vous devez utiliser le `CStr` mot clé pour convertir explicitement le retour à partir de `Object` à `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">Type Conversion Functions</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/if-then-else-statement.md">If...Then...Else, instruction (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case, instruction (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Title" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="DefaultResponse" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="XPos" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="YPos" Type="System.Int32" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Prompt">L'expression <see langword="String" /> requise affichée comme message de la boîte de dialogue. La longueur maximale de l'argument <paramref name="Prompt" /> est d'environ 1 024 caractères selon la largeur des caractères utilisés. Si <paramref name="Prompt" /> comporte plusieurs lignes, vous pouvez séparer les lignes en insérant un caractère de retour chariot (<see langword="Chr(" />13<see langword=")" />), un caractère de saut de ligne (<see langword="Chr(" />10<see langword=")" />) ou une combinaison de retour chariot/saut de ligne (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) entre chaque ligne.</param>
        <param name="Title">Optionnel. Expression <see langword="String" /> affichée dans la barre de titre de la boîte de dialogue. Si l'argument <paramref name="Title" /> est omis, le nom de l'application est placé dans la barre de titre.</param>
        <param name="DefaultResponse">Optionnel. Expression <see langword="String" /> affichée dans la zone de texte comme réponse par défaut si aucune autre entrée n'est fournie. Si l'argument <paramref name="DefaultResponse" /> est omis, la zone de texte affichée est vide.</param>
        <param name="XPos">Optionnel. Expression numérique qui spécifie, en twips, la distance entre le bord gauche de la boîte de dialogue et le bord gauche de l'écran. Si l'argument <paramref name="XPos" /> est omis, la boîte de dialogue est centrée horizontalement.</param>
        <param name="YPos">Optionnel. Expression numérique qui spécifie, en twips, la distance entre le bord supérieur de la boîte de dialogue et le bord haut de l'écran. Si l'argument <paramref name="YPos" /> est omis, la boîte de dialogue est positionnée verticalement, à environ un tiers de l'écran en partant du haut.</param>
        <summary>Affiche une invite dans une boîte de dialogue, attend que l'utilisateur tape du texte ou clique sur un bouton, puis retourne le contenu de la zone de texte sous la forme d'une chaîne.</summary>
        <returns>Affiche une invite dans une boîte de dialogue, attend que l'utilisateur tape du texte ou clique sur un bouton, puis retourne le contenu de la zone de texte sous la forme d'une chaîne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’utilisateur clique sur **Annuler**, une chaîne de longueur nulle est retournée.  
  
 Pour spécifier plus que le premier argument, vous devez utiliser le `InputBox` fonction dans une expression. Si vous omettez les arguments positionnels, vous devez conserver la virgule de séparation correspondante.  
  
> [!NOTE]
>  Le `InputBox` fonction requiert `UIPermission` à la <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> niveau, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez [demande d’autorisations](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/yd267cce(v%3dvs.100)) et <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 Cet exemple montre différentes manières d’utiliser le `InputBox` (fonction) pour inviter l’utilisateur à entrer une valeur. Si x et y positions sont omises, la boîte de dialogue est centrée automatiquement pour les axes respectifs. La variable `MyValue` contient la valeur entrée par l’utilisateur si l’utilisateur clique sur OK ou appuie sur la touche ENTRÉE.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Title" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Prompt">Obligatoire. Expression <see langword="String" /> affichée comme message dans la boîte de dialogue. La longueur maximale de l'argument <paramref name="Prompt" /> est d'environ 1 024 caractères selon la largeur des caractères utilisés. Si <paramref name="Prompt" /> comporte plusieurs lignes, vous pouvez séparer les lignes en insérant un caractère de retour chariot (<see langword="Chr(" />13<see langword=")" />), un caractère de saut de ligne (<see langword="Chr(" />10<see langword=")" />) ou une combinaison de caractères de retour chariot/saut de ligne (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) entre chaque ligne.</param>
        <param name="Buttons">Optionnel. Expression numérique qui représente la somme des valeurs spécifiant le nombre et le type de boutons à afficher, le style d'icône à utiliser, l'identité du bouton par défaut, ainsi que la modalité du message. Si l'argument <paramref name="Buttons" /> est omis, la valeur par défaut est zéro.</param>
        <param name="Title">Optionnel. Expression <see langword="String" /> affichée dans la barre de titre de la boîte de dialogue. Si l'argument <paramref name="Title" /> est omis, le nom de l'application est placé dans la barre de titre.</param>
        <summary>Affiche un message dans une boîte de dialogue, attend que l'utilisateur clique sur un bouton, puis retourne un nombre entier qui indique le bouton choisi par l'utilisateur.</summary>
        <returns><list type="table">
            <item>
              <term> Constante 
 </term>
              <description> Value 
 </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 
 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 
 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 
 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 
 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 
 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 
 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 
 </description>
            </item>
          </list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous omettez les arguments positionnels, vous devez conserver la virgule de séparation correspondante.  
  
 Si la boîte de dialogue affiche un **Annuler** bouton, en appuyant sur la touche ÉCHAP a le même effet qu’un clic sur **Annuler**  
  
 Si la boîte de dialogue contient un **aide** bouton, l’aide contextuelle est disponible pour la boîte de dialogue. Toutefois, aucune valeur n’est retournée jusqu'à ce qu’un des autres boutons est choisi. Dans les applications Windows Form, en choisissant le **aide** bouton exécute le <xref:System.Windows.Forms.Control.HelpRequested> pour le formulaire.  
  
> [!NOTE]
>  Le `MsgBox` fonction requiert `UIPermission` à la <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> niveau, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d'informations, consultez <xref:System.Security.Permissions.UIPermission>.  
  
 Le `MsgBoxStyle` valeurs d’énumération sont répertoriés dans le tableau suivant.  
  
|Membre|Value|Description |  
|-|-|-|  
|Membre|Value|Description |  
|`OKOnly`|0|Bouton affiche OK uniquement.|  
|`OKCancel`|1|Affiche OK et Annuler boutons.|  
|`AbortRetryIgnore`|2|Affiche les boutons Abandonner, réessayer et ignorer.|  
|`YesNoCancel`|3|Affiche Yes, No et les boutons d’annulation.|  
|`YesNo`|4|N’affiche les boutons Oui et.|  
|`RetryCancel`|5|Affiche les boutons Réessayer et Annuler.|  
|`Critical`|16|Affiche l’icône Message critique.|  
|`Question`|32|Affiche l’icône requête d’avertissement.|  
|`Exclamation`|48|Affiche l’icône Message d’avertissement.|  
|`Information`|64|Affiche l’icône Message d’Information.|  
|`DefaultButton1`|0|Le premier bouton est la valeur par défaut.|  
|`DefaultButton2`|256|Le deuxième bouton est la valeur par défaut.|  
|`DefaultButton3`|512|Le troisième bouton est la valeur par défaut.|  
|`ApplicationModal`|0|L’application est modale. L’utilisateur doit répondre à la boîte de message avant de continuer à travailler dans l’application actuelle.|  
|`SystemModal`|4096|Le système est modal. Toutes les applications sont interrompues jusqu'à ce que l’utilisateur réponde à la boîte de message.|  
|`MsgBoxSetForeground`|65536|Spécifie la fenêtre de message en tant que la fenêtre de premier plan.|  
|`MsgBoxRight`|524288|Texte est aligné à droite.|  
|`MsgBoxRtlReading`|1048576|Spécifie le texte doit apparaître de droite à gauche sur les systèmes hébreu et arabe.|  
  
 Le premier groupe de valeurs (0-5) décrit le nombre et le type de boutons affichés dans la boîte de dialogue. Le deuxième groupe (16, 32, 48, 64) décrit le style d’icône. Le troisième groupe (0, 256, 512) détermine quel bouton est la valeur par défaut. Le quatrième groupe (0, 4096) détermine la modalité de la boîte de message et le cinquième groupe spécifie si la fenêtre de message est la fenêtre de premier plan, ainsi que l’alignement et la direction du texte. Lors de l’ajout de nombres pour créer une valeur finale pour le `Buttons` argument, utilisez uniquement un numéro de chaque groupe.  
  
   
  
## Examples  
 Cet exemple utilise le `MsgBox` (fonction) pour afficher un message d’erreur critique dans une boîte de dialogue avec les boutons Oui et non. Le bouton No est spécifié en tant que la réponse par défaut. Cela est effectué en combinant le `MsgBox` des valeurs constantes dans une expression numérique. Dans ce cas, l’addition de 4 (la combinaison des boutons Oui/non) et 16 (le **Message critique** fenêtre) et 256 (le deuxième bouton comme bouton par défaut) donne un total de 276. La valeur retournée par la `MsgBox` fonction dépend du bouton choisi par l’utilisateur : Oui retourne une valeur de 6 ; Aucun retourne une valeur de 7.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Prompt" /> n'est pas une expression <see langword="String" /> ou <paramref name="Title" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Le processus ne s'exécute pas en mode utilisateur interactif.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Au moins un paramètre n'est pas un membre de l'énumération <see langword="MsgBoxResult" /> ou <see langword="MsgBoxStyle" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Start" Type="System.Int64" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Stop" Type="System.Int64" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Interval" Type="System.Int64" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Number">Obligatoire. <see langword="Long" />. Nombre entier que vous souhaitez localiser dans l'une des plages calculées.</param>
        <param name="Start">Obligatoire. <see langword="Long" />. Nombre entier qui indique le début de l'ensemble des plages calculées. <paramref name="Start" /> ne peut pas être inférieur à 0.</param>
        <param name="Stop">Obligatoire. <see langword="Long" />. Nombre entier qui indique la fin de l'ensemble des plages calculées. <paramref name="Stop" /> ne peut pas être inférieur ou égal à <paramref name="Start" />.</param>
        <param name="Interval">Obligatoire. <see langword="Long" />. Nombre entier qui indique la taille de chacune des plages calculées entre <paramref name="Start" /> et <paramref name="Stop" />. <paramref name="Interval" /> ne peut pas être inférieur à 1.</param>
        <summary>Retourne une chaîne représentant la plage calculée qui contient un nombre.</summary>
        <returns>Une chaîne représentant la plage calculée qui contient un nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Partition` fonction calcule un ensemble de plages numériques, chacune contenant le nombre de valeurs spécifiées par `Interval`. La première plage commence à `Start`, et la dernière plage se termine à `Stop`. Le `Partition` fonction identifie ensuite la plage qui contient `Number` et retourne une chaîne décrivant cette plage. La plage est représentée dans la chaîne en tant que «*lowervalue*:*uppervalue*», où la partie inférieure de la plage (*lowervalue*) est séparé du haut de gamme ( *uppervalue*) par un signe deux-points ( :)).  
  
 Si nécessaire, le `Partition` fonction insère des espaces avant *lowervalue* et *uppervalue* afin qu’ils ont tous deux le même nombre de caractères que la représentation sous forme de chaîne de la valeur ( `Stop` + 1). Cela garantit que si vous utilisez la sortie de la `Partition` fonction avec plusieurs valeurs de `Number`, le texte résultant sera correctement géré lors de toute opération de tri suivantes.  
  
 Le tableau suivant présente certains exemples de chaînes pour des plages calculées à l’aide de trois ensembles de `Start`, `Stop`, et `Interval`. Le « colonnes première plage » et « Dernière plage » illustrent les les plus élevés plages possibles attribuées aux valeurs de `Start` et `Stop`. Le « avant première plage » et « après la dernière plage » colonnes indiquent les chaînes retournées pour les valeurs de `Number` inférieure à `Start` et supérieur à `Stop`, respectivement.  
  
|`Start`|`Stop`|`Interval`|Avant la première plage|Première plage|Dernière plage|Après la dernière plage|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"  0:  4"|" 95: 99"|"100:   "|  
|20|199|10|"   : 19"|" 20: 29"|"190:199"|"200:   "|  
|100|1010|20|"    : 99"|" 100: 119"|"1000:1010"|"1011:    "|  
  
 Dans le tableau précédent, la troisième ligne présente le résultat lorsque `Start` et `Stop` définir un ensemble de nombres qui ne peut pas être divisé par `Interval`. La dernière plage se termine à `Stop`, rendant 11 nombres, même si `Interval` est 20.  
  
 Si `Interval` est 1, la plage est «`Number`:`Number`», quel que soit le `Start` et `Stop` arguments. Par exemple, si `Number` est 267 `Stop` 1 000, et `Interval` est 1, `Partition` retourne « 267 : 267".  
  
 `Partition` peut être utile lors de la construction des requêtes de base de données. Vous pouvez créer une requête SELECT qui indique le nombre de commandes produire dans les plages de valeurs différentes, par exemple avec les valeurs de la facture de 1 à 1000, 1001 à 2000 et ainsi de suite.  
  
   
  
## Examples  
 L’exemple suivant définit une série de plages depuis des décennies de 1950 à 2049. Il localise la valeur de `year` au sein de la plage appropriée et retourne un `String` qui affiche la plage de valeur. Si `year` a la valeur 1984, par exemple, `Partition` retourne « 1980 : 1989 ».  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" /> ou <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Setting" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatoire. Expression <see langword="String" /> contenant le nom de l'application ou du projet auquel le paramètre s'applique.</param>
        <param name="Section">Obligatoire. Expression <see langword="String" /> contenant le nom de la section dans laquelle le paramètre de clé est enregistré.</param>
        <param name="Key">Obligatoire. Expression <see langword="String" /> contenant le nom du paramètre de clé enregistré.</param>
        <param name="Setting">Obligatoire. Expression contenant la valeur avec laquelle <paramref name="Key" /> est définie.</param>
        <summary>Enregistre ou crée une entrée d'application d'entrée dans la base de registres Windows. L'utilisation de la fonctionnalité <see langword="My" /> vous permet une meilleure productivité et de meilleures performances dans les opérations de Registre que <see langword="SaveSetting" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `SaveSetting` fonction ajoute la clé à `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Si le paramètre de clé ne peut pas être enregistré pour une raison quelconque, une erreur se produit.  
  
 `SaveSetting` nécessite qu’un utilisateur soit connecté car elle fonctionne sous le `HKEY_LOCAL_USER` clé de Registre qui n’est pas actif jusqu'à ce qu’un utilisateur se connecte manière interactive.  
  
 Les paramètres de Registre qui sont accessibles à partir d’un processus non interactif (par exemple, Mtx.exe) doivent être stockés sous la `HKEY_LOCAL_MACHINE\Software\` ou `HKEY_USER\DEFAULT\Software` clés de Registre.  
  
 `SaveSetting` requiert `Write` et `Create` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 L’exemple suivant utilise d’abord la `SaveSetting` fonction permettant de créer des entrées dans le Registre Windows pour le `MyApp` application, puis utilise le `DeleteSetting` (fonction) pour les supprimer.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La clé du Registre n'a pas pu être créée ou l'utilisateur n'est pas connecté.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lecture et écriture dans le Registre (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Pathname">Obligatoire. <see langword="String" />. Nom du programme à exécuter, ainsi que les arguments et les commutateurs de ligne de commande requis. <paramref name="PathName" /> peut également inclure le lecteur et le chemin d'accès au répertoire ou au dossier.
Si vous ne connaissez pas le chemin d'accès au programme, vous pouvez utiliser le <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> pour le rechercher. Par exemple, vous pouvez appeler <c>My.Computer.FileSystem.GetFiles ("C:\", True, "testFile.txt")</c>, qui retourne le chemin d’accès complet de chaque fichier nommé <c>testFile.txt</c> sur le lecteur C:\\.</param>
        <param name="PathName">Obligatoire. <see langword="String" />. Nom du programme à exécuter, ainsi que les arguments et les commutateurs de ligne de commande requis. <paramref name="PathName" /> peut également inclure le lecteur et le chemin d'accès au répertoire ou au dossier.  
 Si vous ne connaissez pas le chemin d'accès au programme, vous pouvez utiliser le <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> pour le rechercher. Par exemple, vous pouvez appeler <c>My.Computer.FileSystem.GetFiles ("C:\", True, "testFile.txt")</c>, qui retourne le chemin d’accès complet de chaque fichier nommé <c>testFile.txt</c> sur le lecteur C:\\.</param>
        <param name="Style">Optionnel. <see langword="AppWinStyle" />. Valeur choisie à partir du <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> spécifiant le style de la fenêtre dans laquelle le programme doit être exécuté. Si <paramref name="Style" /> est omis, <see langword="Shell" /> utilise <see langword="AppWinStyle.MinimizedFocus" />, le programme est activé et la fenêtre est réduite.</param>
        <param name="Wait">Optionnel. <see langword="Boolean" />. Valeur indiquant si la fonction <see langword="Shell" /> doit attendre la fin du programme. Si <paramref name="Wait" /> est omis, <see langword="Shell" /> utilise <see langword="False" />.</param>
        <param name="Timeout">Optionnel. <see langword="Integer" />. Nombre de millisecondes à attendre avant la fin du programme si <paramref name="Wait" /> a la valeur <see langword="True" />. Si <paramref name="Timeout" /> est omis, <see langword="Shell" /> utilise -1 : il n'y a donc aucun délai et <see langword="Shell" /> ne retourne aucune valeur jusqu'à la fin du programme. Ainsi, si vous omettez <paramref name="Timeout" /> ou si vous lui affectez -1, il est possible que <see langword="Shell" /> ne retourne jamais le contrôle à votre programme.</param>
        <summary>Exécute un programme exécutable et retourne un entier contenant l'ID du processus du programme s'il est toujours en cours d'exécution.</summary>
        <returns>Entier contenant l’ID du processus du programme s’il est toujours en cours d’exécution. 0 si le programme a déjà terminé l’exécution.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de retour de la `Shell` fonction varie selon que le programme nommé dans `PathName` est en cours d’exécution lorsque `Shell` retourne. Si vous définissez `Wait` à `True` et le programme se termine avant l’expiration du délai, `Shell` retourne la valeur zéro. Si le délai expire ou si vous omettez `Wait` ou affectez-lui la valeur `False`, `Shell` retourne l’ID de processus du programme. L’ID de processus est un nombre unique qui identifie le programme en cours d’exécution.  
  
## <a name="failure-to-start"></a>Échec de démarrage  
 Si le `Shell` fonction ne peut pas démarrer le programme nommé, un <xref:System.IO.FileNotFoundException> erreur se produit. Cela peut se produire, par exemple, lorsque vous tentez d’exécuter un programme 16 bits, tel que `command.com`, à partir d’une application à l’aide <xref:System.Windows.Forms?displayProperty=nameWithType>. Pour résoudre ce problème, vous pouvez exécuter un programme 32 bits qui appelle le programme 16 bits souhaité. Dans le cas de `command.com`, vous pouvez exécuter `cmd.exe` en guise d’alternative.  
  
## <a name="waiting-for-completion"></a>En attente d’achèvement  
 Par défaut, le `Shell` fonction exécute le programme de façon asynchrone. Cela signifie qu’un programme démarré avec le `Shell` (fonction) peut ne pas s’exécuter avant les instructions situées après le `Shell` (fonction) sont exécutées. Si vous voulez attendre pour le programme se termine avant de continuer, définissez `Wait` à `True`.  
  
## <a name="determining-the-exit-code"></a>Déterminer le Code de sortie  
 Un processus peut retourner un *code de sortie* quand il se termine. Toutefois, vous ne pouvez pas utiliser `Shell` pour récupérer ce code de sortie, car `Shell` retourne zéro s’il attend l’arrêt et également parce que le processus s’exécute dans un objet différent de `Shell`.  
  
 Pour récupérer le code de sortie à partir d’un processus, vous devez écrire votre propre code pour lancer le processus et attendre la fin de contrat. L’exemple suivant montre comment initier un processus, attendez qu’elle se terminer et récupérer son code de sortie.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>Protection de la spécification de fichier  
 Vous devez toujours mettre toute la spécification de chemin d’accès et de fichier entre guillemets, comme le montre l’exemple suivant.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Chaque paire de guillemets doubles adjacents (`" "`) dans la chaîne de littéral est interprété comme un double caractère de guillemet dans la chaîne. Par conséquent, l’exemple précédent présente la chaîne suivante à la `Shell` (fonction) :  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Si vous n’avez pas le chemin d’accès entre guillemets, Windows recherche un fichier appelé `Program.exe` dans le répertoire C:\, au lieu de `display.exe` dans le répertoire C:\Program Files.  
  
> [!IMPORTANT]
>  Si vous ne placez pas la spécification de chemin d’accès et de fichier entre guillemets, existe un risque de sécurité si le nom de fichier ou un nœud de chemin d’accès contient des espaces. Dans l’exemple précédent, le nœud de chemin d’accès `\Program Files` inclut un espace. Si la spécification n’était pas entre guillemets et un programme nommé `Program.exe` avait été installé dans C:\\, par exemple de manière illicite, Windows l’aurait exécuté au lieu de `display.exe`.  
  
> [!IMPORTANT]
>  Le `Shell` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 L’exemple suivant utilise le `Shell` fonction à exécuter une application spécifiée par l’utilisateur. En spécifiant <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> comme deuxième argument ouvre l’application dans sa taille d’origine et lui donne le focus.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Style" /> se trouve en dehors de la plage de 0 à 9 compris.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><see langword="Shell" /> ne peut pas trouver le fichier <paramref name="PathName" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="PathName" /> est <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Obligatoire. Tableau de paramètres <see langword="Object" />. Doit comprendre un nombre pair d'éléments. Vous pouvez fournir une liste de variables ou d'expressions <see langword="Object" /> séparées par des virgules, ou un tableau unidimensionnel d'éléments <see langword="Object" />.</param>
        <summary>Évalue une liste d'expressions et retourne une valeur <see langword="Object" /> correspondant à la première expression de la liste qui est <see langword="True" />.</summary>
        <returns>Évalue une liste d'expressions et retourne une valeur <see langword="Object" /> correspondant à la première expression de la liste qui est <see langword="True" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’argument fourni à `VarExpr` se compose d’expressions et de valeurs. Le `Switch` fonction évalue les expressions impaires à partir de la plus basse à l’index le plus élevé dans `VarExpr`et retourne la valeur paire associée à la première expression qui prend la valeur `True`. Par exemple, si `VarExpr(0)` est `True`, `Switch` retourne `VarExpr(1)`et si `VarExpr(0)` est `False` mais `VarExpr(2)` est `True`, `Switch` retourne `VarExpr(3)`, et ainsi de suite.  
  
 Si vous ne fournissez pas le `VarExpr` argument, `Switch` retourne `Nothing`.  
  
> [!NOTE]
>  Les expressions dans la liste d’arguments peuvent inclure des appels de fonction. Dans le cadre de la préparation de la liste d’arguments pour l’appel à `Switch`, le compilateur Visual Basic appelle chaque fonction de chaque expression. Cela signifie que vous ne pouvez pas compter sur une fonction particulière sera appelée si une expression plus haut dans la liste d’arguments est `True`.  
  
   
  
## Examples  
 L’exemple suivant utilise le `Switch` fonction pour retourner le nom d’une langue qui correspond au nom d’une ville. Il requiert que `Option Strict` être `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Étant donné que le <xref:System.Diagnostics> espace de noms contient également une classe appelée <xref:System.Diagnostics.Switch>, un appel à la `Switch` fonction doit être qualifiée avec le <xref:Microsoft.VisualBasic> espace de noms.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nombre impair d'arguments</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case, instruction (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Tableaux de paramètres</related>
      </Docs>
    </Member>
  </Members>
</Type>