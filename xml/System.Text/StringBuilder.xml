<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8329e2db3ee82e0cdf4f3d48d2130cafc22833e8" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52228137" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une chaîne de caractères mutable. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe représente un objet chaîne dont la valeur est une séquence de caractères mutable.  
  
 Dans cette section :  
  
-   [Les types String et StringBuilder](#StringAndSB)  
  
-   [Fonctionne de StringBuilder](#HowWorks)  
  
-   [Allocation de mémoire](#Memory)  
  
-   [Instanciation d’un objet StringBuilder](#Instantiating)  
  
-   [Appel des méthodes de StringBuilder](#Calling)  
  
-   [Exécution d’opérations de StringBuilder](#Operations)  
  
    -   [Itération des caractères de StringBuilder](#Iterating)  
  
    -   [Ajout de texte à un objet StringBuilder](#Adding)  
  
    -   [Suppression de texte à partir d’un objet StringBuilder](#Deleting)  
  
    -   [Modifier le texte dans un objet StringBuilder](#Modifying)  
  
-   [Recherche le texte dans un objet StringBuilder](#Searching)  
  
-   [Conversion de l’objet StringBuilder en une chaîne](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Les types String et StringBuilder  
 Bien que <xref:System.Text.StringBuilder> et <xref:System.String> tous deux représentent des séquences de caractères, ils sont implémentés différemment. <xref:System.String> est un type immuable. Autrement dit, chaque opération qui s’affiche pour modifier un <xref:System.String> objet crée en fait une nouvelle chaîne.  
  
 Par exemple, l’appel à la <xref:System.String.Concat%2A?displayProperty=nameWithType> méthode dans l’exemple c# suivant s’affiche pour modifier la valeur d’une variable chaîne nommée `value`. En fait, le <xref:System.String.Concat%2A> méthode retourne un `value` objet qui a une valeur différente et une adresse à partir de la `value` objet qui a été passé à la méthode. Notez que l’exemple doit être compilé à l’aide de la `/unsafe` option du compilateur.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Pour les routines qui effectuent la manipulation de chaînes étendues (comme les applications qui modifient une chaîne de plusieurs fois dans une boucle), la modification d’une chaîne à plusieurs reprises peut peser sensiblement les performances. L’alternative consiste à utiliser <xref:System.Text.StringBuilder>, qui est une classe de chaîne mutable. Mutabilité signifie qu’une fois qu’une instance de la classe a été créée, elle peut être modifiée en ajoutant, supprimant, en remplaçant ou en insérant des caractères de. Un <xref:System.Text.StringBuilder> objet gère une mémoire tampon pour prendre en charge d’expansion à la chaîne. Nouvelles données sont ajoutées à la mémoire tampon si l’espace est disponible ; Sinon, une mémoire tampon de nouveau, plus grande est allouée, les données à partir de la mémoire tampon d’origine sont copiées vers la nouvelle mémoire tampon et les nouvelles données sont ensuite ajoutées à la nouvelle mémoire tampon.  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Text.StringBuilder> classe offre généralement de meilleures performances que le <xref:System.String> (classe), vous ne devez pas remplacer automatiquement <xref:System.String> avec <xref:System.Text.StringBuilder> chaque fois que vous voulez manipuler des chaînes. Performances dépendent de la taille de la chaîne, la quantité de mémoire à allouer pour la nouvelle chaîne, le système sur lequel votre application s’exécute et le type d’opération. Vous devez être prêt à tester votre application pour déterminer si <xref:System.Text.StringBuilder> offre en fait une amélioration significative des performances.  
  
 Envisagez d’utiliser la <xref:System.String> classe dans ces conditions :  
  
-   Lorsque le nombre de modifications pour rendre votre application vers une chaîne est faible. Dans ce cas, <xref:System.Text.StringBuilder> peut offre négligeable ou aucune amélioration des performances par rapport à <xref:System.String>.  
  
-   Lorsque vous effectuez un nombre fixe d’opérations de concaténation, en particulier avec les littéraux de chaîne. Dans ce cas, le compilateur peut combiner les opérations de concaténation en une seule opération.  
  
-   Lorsque vous devez effectuer des opérations de recherche étendue pendant la création de votre chaîne. Le <xref:System.Text.StringBuilder> n’a pas de classe telles que des méthodes de recherche `IndexOf` ou `StartsWith`. Vous devrez convertir le <xref:System.Text.StringBuilder> de l’objet à un <xref:System.String> pour ces opérations et cela peuvent nier l’amélioration des performances de l’utilisation de <xref:System.Text.StringBuilder>. Pour plus d’informations, consultez le [recherche le texte dans un objet StringBuilder](#Searching) section.  
  
 Envisagez d’utiliser la <xref:System.Text.StringBuilder> classe dans ces conditions :  
  
-   Si vous pensez que votre application pour vérifier un nombre inconnu de modifications à une chaîne au moment du design (par exemple, lorsque vous utilisez une boucle pour concaténer un nombre aléatoire de chaînes qui contiennent des entrées d’utilisateur).  
  
-   Si vous pensez que votre application pour vérifier un nombre important de modifications à une chaîne.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Fonctionne de StringBuilder  
 Le <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> propriété indique le nombre de caractères le <xref:System.Text.StringBuilder> objet contient actuellement. Si vous ajoutez des caractères à la <xref:System.Text.StringBuilder> de l’objet, sa longueur augmente jusqu'à ce qu’elle est égale à la taille de la <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propriété, qui définit le nombre de caractères que l’objet peut contenir. Si le nombre de caractères ajoutés provoque la longueur de la <xref:System.Text.StringBuilder> objet à dépasser sa capacité actuelle, la nouvelle mémoire est allouée, la valeur de la <xref:System.Text.StringBuilder.Capacity%2A> propriété est doublée, de nouveaux caractères sont ajoutés à la <xref:System.Text.StringBuilder> objet et ses <xref:System.Text.StringBuilder.Length%2A>propriété est ajustée. Une mémoire supplémentaire pour le <xref:System.Text.StringBuilder> objet est alloué de façon dynamique jusqu'à ce qu’il atteigne la valeur définie par le <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> propriété. Lorsque la capacité maximale est atteinte, aucune mémoire supplémentaire ne pouvant être allouée pour le <xref:System.Text.StringBuilder> objet et essaie d’ajouter des caractères ou développez-le au-delà de sa capacité maximale lève soit une <xref:System.ArgumentOutOfRangeException> ou un <xref:System.OutOfMemoryException> exception.  
  
 L’exemple suivant illustre comment un <xref:System.Text.StringBuilder> objet alloue de la nouvelle mémoire et augmente dynamiquement sa capacité développe la chaîne assignée à l’objet. Le code crée un <xref:System.Text.StringBuilder> objet en appelant son constructeur (sans paramètre) par défaut. La capacité par défaut de cet objet est 16 caractères, et sa capacité maximale est de plus de 2 milliards de caractères. Ajout de la chaîne « Il s’agit d’une phrase. » génère une nouvelle allocation de mémoire, car la longueur de chaîne (19 caractères) dépasse la capacité par défaut de la <xref:System.Text.StringBuilder> objet. La capacité de l’objet double à 32 caractères, la nouvelle chaîne est ajoutée, et la longueur de l’objet est désormais égal à 19 caractères. Le code ajoute ensuite la chaîne « Il s’agit d’une phrase supplémentaire. » la valeur de la <xref:System.Text.StringBuilder> 11 fois de l’objet. Chaque fois que l’opération d’ajout entraîne la longueur de la <xref:System.Text.StringBuilder> dépasser sa capacité, sa capacité existante à l’objet est doublé et <xref:System.Text.StringBuilder.Append%2A> opération réussit.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Allocation de mémoire  
 La capacité par défaut d’un <xref:System.Text.StringBuilder> objet est 16 caractères, et sa capacité maximale par défaut est <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Ces valeurs par défaut sont utilisées si vous appelez le <xref:System.Text.StringBuilder.%23ctor> et <xref:System.Text.StringBuilder.%23ctor%28System.String%29> constructeurs.  
  
 Vous pouvez définir explicitement la capacité initiale d’un <xref:System.Text.StringBuilder> objet comme suit :  
  
-   En appelant une de le <xref:System.Text.StringBuilder> constructeurs incluant un `capacity` paramètre lorsque vous créez l’objet.  
  
-   En affectant explicitement une nouvelle valeur à la <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propriété à développer un existant <xref:System.Text.StringBuilder> objet. Notez que la propriété lève une exception si la nouvelle capacité est inférieure à existant la capacité ou supérieur à la <xref:System.Text.StringBuilder> capacité maximale de l’objet.  
  
-   En appelant le <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> méthode avec la nouvelle capacité. La nouvelle capacité ne doit pas être supérieure à la <xref:System.Text.StringBuilder> capacité maximale de l’objet. Toutefois, contrairement à une assignation à la <xref:System.Text.StringBuilder.Capacity%2A> propriété, <xref:System.Text.StringBuilder.EnsureCapacity%2A> ne lève pas d’exception si la nouvelle capacité souhaitée est inférieure à la capacité existante ; dans ce cas, l’appel de méthode n’a aucun effet.  
  
 Si la longueur de la chaîne assignée à la <xref:System.Text.StringBuilder> objet dans l’appel de constructeur dépasse la capacité par défaut ou la capacité spécifiée, le <xref:System.Text.StringBuilder.Capacity%2A> propriété est définie à la longueur de la chaîne spécifiée avec la `value` paramètre.  
  
 Vous pouvez définir explicitement la capacité maximale d’une <xref:System.Text.StringBuilder> objet en appelant le <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> constructeur. Vous ne pouvez pas modifier la capacité maximale en affectant une nouvelle valeur à la <xref:System.Text.StringBuilder.MaxCapacity%2A> propriété, car il est en lecture seule.  
  
 La section précédente montre, chaque fois que la capacité existante est inadéquate, plu de mémoire est allouée et la capacité d’un <xref:System.Text.StringBuilder> doubles jusqu'à la valeur définie par l’objet le <xref:System.Text.StringBuilder.MaxCapacity%2A> propriété.  
  
 En règle générale, la capacité par défaut et la capacité maximale sont adéquates pour la plupart des applications. Vous pouvez envisager de configurer ces valeurs dans les conditions suivantes :  
  
-   Si la taille finale de la <xref:System.Text.StringBuilder> objet est susceptible de devenir extrêmement volumineux, généralement dépassant plusieurs mégaoctets. Dans ce cas, il peut y avoir des gains de performance de la configuration initial <xref:System.Text.StringBuilder.Capacity%2A> propriété à une valeur très élevée pour éliminer la nécessité pour les réallocations trop de mémoire.  
  
-   Si votre application s’exécute sur un système à mémoire limitée. Dans ce cas, vous souhaiterez paramètre la <xref:System.Text.StringBuilder.MaxCapacity%2A> propriété inférieur à <xref:System.Int32.MaxValue?displayProperty=nameWithType> si votre application gère les chaînes de grande taille qui peuvent s’exécuter dans un environnement limité en mémoire.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Instanciation d’un objet StringBuilder  
 Vous instanciez un <xref:System.Text.StringBuilder> objet en appelant une de ses six constructeurs de classe surchargés, qui sont répertoriées dans le tableau suivant. Trois constructeurs instancier un <xref:System.Text.StringBuilder> objet dont la valeur est une chaîne vide, mais définir son <xref:System.Text.StringBuilder.Capacity%2A> et <xref:System.Text.StringBuilder.MaxCapacity%2A> valeurs différemment. Les trois autres constructeurs définissent un <xref:System.Text.StringBuilder> objet qui possède une valeur de chaîne spécifique et la capacité. Deux des trois constructeurs utilisent la capacité maximale par défaut de <xref:System.Int32.MaxValue?displayProperty=nameWithType>, tandis que le troisième vous permet de définir la capacité maximale.  
  
|Constructeur|Valeur de chaîne|Capacité|Capacité maximale|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Défini par le `capacity` paramètre|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Défini par le `capacity` paramètre|Défini par le `maxCapacity` paramètre|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Défini par le `value` paramètre|16 ou `value`. <xref:System.String.Length%2A>, deux valeurs étant retenue|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Défini par le `value` paramètre|Défini par le `capacity` paramètre ou `value`. <xref:System.String.Length%2A>, deux valeurs étant retenue.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Défini par `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Défini par le `capacity` paramètre ou `value`. <xref:System.String.Length%2A>, deux valeurs étant retenue.|Défini par le `maxCapacity` paramètre|  
  
 L’exemple suivant utilise trois de ces surcharges de constructeur pour instancier <xref:System.Text.StringBuilder> objets.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Appel des méthodes de StringBuilder  
 La plupart des méthodes qui modifient la chaîne dans un <xref:System.Text.StringBuilder> instance retournent une référence à cette même instance. Cela vous permet d’appeler <xref:System.Text.StringBuilder> méthodes de deux manières :  
  
-   Vous pouvez effectuer des appels de méthode individuelle et ignorer la valeur de retour, comme dans l’exemple suivant.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Vous pouvez effectuer une série d’appels de méthode dans une instruction unique. Cela peut être pratique si vous souhaitez écrire une instruction unique qui associe plusieurs opérations successives. L’exemple suivant regroupe trois appels de méthode à partir de l’exemple précédent en une seule ligne de code.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Exécution d’opérations de StringBuilder  
 Vous pouvez utiliser les méthodes de la <xref:System.Text.StringBuilder> classe pour effectuer une itération, ajouter, supprimer ou modifier les caractères d’un <xref:System.Text.StringBuilder> objet.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Itération des caractères de StringBuilder  
 Vous pouvez accéder aux caractères dans un <xref:System.Text.StringBuilder> objet à l’aide de la <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriété. En c#, <xref:System.Text.StringBuilder.Chars%2A> est un indexeur ; en Visual Basic, il est la propriété par défaut de la <xref:System.Text.StringBuilder> classe. Cela vous permet de définir ou extraire des caractères individuels à l’aide de leur index uniquement, sans référencer explicitement le <xref:System.Text.StringBuilder.Chars%2A> propriété. Caractères dans un <xref:System.Text.StringBuilder> objet commence à l’index 0 (zéro) et continue à indexer <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 L’exemple suivant illustre le <xref:System.Text.StringBuilder.Chars%2A> propriété. Il ajoute dix nombres aléatoires à une <xref:System.Text.StringBuilder> de l’objet, puis itère au sein de chaque caractère. Si la catégorie du caractère Unicode est <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, il réduit le nombre de 1 (ou modifie le nombre à 9 si sa valeur est 0). L’exemple affiche le contenu de la <xref:System.Text.StringBuilder> de l’objet à la fois avant et après les valeurs de caractères individuels ont été modifiés.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Ajout de texte à un objet StringBuilder  
 Le <xref:System.Text.StringBuilder> classe comprend les méthodes suivantes pour développer le contenu d’un <xref:System.Text.StringBuilder> objet :  
  
-   Le <xref:System.Text.StringBuilder.Append%2A> méthode ajoute une chaîne, une sous-chaîne, un tableau de caractères, une partie d’un tableau de caractères, un seul caractère répété plusieurs fois, ou la représentation sous forme de chaîne de données primitif le type à un <xref:System.Text.StringBuilder> objet.  
  
-   Le <xref:System.Text.StringBuilder.AppendLine%2A> méthode ajoute un terminateur de ligne ou une chaîne avec un terminateur de ligne dans un <xref:System.Text.StringBuilder> objet.  
  
-   Le <xref:System.Text.StringBuilder.AppendFormat%2A> méthode ajoute un à un <xref:System.Text.StringBuilder> objet. Les représentations sous forme de chaîne d’objets inclus dans la chaîne de résultat peuvent refléter les conventions de mise en forme de la culture système actuelle ou une culture spécifiée.  
  
-   Le <xref:System.Text.StringBuilder.Insert%2A> méthode insère une chaîne, une sous-chaîne, plusieurs répétitions d’une chaîne, un tableau de caractères, une partie d’un tableau de caractères, ou la représentation sous forme de chaîne de données primitif type à une position spécifiée dans le <xref:System.Text.StringBuilder> objet. La position est définie par un index de base zéro.  
  
 L’exemple suivant utilise le <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, et <xref:System.Text.StringBuilder.Insert%2A> méthodes pour développer le texte d’un <xref:System.Text.StringBuilder> objet.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Suppression de texte à partir d’un objet StringBuilder  
 Le <xref:System.Text.StringBuilder> classe inclut des méthodes qui peuvent réduire la taille de l’actuel <xref:System.Text.StringBuilder> instance. Le <xref:System.Text.StringBuilder.Clear%2A> méthode supprime tous les caractères et définit le <xref:System.Text.StringBuilder.Length%2A> propriété à zéro. Le <xref:System.Text.StringBuilder.Remove%2A> méthode supprime un nombre spécifié de caractères en commençant à une position d’index particulière. En outre, vous pouvez supprimer des caractères à partir de la fin d’un <xref:System.Text.StringBuilder> objet en définissant son <xref:System.Text.StringBuilder.Length%2A> propriété une valeur qui est inférieure à la longueur de l’instance actuelle.  
  
 L’exemple suivant supprime une partie du texte à partir d’un <xref:System.Text.StringBuilder> objet, affiche sa capacité qui en résulte, capacité maximale et les valeurs de propriété de longueur, puis appelle la <xref:System.Text.StringBuilder.Clear%2A> méthode pour supprimer tous les caractères de la <xref:System.Text.StringBuilder> objet.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Modifier le texte dans un objet StringBuilder  
 Le <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> méthode remplace toutes les occurrences d’un caractère ou une chaîne dans l’ensemble <xref:System.Text.StringBuilder> objet ou dans une plage de caractères particulier. L’exemple suivant utilise le <xref:System.Text.StringBuilder.Replace%2A> méthode pour remplacer tous les points d’exclamation ( !) avec des points d’interrogation ( ?) dans le <xref:System.Text.StringBuilder> objet.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Recherche le texte dans un objet StringBuilder  
 Le <xref:System.Text.StringBuilder> classe n’inclut pas de méthodes similaires à la <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, et <xref:System.String.StartsWith%2A?displayProperty=nameWithType> méthodes fournies par le <xref:System.String> (classe), ce qui vous permet de rechercher l’objet pour un caractère particulier ou d’une sous-chaîne. Déterminer la présence ou la position de caractère d’une sous-chaîne de départ nécessite que vous recherchez un <xref:System.String> valeur à l’aide d’une méthode de recherche de chaîne ou une méthode d’expression régulière. Il existe quatre façons d’implémenter ces recherches, comme le tableau suivant.  
  
|Technique|Professionnels de l'|Inconvénients|  
|---------------|----------|----------|  
|Rechercher des valeurs de chaîne avant de les ajouter à la <xref:System.Text.StringBuilder> objet.|Utile pour déterminer si une sous-chaîne existe.|Ne peut pas être utilisé lors de la position d’index d’une sous-chaîne est importante.|  
|Appelez <xref:System.Text.StringBuilder.ToString%2A> et rechercher le texte retourné <xref:System.String> objet.|Facile à utiliser si vous attribuez tout le texte à un <xref:System.Text.StringBuilder> de l’objet et commencez à le modifier.|Fastidieux d’appeler à plusieurs reprises <xref:System.Text.StringBuilder.ToString%2A> si vous devez apporter des modifications avant que tout le texte est ajouté à la <xref:System.Text.StringBuilder> objet.<br /><br /> Vous devez penser à travailler à partir de la fin de la <xref:System.Text.StringBuilder> texte de l’objet si vous apportez des modifications.|  
|Utilisez le <xref:System.Text.StringBuilder.Chars%2A> propriété à rechercher de manière séquentielle une plage de caractères.|Utile si vous êtes concerné avec des caractères ou une sous-chaîne petite.|Fastidieuse si le nombre de caractères à rechercher est élevé ou si la logique de recherche est complexe.<br /><br />Résultats de performances très médiocres pour les objets qui se sont très volumineux via des appels de méthode répétées.  |  
|Convertir le <xref:System.Text.StringBuilder> de l’objet à un <xref:System.String> de l’objet et effectuez des modifications sur le <xref:System.String> objet.|Utile si le nombre de modifications est faible.|Inverse l’amélioration des performances de la <xref:System.Text.StringBuilder> classe si le nombre de modifications est élevé.|  
  
 Nous allons examiner ces techniques plus en détail.  
  
-   Si l’objectif de la recherche doit déterminer si une sous-chaîne particulière existe (autrement dit, si vous n’êtes pas intéressé par la position de la sous-chaîne), vous pouvez rechercher des chaînes avant de les stocker dans le <xref:System.Text.StringBuilder> objet. L’exemple suivant fournit une implémentation possible. Il définit un `StringBuilderFinder` classe dont le constructeur est passé à une référence à un <xref:System.Text.StringBuilder> objet et la sous-chaîne à rechercher dans la chaîne. Dans ce cas, l’exemple tente de déterminer si les températures enregistrées sont en degrés Fahrenheit ou Celsius et ajoute le texte d’introduction approprié au début de la <xref:System.Text.StringBuilder> objet. Un générateur de nombres aléatoires est utilisé pour sélectionner un tableau qui contient les données en degrés Celsius ou degrés Fahrenheit.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Appelez le <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> méthode pour convertir le <xref:System.Text.StringBuilder> de l’objet à un <xref:System.String> objet. Vous pouvez rechercher la chaîne à l’aide de méthodes telles que <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> ou <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, ou vous pouvez utiliser des expressions régulières et le <xref:System.Text.RegularExpressions.Regex> classe pour rechercher des modèles. Étant donné que les deux <xref:System.Text.StringBuilder> et <xref:System.String> objets utilisent l’encodage pour stocker les caractères, les positions d’index de caractères, des sous-chaînes, UTF-16 et les correspondances d’expression régulière sont les mêmes dans les deux objets. Cela vous permet d’utiliser <xref:System.Text.StringBuilder> méthodes pour apporter des modifications à la même position à laquelle ce texte se trouve dans le <xref:System.String> objet.  
  
    > [!NOTE]
    >  Si vous adoptez cette approche, vous devez travailler à partir de la fin de la <xref:System.Text.StringBuilder> objet à ses débuts afin que vous n’êtes pas obligé de convertir de manière répétée le <xref:System.Text.StringBuilder> objet en une chaîne.  
  
     L'exemple suivant illustre cette approche. Il stocke quatre occurrences de chaque lettre de l’alphabet anglais dans un <xref:System.Text.StringBuilder> objet. Il convertit ensuite le texte à un <xref:System.String> de l’objet et utilise une expression régulière pour identifier la position de départ de chaque séquence de quatre caractères. Enfin, il ajoute un trait de soulignement avant chaque séquence de quatre caractères, à l’exception de la première séquence et convertit le premier caractère de la séquence en majuscules.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Utilisez le <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriété à rechercher de manière séquentielle une plage de caractères dans un <xref:System.Text.StringBuilder> objet. Cette approche ne peut pas être pratique si le nombre de caractères à rechercher est volumineux ou la logique de recherche est particulièrement complexe. Pour l’impact sur les performances d’accès de partir d’un index de caractère par caractère pour très volumineux, mémorisé en bloc <xref:System.Text.StringBuilder> objets, consultez la documentation pour le <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriété. 
  
     L’exemple suivant est identique dans sa fonctionnalité à l’exemple précédent, mais diffère dans l’implémentation. Il utilise le <xref:System.Text.StringBuilder.Chars%2A> propriété pour détecter la modification d’une valeur de caractère, insère un trait de soulignement à cette position et convertit le premier caractère dans la nouvelle séquence de caractères majuscules.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store tout le texte non modifié dans le <xref:System.Text.StringBuilder> de l’objet, appelez le <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> méthode pour convertir le <xref:System.Text.StringBuilder> de l’objet à un <xref:System.String> de l’objet et d’effectuer les modifications sur le <xref:System.String> objet. Vous pouvez utiliser cette approche si vous avez uniquement quelques modifications ; Sinon, le coût de l’utilisation de chaînes immuables peut anéantir les avantages de performances offerts par un <xref:System.Text.StringBuilder> objet.  
  
     L’exemple suivant est identique dans les fonctionnalités pour les deux exemples précédents, mais diffère dans l’implémentation. Il crée un <xref:System.Text.StringBuilder> d’objet, le convertit en un <xref:System.String> de l’objet et utilise ensuite une expression régulière pour effectuer toutes les modifications restantes sur la chaîne. Le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> méthode utilise une expression lambda pour effectuer le remplacement de chaque correspondance.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Conversion de l’objet StringBuilder en une chaîne  
 Vous devez convertir l’objet <xref:System.Text.StringBuilder> en objet <xref:System.String> pour pouvoir passer la chaîne représentée par l’objet <xref:System.Text.StringBuilder> à une méthode qui a un paramètre <xref:System.String> ou pour l’afficher dans l’interface utilisateur. Vous effectuez cette conversion en appelant le <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> (méthode). Pour obtenir une illustration, consultez l’exemple précédent, qui appelle le <xref:System.Text.StringBuilder.ToString%2A> méthode pour convertir un <xref:System.Text.StringBuilder> de l’objet en une chaîne afin qu’elle peut être passée à une méthode d’expression régulière.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler la plupart des méthodes définies par le <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de chaîne de cette instance est définie <xref:System.String.Empty?displayProperty=nameWithType>, et la capacité est définie sur la capacité par défaut spécifiques à l’implémentation.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Text.StringBuilder.%23ctor%2A> constructeur sans paramètres.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Taille de départ suggérée de cette instance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.StringBuilder" /> en utilisant la capacité spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `capacity` paramètre définit le nombre maximal de caractères qui peuvent être stockées dans la mémoire allouée par l’instance actuelle. Sa valeur est assignée à la <xref:System.Text.StringBuilder.Capacity%2A> propriété. Si le nombre de caractères à stocker dans l’instance actuelle dépasse cette `capacity` valeur, le <xref:System.Text.StringBuilder> objet alloue la mémoire supplémentaire pour les stocker.  
  
 La valeur de chaîne de cette instance est définie <xref:System.String.Empty?displayProperty=nameWithType>. Si `capacity` est égal à zéro, la capacité par défaut spécifiques à l’implémentation est utilisée.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Text.StringBuilder.%23ctor%2A> constructeur avec une capacité spécifiée.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne utilisée pour initialiser la valeur de l'instance. Si <paramref name="value" /> est <see langword="null" />, le nouveau <see cref="T:System.Text.StringBuilder" /> contient la chaîne vide (il contient <see cref="F:System.String.Empty" />).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.StringBuilder" /> à l'aide de la chaîne spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `value` est `null`, le nouveau <xref:System.Text.StringBuilder> contient la chaîne vide (il contient <xref:System.String.Empty>).  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Text.StringBuilder.%23ctor%2A> constructeur avec la chaîne spécifiée.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Taille de départ suggérée de <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Nombre maximal de caractères que la chaîne actuelle peut contenir.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.StringBuilder" /> qui commence avec une capacité spécifiée et peut croître jusqu'à un maximum spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `capacity` paramètre définit le nombre maximal de caractères qui peuvent être stockées dans la mémoire allouée par l’instance actuelle. Sa valeur est assignée à la <xref:System.Text.StringBuilder.Capacity%2A> propriété. Si le nombre de caractères à stocker dans l’instance actuelle dépasse cette `capacity` valeur, le <xref:System.Text.StringBuilder> objet alloue la mémoire supplémentaire pour les stocker.  
  
 Si `capacity` est égal à zéro, la capacité par défaut spécifiques à l’implémentation est utilisée.  
  
 Le `maxCapacity` propriété définit le nombre maximal de caractères que l’instance actuelle peut contenir. Sa valeur est assignée à la <xref:System.Text.StringBuilder.MaxCapacity%2A> propriété. Si le nombre de caractères à stocker dans l’instance actuelle dépasse cette `maxCapacity` valeur, le <xref:System.Text.StringBuilder> objet n’alloue pas de mémoire supplémentaire, mais au lieu de cela lève une exception.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Text.StringBuilder.%23ctor%2A> constructeur avec une capacité spécifiée et la capacité maximale.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> est inférieur à 1, <paramref name="capacity" /> est inférieur à zéro, ou <paramref name="capacity" /> est supérieur à <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne utilisée pour initialiser la valeur de l'instance. Si <paramref name="value" /> est <see langword="null" />, le nouveau <see cref="T:System.Text.StringBuilder" /> contient la chaîne vide (il contient <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Taille de départ suggérée de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.StringBuilder" /> en utilisant la chaîne et la capacité spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `capacity` paramètre définit le nombre maximal de caractères qui peuvent être stockées dans la mémoire allouée par l’instance actuelle. Sa valeur est assignée à la <xref:System.Text.StringBuilder.Capacity%2A> propriété. Si le nombre de caractères à stocker dans l’instance actuelle dépasse cette `capacity` valeur, le <xref:System.Text.StringBuilder> objet alloue la mémoire supplémentaire pour les stocker.  
  
 Si `capacity` est égal à zéro, la capacité par défaut spécifiques à l’implémentation est utilisée.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Text.StringBuilder.%23ctor%2A> constructeur avec une chaîne initiale et une capacité spécifiée.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne contenant la sous-chaîne utilisée pour initialiser la valeur de l'instance. Si <paramref name="value" /> est <see langword="null" />, le nouveau <see cref="T:System.Text.StringBuilder" /> contient la chaîne vide (il contient <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Position au sein de <paramref name="value" /> où commence la sous-chaîne.</param>
        <param name="length">Nombre de caractères dans la sous-chaîne.</param>
        <param name="capacity">Taille de départ suggérée de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.StringBuilder" /> à partir de la sous-chaîne et de la capacité spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `capacity` paramètre définit le nombre maximal de caractères qui peuvent être stockées dans la mémoire allouée par l’instance actuelle. Sa valeur est assignée à la <xref:System.Text.StringBuilder.Capacity%2A> propriété. Si le nombre de caractères à stocker dans l’instance actuelle dépasse cette `capacity` valeur, le <xref:System.Text.StringBuilder> objet alloue la mémoire supplémentaire pour les stocker.  
  
 Si `capacity` est égal à zéro, la capacité par défaut spécifiques à l’implémentation est utilisée.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Text.StringBuilder.%23ctor%2A> constructeur avec la chaîne spécifiée.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> plus <paramref name="length" /> n’est pas une position dans <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un objet spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valeur booléenne à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'une valeur booléenne spécifiée.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Boolean%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Boolean%29> les appels de méthode le <xref:System.Boolean.ToString?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value`. La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 8 bits non signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Byte%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Byte%29> les appels de méthode le <xref:System.Byte.ToString%28System.IFormatProvider%29> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Unité de code encodée en UTF-16 à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d’un objet <see cref="T:System.Char" /> spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Char%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tableau de caractères à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne des caractères Unicode d'un tableau spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ajoute tous les caractères dans le tableau spécifié à l’instance actuelle dans le même ordre où ils apparaissent dans `value`. Si `value` est `null`, aucune modification est apportée.  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un nombre décimal spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Decimal%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Decimal%29> les appels de méthode le <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un nombre à virgule flottante double précision spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Double%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Double%29> les appels de méthode le <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 16 bits signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Int16%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Int16%29> les appels de méthode le <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 32 bits signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Int32%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Int32%29> les appels de méthode le <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 64 bits signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Int64%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Int64%29> les appels de méthode le <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un objet spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Object%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant. Il définit un `Dog` de classe, crée un `Dog` objet et passe trois appels à la <xref:System.Text.StringBuilder.Append%2A> méthode pour créer une chaîne qui contient le chien nom et qualité.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Object%29> les appels de méthode le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value`. Si `value` est `null`, aucune modification n’est apportée à la <xref:System.Text.StringBuilder> objet.  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 8 bits signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.SByte%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.SByte%29> les appels de méthode le <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un nombre à virgule flottante simple précision spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Single%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Single%29> les appels de méthode le <xref:System.Single.ToString%2A?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à ajouter.</param>
        <summary>Ajoute à cette instance une copie de la chaîne spécifiée.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.String%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Si `value` est `null`, aucune modification est apportée.  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 16 bits non signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.UInt16%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.UInt16%29> les appels de méthode le <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value`. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 32 bits non signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.UInt32%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.UInt32%29> appelle le <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un entier 64 bits non signé spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.UInt64%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 Le <xref:System.Text.StringBuilder.Append%28System.UInt64%29> les appels de méthode le <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> méthode pour obtenir la représentation sous forme de chaîne de `value` pour la culture actuelle. Pour contrôler la mise en forme de `value`, appelez le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère à ajouter.</param>
        <param name="repeatCount">Nombre d'ajouts de <paramref name="value" />.</param>
        <summary>Ajoute à cette instance un nombre spécifié de copies de la représentation sous forme de chaîne d'un caractère Unicode.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> est inférieur à zéro.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Mémoire insuffisante.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau de caractères.</param>
        <param name="valueCount">Nombre de caractères dans le tableau.</param>
        <summary>Ajoute à cette instance un tableau de caractères Unicode commençant à une adresse spécifiée.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ajoute `valueCount` caractères en commençant à l’adresse `value` à l’instance actuelle.  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour une <xref:System.Text.StringBuilder> objet.  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> est inférieur à zéro.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> est un pointeur Null</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tableau de caractères.</param>
        <param name="startIndex">Position de départ dans <paramref name="value" />.</param>
        <param name="charCount">Nombre de caractères à ajouter.</param>
        <summary>Ajoute à cette instance la représentation sous forme de chaîne d'un sous-tableau spécifié de caractères Unicode.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ajoute la plage spécifiée de caractères dans `value` à l’instance actuelle. Si `value` est `null` et `startIndex` et `count` sont tous deux égal à zéro, aucune des modifications.  
  
 Le <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />, tandis que <paramref name="startIndex" /> et <paramref name="charCount" /> sont différents de zéro.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> + <paramref name="charCount" /> est supérieur à la longueur de <paramref name="value" />.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne qui contient la sous-chaîne à ajouter.</param>
        <param name="startIndex">Position de départ de la sous-chaîne dans <paramref name="value" />.</param>
        <param name="count">Nombre de caractères de <paramref name="value" /> à ajouter.</param>
        <summary>Ajoute à cette instance une copie d'une sous-chaîne spécifiée.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ajoute la plage spécifiée de caractères dans `value` à l’instance actuelle. Si `value` est `null` et `startIndex` et `count` sont tous deux égal à zéro, aucune des modifications.  
  
 Le <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> méthode modifie l’instance existante de cette classe ; elle ne retourne pas une nouvelle instance de classe. Pour cette raison, vous pouvez appeler une méthode ou propriété sur la référence existante et vous n’avez pas à affecter la valeur de retour pour un <xref:System.Text.StringBuilder> de l’objet, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />, tandis que <paramref name="startIndex" /> et <paramref name="count" /> sont différents de zéro.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> + <paramref name="count" /> est supérieur à la longueur de <paramref name="value" />.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de mise en forme est remplacé par la représentation sous forme de chaîne d’un argument d’objet correspondant.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Objet à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de format est remplacé par la représentation sous forme de chaîne d'un argument unique.</summary>
        <returns>Référence à cette instance après l'ajout de <paramref name="format" />. Chaque élément de mise en forme dans <paramref name="format" /> est remplacé par la représentation sous forme de chaîne de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans actuel <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format. L’index des éléments de format doit être 0, pour qu’elles correspondent à `arg0`, l’objet unique dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de `arg0`.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. S’il n’existe pas de paramètre dans le *index* position, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` représente l’objet à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne de `arg0`. Si l’élément de format contient `formatString` et `arg0` implémente le <xref:System.IFormattable> d’interface, puis `arg0.ToString(formatString, null)` définit la mise en forme. Sinon, `arg0.ToString()` définit la mise en forme.  
  
 Si la chaîne assignée à `format` est « Merci de votre don de {0 : ###} conserves alimentaires à notre organisation caritative. » et `arg0` est un entier avec la valeur 10, la valeur de retour sera « Merci d’avoir votre don de 10 conserves alimentaires à notre organisation caritative. »  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="args">Tableau d'objets à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de mise en forme est remplacé par la représentation sous forme de chaîne d'un argument correspondant dans un tableau de paramètres.</summary>
        <returns>Référence à cette instance après l'ajout de <paramref name="format" />. Chaque élément de mise en forme de <paramref name="format" /> est remplacé par la représentation sous forme de chaîne de l'argument objet correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans actuel <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format, qui correspondent à des objets dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de l’objet correspondant.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. S’il n’existe pas de paramètre dans le *index* position, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` représente les objets à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne de l’objet correspondant dans `args`. Si l’élément de format contient `formatString` et l’objet correspondant dans `args` implémente le <xref:System.IFormattable> d’interface, puis `args[index].ToString(formatString, provider)` définit la mise en forme. Sinon, `args[index].ToString()` définit la mise en forme.  
  
 Si la chaîne assignée à `format` est « Merci de votre don de {0 : ###} conserves alimentaires à notre organisation caritative. » et `arg0` est un entier avec la valeur 10, la valeur de retour sera « Merci d’avoir votre don de 10 conserves alimentaires à notre organisation caritative. »  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à la longueur du tableau <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Objet à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de format est remplacé par la représentation sous forme de chaîne d’un argument unique à l’aide d’un fournisseur de format spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout. Après l'opération d'ajout, cette instance contient les données qui existaient avant l'opération, avec comme suffixe une copie de <paramref name="format" /> dans laquelle toute spécification de format est remplacée par la représentation sous forme de chaîne de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur de `arg0` à sa représentation sous forme de texte et incorporer cette représentation dans le courant <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format. L’index de chaque élément de format doit être zéro (0) dans la mesure où cette méthode inclut une liste d’arguments avec un seul argument. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de `arg0`.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. Dans ce cas, depuis le <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> méthode possède un argument unique dans la liste d’arguments, la valeur de *index* doit toujours être 0. Le cas contraire, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Le `provider` paramètre spécifie un <xref:System.IFormatProvider> implémentation qui peut fournir des informations de mise en forme pour les objets dans `args`. `provider` peut être l'une des fonctions suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui fournit des informations de mise en forme propres à la culture.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour `arg0` s’il s’agit d’une valeur numérique.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour `arg0` s’il s’agit d’une valeur de date et d’heure.  
  
-   Personnalisé <xref:System.IFormatProvider> implémentation qui fournit des informations de mise en forme pour `arg0`. En règle générale, une telle implémentation implémente également le <xref:System.ICustomFormatter> interface.  
  
 Si le `provider` paramètre est `null`, mise en forme informations sont obtenues à partir de la culture actuelle.  
  
 `arg0` représente l’objet à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne de `arg0`. Si l’élément de format contient `formatString` et `arg0` implémente le <xref:System.IFormattable> d’interface, puis `arg0.ToString(formatString, provider)` définit la mise en forme. Sinon, `arg0.ToString()` définit la mise en forme.  
  
   
  
## Examples  
 Ce qui suit inclut deux appels à la <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> (méthode). Les deux utilisent les conventions de mise en forme de la culture anglais-Grande-Bretagne (en-GB). La première insère la représentation sous forme de chaîne d’un <xref:System.Decimal> valeur monétaire dans une chaîne de résultat. Les insertions deuxième un <xref:System.DateTime> valeur à deux emplacements dans un résultat de chaîne, la première notamment uniquement court date de chaîne et la seconde la chaîne d’heure courte.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à 1 (un).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Comment : définir et utiliser des fournisseurs de format numérique personnalisés</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">Chaîne de format composite.</param>
        <param name="args">Tableau d'objets à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de mise en forme est remplacé par la représentation sous forme de chaîne d'un argument correspondant dans un tableau de paramètres à l'aide d'un fournisseur de format spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout. Après l'opération d'ajout, cette instance contient les données ayant existé avant l'opération, suffixées par une copie de <paramref name="format" /> où la spécification de format est remplacée par la représentation sous forme de chaîne de l'argument d'objet correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans actuel <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format, qui correspondent à des objets dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de l’objet correspondant.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. S’il n’existe pas de paramètre dans le *index* position, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Le `provider` paramètre spécifie un <xref:System.IFormatProvider> implémentation qui peut fournir des informations de mise en forme pour les objets dans `args`. `provider` peut être l'une des fonctions suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui fournit des informations de mise en forme propres à la culture.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour les valeurs numériques dans `args`.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour les valeurs de date et d’heure dans `args`.  
  
-   Personnalisé <xref:System.IFormatProvider> implémentation qui fournit des informations de mise en forme pour un ou plusieurs des objets dans `args`. En règle générale, une telle implémentation implémente également le <xref:System.ICustomFormatter> interface. Le deuxième exemple dans la section suivante illustre un <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> appel de méthode avec un personnalisé <xref:System.IFormatProvider> implémentation.  
  
 Si le `provider` paramètre est `null`, informations de fournisseur de format sont obtenues à partir de la culture actuelle.  
  
 `args` représente les objets à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne de l’objet correspondant dans `args`. Si l’élément de format contient `formatString` et l’objet correspondant dans `args` implémente le <xref:System.IFormattable> d’interface, puis `args[index].ToString(formatString, provider)` définit la mise en forme. Sinon, `args[index].ToString()` définit la mise en forme.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 L’exemple suivant définit un personnalisé <xref:System.IFormatProvider> implémentation nommée `CustomerFormatter` qui met en forme un nombre avec des traits d’union de client à 10 chiffres après les quatrième et septième chiffres. Il est passé à la <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> méthode pour créer une chaîne qui inclut le numéro de client de mise en forme et le nom de client.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à la longueur du tableau <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Comment : définir et utiliser des fournisseurs de format numérique personnalisés</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de format est remplacé par la représentation sous forme de chaîne de l'un des deux arguments possibles.</summary>
        <returns>Référence à cette instance après l'ajout de <paramref name="format" />. Chaque élément de mise en forme de <paramref name="format" /> est remplacé par la représentation sous forme de chaîne de l'argument objet correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans actuel <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format, qui correspondent aux `arg0` et `arg1`, les deux objets dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de l’objet correspondant.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. S’il n’existe pas de paramètre dans le *index* position, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` et `arg1` représentent les objets à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne du `arg0` ou `arg1`. Si l’élément de format contient `formatString` et l’objet correspondant implémente le <xref:System.IFormattable> d’interface, puis `arg` *x* `.ToString(formatString, provider)` définit la mise en forme, où *x* est l’index de l’argument. Sinon, `arg` *x* `.ToString()` définit la mise en forme.  
  
 Si la chaîne assignée à `format` est « Merci de votre don de {0 : ###} conserves alimentaires à notre organisation caritative. » et `arg0` est un entier avec la valeur 10, la valeur de retour sera « Merci d’avoir votre don de 10 conserves alimentaires à notre organisation caritative. »  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de format est remplacé par la représentation sous forme de chaîne d’un argument parmi deux à l’aide d’un fournisseur de format spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout. Après l'opération d'ajout, cette instance contient les données ayant existé avant l'opération, suffixées par une copie de <paramref name="format" /> où la spécification de format est remplacée par la représentation sous forme de chaîne de l'argument d'objet correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans actuel <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format, qui correspondent à des objets dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de l’objet correspondant.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. S’il n’existe pas de paramètre dans le *index* position, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Le `provider` paramètre spécifie un <xref:System.IFormatProvider> implémentation qui peut fournir des informations de mise en forme pour `arg0` et `arg1`. `provider` peut être l'une des fonctions suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui fournit des informations de mise en forme propres à la culture.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour `arg0` ou `arg1` si elles sont des valeurs numériques.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour `arg0` ou `arg1` si ce sont des valeurs de date et d’heure.  
  
-   Personnalisé <xref:System.IFormatProvider> implémentation qui fournit des informations de mise en forme pour `arg0` et `arg1`. En règle générale, une telle implémentation implémente également le <xref:System.ICustomFormatter> interface.  
  
 Si le `provider` paramètre est `null`, informations de fournisseur de format sont obtenues à partir de la culture actuelle.  
  
 `arg0` et `arg1` représentent les objets à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne de l’objet qui possède l’index correspondant. Si l’élément de format contient `formatString` et l’argument correspondant implémente le <xref:System.IFormattable> interface, puis l’argument `ToString(formatString, provider)` méthode définit la mise en forme. Sinon, l’argument `ToString()` méthode définit la mise en forme.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> méthode pour afficher les données de temps et de température stockées dans un générique <xref:System.Collections.Generic.Dictionary%602> objet. Notez que la chaîne de format a trois éléments de format, bien qu’il existe uniquement aux objets à mettre en forme. Il s’agit, car le premier objet dans la liste (une valeur de date et heure) est utilisé par les deux éléments de format : le premier affichage des éléments de format l’heure et la seconde affiche la date.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à 2 (deux).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Comment : définir et utiliser des fournisseurs de format numérique personnalisés</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <param name="arg2">Troisième objet à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de format est remplacé par la représentation sous forme de chaîne de l'un des trois arguments possibles.</summary>
        <returns>Référence à cette instance après l'ajout de <paramref name="format" />. Chaque élément de mise en forme de <paramref name="format" /> est remplacé par la représentation sous forme de chaîne de l'argument objet correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans actuel <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format, qui correspondent aux `arg0` via `arg2`, les objets dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de l’objet correspondant.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. S’il n’existe pas de paramètre dans le *index* position, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, et `arg2` représentent les objets à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne du `arg0`, `arg1`, ou `arg2`, selon l’index de l’élément de format. Si l’élément de format contient `formatString` et l’objet correspondant dans `args` implémente le <xref:System.IFormattable> d’interface, puis `arg` *x* `.ToString(formatString, null)` définit la mise en forme, où  *x* est l’index de l’argument. Sinon, `arg` *x* `.ToString()` définit la mise en forme.  
  
 Si la chaîne assignée à `format` est « Merci de votre don de {0 : ###} conserves alimentaires à notre organisation caritative. » et `arg0` est un entier avec la valeur 10, la valeur de retour sera « Merci d’avoir votre don de 10 conserves alimentaires à notre organisation caritative. »  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.AppendFormat%2A> (méthode).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <param name="arg2">Troisième objet à mettre en forme.</param>
        <summary>Ajoute à cette instance la chaîne retournée par le traitement d'une chaîne de format composite, qui contient un nombre supérieur ou égal à zéro d'éléments de mise en forme. Chaque élément de format est remplacé par la représentation sous forme de chaîne d'un argument parmi trois à l'aide d'un fournisseur de format spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'ajout. Après l'opération d'ajout, cette instance contient les données ayant existé avant l'opération, suffixées par une copie de <paramref name="format" /> où la spécification de format est remplacée par la représentation sous forme de chaîne de l'argument d'objet correspondant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans actuel <xref:System.Text.StringBuilder> objet.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format, qui correspondent à des objets dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation sous forme de chaîne de l’objet correspondant.  
  
 La syntaxe d’un élément de format est comme suit :  
  
 {*index*[,*longueur*] [ :*formatString*]}  
  
 Les éléments entre crochets sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*index*|Position de base zéro dans la liste des paramètres de l’objet à mettre en forme. Si l’objet spécifié par *index* est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. S’il n’existe pas de paramètre dans le *index* position, un <xref:System.FormatException> est levée.|  
|,*longueur*|Le nombre minimal de caractères dans la représentation sous forme de chaîne du paramètre. Si elle est positive, le paramètre est aligné à droite ; Si négatif, il est aligné à gauche.|  
|:*formatString*|Une chaîne de format standard ou personnalisé qui est pris en charge par le paramètre.|  
  
> [!NOTE]
>  Pour les chaînes de format standard et personnalisés utilisés avec des valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Pour les chaînes de format standard et personnalisées utilisées avec des valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format standard utilisées avec des énumérations, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Le `provider` paramètre spécifie un <xref:System.IFormatProvider> implémentation qui peut fournir des informations de mise en forme pour `arg0` et `arg1`. `provider` peut être l'une des fonctions suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui fournit des informations de mise en forme propres à la culture.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour `arg0` ou `arg1` si elles sont des valeurs numériques.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objet qui fournit des informations de mise en forme propres à la culture pour `arg0`, `arg1`, ou `arg2` si ce sont des valeurs de date et d’heure.  
  
-   Personnalisé <xref:System.IFormatProvider> implémentation qui fournit des informations de mise en forme pour `arg0`, `arg1`, et `arg2`. En règle générale, une telle implémentation implémente également le <xref:System.ICustomFormatter> interface.  
  
 Si le `provider` paramètre est `null`, informations de fournisseur de format sont obtenues à partir de la culture actuelle.  
  
 `arg0`, `arg1`, et `arg2` représentent les objets à mettre en forme. Chaque élément de format dans `format` est remplacé par la représentation sous forme de chaîne de l’objet qui possède l’index correspondant. Si l’élément de format contient `formatString` et l’argument correspondant implémente le <xref:System.IFormattable> interface, puis l’argument `ToString(formatString, provider)` méthode définit la mise en forme. Sinon, l’argument `ToString()` méthode définit la mise en forme.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> méthode pour illustrer le résultat d’une valeur booléenne `And` opération avec des valeurs entières. Notez que la chaîne de format inclut six éléments, mais la méthode a uniquement trois éléments dans sa liste d’arguments, étant donné que chaque élément est mis en forme de deux manières différentes.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à 0 (zéro), ou supérieur ou égal à 3 (trois).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la chaîne développée dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Comment : définir et utiliser des fournisseurs de format numérique personnalisés</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute à la fin de cette instance la marque de fin de ligne par défaut ou la copie d'une chaîne spécifiée et la marque de fin de ligne par défaut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ajoute la marque de fin de ligne par défaut à la fin de l'objet <see cref="T:System.Text.StringBuilder" /> actuel.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le terminateur de ligne par défaut est la valeur actuelle de la <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriété.  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.AppendLine%2A> (méthode).  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à ajouter.</param>
        <summary>Ajoute une copie de la chaîne spécifiée suivie de la marque de fin de ligne par défaut à la fin de l'objet <see cref="T:System.Text.StringBuilder" /> actuel.</summary>
        <returns>Référence à cette instance après l'opération d'ajout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le terminateur de ligne par défaut est la valeur actuelle de la <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriété.  
  
 La capacité de cette instance est ajustée en fonction des besoins.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <see cref="T:System.Text.StringBuilder" /> objet en appelant le <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructeur, la longueur et la capacité de la <see cref="T:System.Text.StringBuilder" /> instance peut augmenter au-delà de la valeur de son <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriété. Cela peut se produire en particulier lorsque vous appelez le <see cref="M:System.Text.StringBuilder.Append(System.String)" /> et <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> méthodes pour ajouter des chaînes de taille réduite.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal de caractères que peut contenir la mémoire allouée par l'instance actuelle.</summary>
        <value>Nombre maximal de caractères que peut contenir la mémoire allouée par l'instance actuelle. Sa valeur peut varier de <see cref="P:System.Text.StringBuilder.Length" /> à <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> n’affecte pas la valeur de chaîne de l’instance actuelle. <xref:System.Text.StringBuilder.Capacity%2A> peut être réduite tant qu’il n’est pas inférieur à <xref:System.Text.StringBuilder.Length%2A>.  
  
 Le <xref:System.Text.StringBuilder> alloue davantage d’espace si nécessaire et augmente dynamiquement <xref:System.Text.StringBuilder.Capacity%2A> en conséquence. Pour des raisons de performances, un <xref:System.Text.StringBuilder> peut allouer davantage de mémoire que nécessaire. La quantité de mémoire allouée est spécifique à l’implémentation.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Capacity%2A> propriété.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour une opération set est inférieure à la longueur actuelle de cette instance.  
  
- ou - 
La valeur spécifiée pour une opération set est supérieure à la capacité maximale.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position du caractère.</param>
        <summary>Obtient ou définit le caractère situé à la position de caractère spécifiée dans cette instance.</summary>
        <value>Caractère Unicode à la position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `index` paramètre correspond à la position d’un caractère dans le <xref:System.Text.StringBuilder>. Le premier caractère dans la chaîne est à l’index 0. La longueur d’une chaîne est le nombre de caractères qu’il contient. Le dernier caractère accessible d’un <xref:System.Text.StringBuilder> instance est à l’index <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> est la propriété par défaut de la <xref:System.Text.StringBuilder> classe. En c#, il est un indexeur. Cela signifie que les caractères individuels peuvent être récupérées à partir de la <xref:System.Text.StringBuilder.Chars%2A> comme indiqué dans l’exemple suivant, qui compte le nombre de caractères alphabétiques, espace blanc et les caractères de ponctuation dans une chaîne.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Performances et l’indexation basée sur des caractères

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est en dehors des limites de cette instance lors de la définition d’un caractère.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> est en dehors des limites de cette instance lors de l’obtention d’un caractère.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les caractères de l'instance <see cref="T:System.Text.StringBuilder" /> actuelle.</summary>
        <returns>Objet dont <see cref="P:System.Text.StringBuilder.Length" /> est égal à 0 (zéro).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> est une méthode pratique qui revient à affecter la <xref:System.Text.StringBuilder.Length%2A> propriété de l’instance actuelle à 0 (zéro).  
  
 Appel de la <xref:System.Text.StringBuilder.Clear%2A> méthode ne modifie pas l’instance actuelle <xref:System.Text.StringBuilder.Capacity%2A> ou <xref:System.Text.StringBuilder.MaxCapacity%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Text.StringBuilder> objet avec une chaîne, appelle le <xref:System.Text.StringBuilder.Clear%2A> (méthode), puis ajoute une nouvelle chaîne.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Position de départ dans cette instance à partir de laquelle les caractères sont copiés. L'index est de base zéro.</param>
        <param name="destination">Tableau vers lequel les caractères sont copiés.</param>
        <param name="destinationIndex">Position de départ dans <paramref name="destination" /> où les caractères sont copiés. L'index est de base zéro.</param>
        <param name="count">Nombre de caractères à copier.</param>
        <summary>Copie les caractères d'un segment spécifié de cette instance vers un segment spécifié d'un tableau <see cref="T:System.Char" /> de destination.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.StringBuilder.CopyTo%2A> méthode est destinée à être utilisée dans les rares cas, lorsque vous devez copier efficacement les sections consécutives d’un <xref:System.Text.StringBuilder> objet en un tableau. Le tableau doit être de taille fixe, préallouée, réutilisable et éventuellement, globalement accessible.  
  
 Par exemple, votre application peut remplir une <xref:System.Text.StringBuilder> avec un grand nombre de caractères de l’objet, puis utilisez le <xref:System.Text.StringBuilder.CopyTo%2A> méthode pour copier des éléments réduits et successifs de la <xref:System.Text.StringBuilder> objet en un tableau où ils sont traités. Lorsque toutes les données dans le <xref:System.Text.StringBuilder> objet est traité, la taille de la <xref:System.Text.StringBuilder> objet est défini sur zéro et le cycle se répète.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.CopyTo%2A> (méthode).  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="sourceIndex" /> est supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> est supérieur à la longueur de cette instance.  
  
- ou - 
 <paramref name="destinationIndex" /> + <paramref name="count" /> est supérieur à la longueur de <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Capacité minimale à garantir.</param>
        <summary>Garantit que la capacité de cette instance de <see cref="T:System.Text.StringBuilder" /> est au moins égale à la valeur spécifiée.</summary>
        <returns>Nouvelle capacité de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la capacité actuelle est inférieure à la `capacity` paramètre, la mémoire pour cette instance est réallouée à contenir au moins `capacity` nombre de caractères ; sinon, aucune mémoire n’est modifiée.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.EnsureCapacity%2A> (méthode).  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Objet à comparer à cette instance ou <see langword="null" />.</param>
        <summary>Retourne une valeur indiquant si cette instance équivaut à un objet spécifié.</summary>
        <returns>
          <see langword="true" /> si cette instance et <paramref name="sb" /> ont des valeurs de chaîne, de <see cref="P:System.Text.StringBuilder.Capacity" /> et de <see cref="P:System.Text.StringBuilder.MaxCapacity" /> égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant utilise la <xref:System.Text.StringBuilder.Equals%2A> méthode pour vérifier si deux <xref:System.Text.StringBuilder> objets sont égaux. La méthode est appelée à plusieurs reprises une fois les petites modifications sont apportées à chaque objet, et les résultats sont affichés dans la console.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un objet spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'une valeur booléenne.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier non signé de 8 bits spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un caractère Unicode spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Tableau de caractères à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un tableau de caractères Unicode spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
 Si `value` est `null`, le <xref:System.Text.StringBuilder> n’est pas modifié.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un nombre décimal.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un nombre à virgule flottante double précision.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier signé 16 bits spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier signé 32 bits spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier signé de 64 bits.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Objet à insérer ou <see langword="null" />.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un objet.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
 Si `value` est `null`, la valeur de cette instance est inchangée.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier signé 8 bits spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un nombre à virgule flottante simple précision.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Chaîne à insérer.</param>
        <summary>Insère une chaîne dans cette instance, à la position de caractère spécifiée.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité est ajustée en fonction des besoins.  
  
 Cette instance de <xref:System.Text.StringBuilder> n’est pas modifié si `value` est `null`, ou `value` n’est pas `null` mais sa longueur est égale à zéro.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur actuelle de cette instance.  
  
- ou - 
La longueur actuelle de cet objet <see cref="T:System.Text.StringBuilder" /> plus la longueur de <paramref name="value" /> dépasse <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier non signé 16 bits.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier non signé 32 bits.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Valeur à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un entier non signé 64 bits.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> est utilisé pour obtenir une représentation de chaîne de `value`. Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] et les versions antérieures, les appels à cette méthode levaient une <see cref="T:System.ArgumentOutOfRangeException" /> si insertion <paramref name="value" /> provoquerait la longueur totale de l’objet à dépasser <see cref="P:System.Text.StringBuilder.MaxCapacity" />. En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la méthode lève un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Chaîne à insérer.</param>
        <param name="count">Nombre d'insertions de <paramref name="value" /> à effectuer.</param>
        <summary>Insère dans cette instance une ou plusieurs copies d'une chaîne spécifiée, à la position de caractère spécifiée.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
 Cela <xref:System.Text.StringBuilder> objet n’est pas modifié si `value` est `null`, `value` n’est pas `null` mais sa longueur est égale à zéro, ou `count` est égal à zéro.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro ou supérieur à la longueur actuelle de cette instance.  
  
- ou - 
 <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.OutOfMemoryException">La longueur actuelle de cet objet <see cref="T:System.Text.StringBuilder" /> plus la longueur de <paramref name="value" /> fois <paramref name="count" /> dépasse <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position dans cette instance où commence l'insertion.</param>
        <param name="value">Tableau de caractères.</param>
        <param name="startIndex">Index de départ dans <paramref name="value" />.</param>
        <param name="charCount">Nombre de caractères à insérer.</param>
        <summary>Insère dans cette instance, à la position de caractère spécifiée, la représentation sous forme de chaîne d'un sous-tableau de caractères Unicode spécifié.</summary>
        <returns>Référence à cette instance après l'opération d'insertion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères existants sont décalés afin de libérer de l’espace pour le nouveau texte. La capacité de cette instance est ajustée en fonction des besoins.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Insert%2A> (méthode).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />, tandis que <paramref name="startIndex" /> et <paramref name="charCount" /> sont différents de zéro.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />, <paramref name="startIndex" /> ou <paramref name="charCount" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> est supérieur à la longueur de cette instance.  
  
- ou - 
 <paramref name="startIndex" /> plus <paramref name="charCount" /> n’est pas une position dans <paramref name="value" />.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la longueur de l'objet <see cref="T:System.Text.StringBuilder" /> actuel.</summary>
        <value>Longueur de cette instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur d’un <xref:System.Text.StringBuilder> objet est défini par son numéro de <xref:System.Char> objets.  
  
 Comme le <xref:System.String.Length%2A?displayProperty=nameWithType> propriété, le <xref:System.Text.StringBuilder.Length%2A> propriété indique la longueur de l’objet string en cours. Contrairement à la <xref:System.String.Length%2A?displayProperty=nameWithType> propriété, qui est en lecture seule, le <xref:System.Text.StringBuilder.Length%2A> propriété vous permet de modifier la longueur de la chaîne enregistrée dans le <xref:System.Text.StringBuilder> objet.  
  
 Si la longueur spécifiée est inférieure à la longueur actuelle, en cours <xref:System.Text.StringBuilder> objet est tronqué à la longueur spécifiée. Si la longueur spécifiée est supérieure à la longueur actuelle, la fin de la valeur de chaîne d’actuel <xref:System.Text.StringBuilder> objet est rempli avec le caractère Unicode NULL (U + 0000).  
  
 Si la longueur spécifiée est supérieure à la capacité actuelle, <xref:System.Text.StringBuilder.Capacity%2A> augmente afin qu’il soit supérieur ou égal à la longueur spécifiée.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Length%2A> propriété.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour une opération ensembliste est inférieure à zéro ou supérieur à <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la capacité maximale de cette instance.</summary>
        <value>Nombre maximal de caractères que cette instance peut contenir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité maximale pour cette implémentation est <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Toutefois, cette valeur est spécifique à l’implémentation et peut être différente dans les implémentations des autres ou version ultérieures. Vous pouvez définir explicitement la capacité maximale d’une <xref:System.Text.StringBuilder> objet en appelant le <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> constructeur.  
  
Dans .NET Core et dans le .NET Framework 4.0 et versions ultérieures, lorsque vous instanciez le <xref:System.Text.StringBuilder> objet en appelant le <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> constructeur, la longueur et la capacité de la <xref:System.Text.StringBuilder> instance peut augmenter au-delà de la valeur de son <xref:System.Text.StringBuilder.MaxCapacity> propriété. Cela peut se produire en particulier lorsque vous appelez le <xref:System.Text.StringBuilder.Append(System.String)> et <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> méthodes pour ajouter des chaînes de taille réduite.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">Nombre de caractères à supprimer.</param>
        <summary>Supprime de cette instance la plage de caractères spécifiée.</summary>
        <returns>Référence à cette instance après l'opération de suppression.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode actuelle supprime la plage de caractères spécifiée à partir de l’instance actuelle. Les caractères à (`startIndex` + `length`) sont déplacés vers `startIndex`, et la valeur de chaîne de l’instance actuelle est raccourcie de `length`. La capacité de l’instance actuelle n’est pas affectée.  
  
> [!NOTE]
>  Le <xref:System.Text.StringBuilder.Remove%2A> méthode modifie la valeur de la <xref:System.Text.StringBuilder> de l’instance et retourne cette instance. Il ne pas créer et retourner une nouvelle <xref:System.Text.StringBuilder> objet.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Remove%2A> (méthode).  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro, ou <paramref name="startIndex" /> + <paramref name="length" /> est supérieur à la longueur de cette instance.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remplace toutes les occurrences d'une chaîne ou d'un caractère spécifié dans cette instance par une autre chaîne ou un autre caractère spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Caractère à remplacer.</param>
        <param name="newChar">Caractère qui remplace <paramref name="oldChar" />.</param>
        <summary>Remplace toutes les occurrences d'un caractère spécifié dans cette instance par un autre caractère spécifié.</summary>
        <returns>Référence à cette instance après le remplacement de <paramref name="oldChar" /> par <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale, respect de la casse pour identifier les occurrences de `oldChar` dans l’instance actuelle. La taille de l’actuel <xref:System.Text.StringBuilder> instance est inchangée après le remplacement.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Replace%2A> (méthode).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Chaîne à remplacer.</param>
        <param name="newValue">Chaîne qui remplace <paramref name="oldValue" /> ou <see langword="null" />.</param>
        <summary>Remplace toutes les occurrences d'une chaîne spécifiée dans cette instance par une autre chaîne spécifiée.</summary>
        <returns>Référence à cette instance après remplacement de toutes les instances de <paramref name="oldValue" /> par <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale, respect de la casse pour identifier les occurrences de `oldValue` dans l’instance actuelle. Si `newValue` est `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, toutes les occurrences de `oldValue` sont supprimés.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Replace%2A> (méthode).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="oldValue" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Caractère à remplacer.</param>
        <param name="newChar">Caractère qui remplace <paramref name="oldChar" />.</param>
        <param name="startIndex">Position dans cette instance où commence la sous-chaîne.</param>
        <param name="count">Longueur de la sous-chaîne.</param>
        <summary>Remplace toutes les occurrences d'un caractère spécifié dans une sous-chaîne de cette instance par un autre caractère spécifié.</summary>
        <returns>Référence à cette instance après remplacement de <paramref name="oldChar" /> par <paramref name="newChar" /> dans la plage comprise entre <paramref name="startIndex" /> et <paramref name="startIndex" /> + <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale, respect de la casse pour identifier les occurrences de `oldChar` dans l’instance actuelle. La taille de l’actuel <xref:System.Text.StringBuilder> objet est inchangé après le remplacement.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Replace%2A> (méthode).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> est supérieur à la longueur de la valeur de cette instance.  
  
- ou - 
 <paramref name="startIndex" /> ou <paramref name="count" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Chaîne à remplacer.</param>
        <param name="newValue">Chaîne qui remplace <paramref name="oldValue" /> ou <see langword="null" />.</param>
        <param name="startIndex">Position dans cette instance où commence la sous-chaîne.</param>
        <param name="count">Longueur de la sous-chaîne.</param>
        <summary>Remplace toutes les occurrences d'une chaîne spécifiée dans une sous-chaîne de cette instance par une autre chaîne spécifiée.</summary>
        <returns>Référence à cette instance après remplacement de toutes les instances de <paramref name="oldValue" /> par <paramref name="newValue" /> dans la plage comprise entre <paramref name="startIndex" /> et <paramref name="startIndex" /> + <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale, respect de la casse pour identifier les occurrences de `oldValue` dans la sous-chaîne spécifiée. Si `newValue` est `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, toutes les occurrences de `oldValue` sont supprimés.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.StringBuilder.Replace%2A> (méthode).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longueur de <paramref name="oldValue" /> est égale à zéro.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> plus <paramref name="count" /> indique une position de caractère qui n’est pas dans cette instance.  
  
- ou - 
Une augmentation de la valeur de cette instance dépasserait <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet à remplir avec des informations de sérialisation.</param>
        <param name="context">Emplacement de stockage et de récupération des données sérialisées. Réservé à un usage ultérieur.</param>
        <summary>Remplit un objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec les données nécessaires pour désérialiser l'objet <see cref="T:System.Text.StringBuilder" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `context` paramètre est réservé pour une utilisation future et ne participe pas à cette opération.  
  
 Pour plus d'informations, voir la méthode <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur d'un <see cref="T:System.Text.StringBuilder" /> en <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convertit la valeur de cette instance en <see cref="T:System.String" />.</summary>
        <returns>Chaîne dont la valeur est identique à celle de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez appeler la <xref:System.Text.StringBuilder.ToString%2A> méthode pour convertir le <xref:System.Text.StringBuilder> de l’objet à un <xref:System.String> avant de pouvoir passer la chaîne représentée par l’objet le <xref:System.Text.StringBuilder> objet à une méthode qui a un <xref:System.String> paramètre ou pour l’afficher dans l’interface utilisateur.  
  
   
  
## Examples  
 L'exemple suivant montre l'appel à la méthode <xref:System.Text.StringBuilder.ToString%2A>. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de départ de la sous-chaîne dans cette instance.</param>
        <param name="length">Longueur de la sous-chaîne.</param>
        <summary>Convertit la valeur d'une sous-chaîne de cette instance en <see cref="T:System.String" />.</summary>
        <returns>Chaîne dont la valeur est identique à la sous-chaîne spécifiée de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez appeler la <xref:System.Text.StringBuilder.ToString%2A> méthode pour convertir le <xref:System.Text.StringBuilder> de l’objet à un <xref:System.String> avant de pouvoir passer la chaîne représentée par l’objet le <xref:System.Text.StringBuilder> objet à une méthode qui a un <xref:System.String> paramètre ou pour l’afficher dans l’interface utilisateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  
  
- ou - 
La somme de <paramref name="startIndex" /> et <paramref name="length" /> est supérieure à la longueur de l’instance actuelle.</exception>
      </Docs>
    </Member>
  </Members>
</Type>