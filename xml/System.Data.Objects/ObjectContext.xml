<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0997f3d7974ba6b3999801d158dad1b588eba4c5" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52598575" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Procure des fonctionnalités permettant d'interroger et d'utiliser des données d'entités en tant qu'objets.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  La classe <xref:System.Data.Objects.ObjectContext> n'est pas thread-safe. L’intégrité des objets de données dans un <xref:System.Data.Objects.ObjectContext> ne peut pas être assurée dans les scénarios multithreads.  
  
 Le <xref:System.Data.Objects.ObjectContext> classe est la classe principale d’interaction avec les données sous forme d’objets qui sont des instances de types d’entités qui sont définies dans un modèle conceptuel. Une instance de la classe <xref:System.Data.Objects.ObjectContext> renferme les éléments suivants :  
  
-   Une connexion à la base de données, sous la forme d'un objet <xref:System.Data.EntityClient.EntityConnection>.  
  
-   Les métadonnées qui décrivent le modèle, sous la forme d'un objet <xref:System.Data.Metadata.Edm.MetadataWorkspace>.  
  
-   Un objet <xref:System.Data.Objects.ObjectStateManager> qui gère les objets rendus persistants dans le cache.  
  
 Lorsque la couche objet qui représente un modèle conceptuel est générée par les outils Entity Data Model, la classe qui représente le <xref:System.Data.Metadata.Edm.EntityContainer> pour le modèle est dérivé le <xref:System.Data.Objects.ObjectContext>.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple montre comment construire un objet <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.EntityClient.EntityConnection" /> qui contient des références au modèle et à la connexion à la source de données.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Objects.ObjectContext" /> avec la connexion donnée. Pendant la construction, l'espace de travail des métadonnées est extrait de l'objet <see cref="T:System.Data.EntityClient.EntityConnection" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> n'est pas valide.  
  
- ou - 
L'espace de travail des métadonnées n'est pas valide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Chaîne de connexion, qui procure également l'accès aux informations de métadonnées.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Objects.ObjectContext" /> avec la chaîne de connexion donnée et le nom de conteneur d'entités par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `connectionString` est une chaîne qui contient des informations qui sont nécessaires pour accéder à un modèle conceptuel et pour se connecter à une source de données. La classe <xref:System.Data.EntityClient.EntityConnectionStringBuilder> peut être utilisée pour mettre correctement en forme la chaîne.  
  
 La générer une chaîne de connexion nommée qui est stockée dans le fichier de configuration de l’application. Cette chaîne de connexion nommée peut être fournie au lieu du `connectionString` paramètre lors de l’instanciation du <xref:System.Data.Objects.ObjectContext> classe.  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple montre comment construire un objet <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connectionString" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connectionString" /> n'est pas valide.  
  
- ou - 
L'espace de travail des métadonnées n'est pas valide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.EntityClient.EntityConnection" /> qui contient des références au modèle et à la connexion à la source de données.</param>
        <param name="defaultContainerName">Nom du conteneur d'entités par défaut. Lorsque le paramètre <paramref name="defaultContainerName" /> est défini à l'aide de cette méthode, la propriété passe en lecture seule.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Objects.ObjectContext" /> avec une connexion et un nom de conteneur d'entités donnés.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" />, <paramref name="defaultContainerName" /> ou l'espace de travail des métadonnées n'est pas valide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Chaîne de connexion, qui procure également l'accès aux informations de métadonnées.</param>
        <param name="defaultContainerName">Nom du conteneur d'entités par défaut. Lorsque le paramètre <paramref name="defaultContainerName" /> est défini à l'aide de cette méthode, la propriété passe en lecture seule.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.Objects.ObjectContext" /> avec une chaîne de connexion et un nom de conteneur d'entités donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `connectionString` est une chaîne qui contient des informations qui sont nécessaires pour accéder à un modèle conceptuel et pour se connecter à une source de données. La classe <xref:System.Data.EntityClient.EntityConnectionStringBuilder> peut être utilisée pour mettre correctement en forme la chaîne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connectionString" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connectionString" />, <paramref name="defaultContainerName" /> ou l'espace de travail des métadonnées n'est pas valide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepte toutes les modifications apportées aux objets dans le contexte de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accepte les modifications sur toutes les entrées associées dans l'objet <xref:System.Data.Objects.ObjectStateManager> de sorte que leur état résultant soit inchangé ou détaché.  
  
 Cette méthode itère au sein de tous les objets <xref:System.Data.Objects.ObjectStateEntry> dans l'objet <xref:System.Data.Objects.ObjectStateManager> dont l'état est Ajouté ou Modifié, puis définit l'état de l'entrée à Inchangé. Les éléments Supprimés sont détachés.  
  
 Si le <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> méthode a été appelée et la <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> n’a pas été spécifié, l’utilisateur doit appeler le <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> (méthode). La méthode <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> est utile dans le cas où une transaction a échoué et un utilisateur souhaite réessayer.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Représente le nom du jeu d'entités, qui peut éventuellement être qualifié par le nom du conteneur d'entités.</param>
        <param name="entity">
          <see cref="T:System.Object" /> à ajouter.</param>
        <summary>Ajoute un objet au contexte de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Data.Objects.ObjectContext.AddObject%2A> sur l'objet <xref:System.Data.Objects.ObjectContext> pour ajouter l'objet au contexte de l'objet. Procédez de cette manière lorsqu'il s'agit d'un nouvel objet qui n'existe pas encore dans la source de données. Pour plus d’informations, consultez [attachement et détachement des objets](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Les objets sont ajoutés à l'objet <xref:System.Data.Objects.ObjectStateManager> à l'état <xref:System.Data.EntityState.Detached>, <xref:System.Data.EntityState.Deleted> ou <xref:System.Data.EntityState.Added>.  
  
 Lorsque vous créez un nouvel objet lié à un autre objet dans le contexte de l'objet, ajoutez l'objet à l'aide d'une des méthodes suivantes :  
  
-   Appelez la méthode <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> sur l'objet <xref:System.Data.Objects.DataClasses.EntityCollection%601> et spécifiez l'objet connexe. Effectuez cette action pour une relation un-à-plusieurs ou plusieurs-à-plusieurs.  
  
-   Définissez la propriété <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> de l'objet <xref:System.Data.Objects.DataClasses.EntityReference%601> à l'objet connexe. Effectuez cette action pour une relation un-à-un ou plusieurs-à-un.  
  
 Pour plus d’informations, consultez [création, ajout, modification et suppression des objets](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Si l’objet est dans un état détaché il ne doit pas avoir un <xref:System.Data.EntityKey>.  
  
 Les règles pour le `entitySetName` format sont les suivantes :  
  
-   Si le <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> propriété est `null`, puis le `entitySetName` doit être qualifié complet comme dans  *\<Nom_conteneur_entités >*. *\<Nom du jeu d’entités >*.  
  
-   Si <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> n’est pas `null`, puis le `entitySetName` peut être  *\<Nom_conteneur_entités >*. *\<Nom du jeu d’entités >* ou  *\<nom du jeu d’entités >*.  
  
 Si le `object` a un <xref:System.Data.EntityKey> et `entitySetName` a une valeur, puis le <xref:System.Data.Metadata.Edm.EntitySet> de l’entité de clé doit correspondre à la <xref:System.Data.Metadata.Edm.EntitySet> qui a été trouvée, selon la `entitySetName` et du nom de conteneur d’entités.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple ajoute un nouveau produit et enregistre les modifications apportées à la base de données.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="entity" /> a la valeur <see langword="null" />.  
  
- ou - 
<paramref name="entitySetName" /> n'est pas qualifié.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="currentEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Type d'entité de l'objet.</typeparam>
        <param name="entitySetName">Nom du jeu d'entités auquel appartient l'objet.</param>
        <param name="currentEntity">Objet détaché ayant les mises à jour de propriétés à appliquer à l'objet d'origine. La clé d'entité de <paramref name="currentEntity" /> doit correspondre à la propriété <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> d'une entrée dans le <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Copie les valeurs scalaires de l'objet fourni dans l'objet du <see cref="T:System.Data.Objects.ObjectContext" /> qui a la même clé.</summary>
        <returns>L'objet mis à jour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> méthode est utilisée pour appliquer les modifications qui ont été apportées aux objets en dehors de la <xref:System.Data.Objects.ObjectContext>, tels que les objets détachés reçus par un service Web. La méthode copie les valeurs scalaires de l’objet fourni dans l’objet dans le <xref:System.Data.Objects.ObjectContext> qui a la même clé. Vous pouvez utiliser le <xref:System.Data.EntityKey> de l’objet détaché pour récupérer une instance de cet objet à partir de la source de données. Pour plus d’informations, consultez [Comment : retourner un objet spécifique à l’aide de sa clé](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Les valeurs qui diffèrent des valeurs d’origine de l’objet sont marquées comme modifiées. Notez que la méthode ne s’applique pas les valeurs actuelles pour les objets connexes de `currentEntity`.  
  
 Si vous avez un graphique avec les valeurs actuelles et que vous souhaitez appliquer les valeurs d’origine, appelez <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> (méthode).  
  
 Vous pouvez également utiliser le <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> de la <xref:System.Data.Objects.ObjectSet%601> ou <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A> méthode de la <xref:System.Data.Objects.ObjectStateEntry>. Pour plus d’informations, consultez [création d’Applications multiniveau](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySetName" /> ou <paramref name="current" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> ne correspond pas au <see cref="T:System.Data.Metadata.Edm.EntitySet" /> du <see cref="T:System.Data.EntityKey" /> de l’objet.  
  
- ou - 
L'objet n'est pas dans le <see cref="T:System.Data.Objects.ObjectStateManager" /> ou est à l'état <see cref="F:System.Data.EntityState.Detached" />.  
  
- ou - 
La clé d'entité de l'objet fourni n'est pas valide.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entitySetName" /> est une chaîne vide.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="originalEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Type de l'objet d'entité.</typeparam>
        <param name="entitySetName">Nom du jeu d'entités auquel appartient l'objet.</param>
        <param name="originalEntity">Objet détaché comportant les valeurs d'origine à appliquer à l'objet. La clé d'entité de <paramref name="originalEntity" /> doit correspondre à la propriété <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> d'une entrée dans le <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Copie les valeurs scalaires de l'objet fourni dans le jeu de valeurs d'origine de l'objet dans le <see cref="T:System.Data.Objects.ObjectContext" /> qui a la même clé.</summary>
        <returns>L'objet mis à jour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> méthode est utilisée pour appliquer les modifications qui ont été apportées aux objets en dehors de la <xref:System.Data.Objects.ObjectContext>, tels que les objets détachés reçus par un service Web. La méthode copie les valeurs scalaires de l’objet fourni dans l’objet dans le <xref:System.Data.Objects.ObjectContext> qui a la même clé. Vous pouvez utiliser le <xref:System.Data.EntityKey> de l’objet détaché pour récupérer une instance de cet objet à partir de la source de données. Pour plus d’informations, consultez [Comment : retourner un objet spécifique à l’aide de sa clé](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Les valeurs qui diffèrent des valeurs actuelles de l’objet sont marquées comme modifiées. Notez que la méthode ne s’applique pas les valeurs actuelles pour les objets connexes de `originalEntity`.  
  
 Si vous avez un graphique avec les valeurs d’origine et que vous souhaitez appliquer les valeurs actuelles, appelez <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> (méthode).  
  
 Vous pouvez également utiliser le <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> de la <xref:System.Data.Objects.ObjectSet%601> ou <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A> méthode de la <xref:System.Data.Objects.ObjectStateEntry>. Pour plus d’informations, consultez [création d’Applications multiniveau](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySetName" /> ou <paramref name="original" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> ne correspond pas au <see cref="T:System.Data.Metadata.Edm.EntitySet" /> du <see cref="T:System.Data.EntityKey" /> de l’objet.  
  
- ou - 
Un <see cref="T:System.Data.Objects.ObjectStateEntry" /> pour l'objet est introuvable dans le <see cref="T:System.Data.Objects.ObjectStateManager" />. - ou - 
L'objet retourné est à l'état <see cref="F:System.Data.EntityState.Added" /> ou <see cref="F:System.Data.EntityState.Detached" />.  
  
- ou - 
La clé d'entité de l'objet fourni n'est pas valide ou a subi des modifications de propriétés.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entitySetName" /> est une chaîne vide.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Nom du jeu d'entités auquel appartient l'objet.</param>
        <param name="changed">Objet détaché ayant les mises à jour de propriétés à appliquer à l'objet d'origine.</param>
        <summary>Applique les modifications de propriété d'un objet détaché à un objet déjà attaché au contexte de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> est utilisée pour appliquer des modifications de propriétés d'une version modifiée, détachée d'un objet à la version d'origine attachée à l'objet <xref:System.Data.Objects.ObjectContext>. Cela prend en charge les scénarios, tels que les services Web, dans lesquels un objet entité est détaché et envoyé à une application distante où des mises à jour de propriétés sont effectuées. Cette méthode vous permet d'appliquer plus facilement ces modifications à l'objet d'origine.  
  
 Après <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>, l'objet est à l'état <xref:System.Data.EntityState.Modified>. Vous devez appeler la méthode <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> pour mettre à jour la source de données.  
  
 L'objet d'origine doit exister dans l'objet <xref:System.Data.Objects.ObjectStateManager> et doit être à l'état <xref:System.Data.EntityState.Modified> ou <xref:System.Data.EntityState.Unchanged>. L’objet d’origine est modifié uniquement s’il existe des propriétés modifiées dans le `changed` objet.  
  
 La propriété <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> de l'objet fourni doit être déifnie sur un <xref:System.Data.EntityKey> valide.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> n'affecte pas les propriétés de navigation ou les objets connexes.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> définit seulement les propriétés qui existent dans les métadonnées d'entité pour le type. Par exemple, les propriétés ajoutées dans une classe partielle ne sont pas incluses dans l'opération <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Lorsque <paramref name="entitySetName" /> est <see langword="null" /> ou une chaîne vide.  
  
- ou - 
Lorsque <paramref name="changed" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Quand le <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> ne correspond pas au <see cref="T:System.Data.Metadata.Edm.EntitySet" /> du <see cref="T:System.Data.EntityKey" /> de l’objet.  
  
- ou - 
Lorsque l'entité est dans un état autre que <see cref="F:System.Data.EntityState.Modified" /> ou <see cref="F:System.Data.EntityState.Unchanged" />.  
  
- ou - 
L'objet d'origine n'est pas attaché au contexte.</exception>
        <exception cref="T:System.ArgumentException">Lorsque le type de l'objet <paramref name="changed" /> est différent de celui de l'objet d'origine.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Objet à attacher.</param>
        <summary>Attache un objet ou graphique d'objet au contexte de l'objet lorsque l'objet a une clé d'entité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Data.Objects.ObjectContext.Attach%2A> sur l'objet <xref:System.Data.Objects.ObjectContext> pour attacher l'objet au contexte de l'objet. Procédez de cette manière lorsque l'objet existe déjà dans la source de données, mais qu'il n'est pas encore attaché au contexte. Pour plus d’informations, consultez [personnalisation des objets](https://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).  
  
 La méthode <xref:System.Data.Objects.ObjectContext.Attach%2A> est utilisée pour attacher un objet ou l'objet de niveau supérieur dans un graphique d'objet.  
  
 L'objet qui est attaché doit implémenter <xref:System.Data.Objects.DataClasses.IEntityWithKey> pour exposer un objet <xref:System.Data.EntityKey>. Toutes les classes d'entités générées implémentent <xref:System.Data.Objects.DataClasses.IEntityWithKey>.  
  
 Lorsque vous attachez des objets connexes, vous devez également appeler `Attach` sur le <xref:System.Data.Objects.DataClasses.EntityReference%601> ou <xref:System.Data.Objects.DataClasses.EntityCollection%601> pour définir la relation.  
  
 Cette méthode appelle la méthode <xref:System.Data.Objects.ObjectContext.AttachTo%2A>.  
  
 Vous devez tenir compte des points suivants lors de l'attachement d'objets :  
  
-   Si l'objet qui est attaché a des objets connexes, ces objets seront également attachés au contexte de l'objet.  
  
-   Les objets sont ajoutés au contexte de l'objet dans un état inchangé.  
  
-   L'objet transmis à la méthode <xref:System.Data.Objects.ObjectContext.Attach%2A> doit avoir une valeur <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> valide. Si l'objet n'a pas de valeur <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> valide, utilisez la méthode <xref:System.Data.Objects.ObjectContext.AttachTo%2A> pour indiquer le nom du jeu d'entités.  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Dans cet exemple, deux objets sont attachés, puis la relation est définie.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Clé d'entité non valide.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Représente le nom du jeu d'entités, qui peut éventuellement être qualifié par le nom du conteneur d'entités.</param>
        <param name="entity">
          <see cref="T:System.Object" /> à attacher.</param>
        <summary>Attache un objet ou graphique d'objet au contexte de l'objet dans un jeu d'entités spécifique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez <xref:System.Data.Objects.ObjectContext.AttachTo%2A> sur le <xref:System.Data.Objects.ObjectContext> pour attacher l’objet à une entité spécifique définie dans le contexte d’objet ou si l’objet a un `null` (`Nothing` en Visual Basic) <xref:System.Data.EntityKey> valeur. Pour plus d’informations, consultez [attachement et détachement des objets](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 L'objet qui est attaché peut être un objet unique ou une partie du graphique.  
  
 Les règles pour le `entitySetName` format sont les suivantes :  
  
-   Si le <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> propriété est `null`, puis le `entitySetName` doit être qualifié complet comme dans  *\<Nom_conteneur_entités >*. *\<Nom du jeu d’entités >*.  
  
-   Si le <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> n’est pas `null`, puis le `entitySetName` peut être  *\<Nom_conteneur_entités >*. *\<Nom du jeu d’entités >* ou  *\<nom du jeu d’entités >*.  
  
 Il n'est pas obligatoire qu'un objet <xref:System.Data.EntityKey> soit associé à l'objet qui est attaché. Si l’objet n’a pas de clé d’entité, puis `entitySetName` ne peut pas être une chaîne vide.  
  
 Si l’objet qui est attaché a un <xref:System.Data.EntityKey> et `entitySetName` a une valeur, puis le <xref:System.Data.Metadata.Edm.EntitySet> de l’entité de clé doit correspondre à la <xref:System.Data.Metadata.Edm.EntitySet> qui a été trouvée, selon la `entitySetName` et du nom de conteneur d’entités.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeu d'entités non valide.  
  
- ou - 
L'objet a une clé temporaire.  
  
- ou - 
L'objet a un objet <see cref="T:System.Data.EntityKey" /> et l'objet <see cref="T:System.Data.Metadata.Edm.EntitySet" /> ne correspond pas au jeu d'entités passé comme argument de la méthode.  
  
- ou - 
L'objet n'a pas d'objet <see cref="T:System.Data.EntityKey" /> et aucun jeu d'entités n'est fourni.  
  
- ou - 
Un objet du graphique d'objet a un objet <see cref="T:System.Data.EntityKey" /> temporaire.  
  
- ou - 
Un objet du graphique d'objet a un objet <see cref="T:System.Data.EntityKey" /> non valide (par exemple, les valeurs dans la clé ne correspondent pas à celles dans l'objet).  
  
- ou - 
Le jeu d'entités est introuvable à partir d'un nom <paramref name="entitySetName" /> et d'un nom de conteneur d'entités donnés.  
  
- ou - 
Un objet du graphique d'objet existe déjà dans un autre gestionnaire d'état.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur du délai d'attente, en secondes, pour toutes les opérations dans le contexte de l'objet. Une valeur <see langword="null" /> indique que la valeur par défaut du fournisseur sous-jacent sera utilisée.</summary>
        <value>Valeur <see cref="T:System.Int32" /> qui correspond au délai d'attente, en secondes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le délai d'attente par défaut des requêtes d'objet et de l'opération <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> est défini par le fournisseur de connexions sous-jacent. Toutefois, vous pouvez substituer cette valeur de délai d'attente par défaut en utilisant la propriété <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A> sur le l'objet <xref:System.Data.Objects.ObjectContext>, comme indiqué dans l'exemple suivant.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]  
  
 Effectuez cette substitution lorsque la requête est complexe ou lorsque d'autres problèmes de performances font que les requêtes ou les appels à la méthode <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> dépassent fréquemment le délai d'attente.  
  
   
  
## Examples  
 [Requêtes d’objet](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur du délai d'attente est inférieure à 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la connexion utilisée par le contexte de l'objet.</summary>
        <value>Objet <see cref="T:System.Data.Common.DbConnection" /> qui correspond à la connexion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne l'objet de connexion qui a été passé dans le constructeur ou créé pendant la construction. La propriété de la connexion est déterminée par les constructeurs utilisés.  
  
   
  
## Examples  
 Cet exemple crée un objet <xref:System.Data.EntityClient.EntityConnection> qui est passé au constructeur d'un objet <xref:System.Data.Objects.ObjectContext> à durée d'exécution longue. La connexion est établie manuellement. Les objets <xref:System.Data.EntityClient.EntityConnection> et <xref:System.Data.Objects.ObjectContext> sont tous deux supprimés manuellement.  
  
 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Lorsque l'instance <see cref="T:System.Data.Objects.ObjectContext" /> a été supprimée.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'instance de <see cref="T:System.Data.Objects.ObjectContextOptions" /> qui contient les options affectant le comportement de <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
        <value>Instance de <see cref="T:System.Data.Objects.ObjectContextOptions" /> qui contient les options affectant le comportement de <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée la base de données en utilisant la connexion à la source de données actuelle et les métadonnées de <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> pour afficher le script de langage (DDL) de définition de données. Appelez <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> pour exécuter le script.  
  
 L’essentiel du travail est déléguée à la <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> (méthode).  
  
 Pour plus d’informations, consultez [utilisation de Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Génère un script de langage de définition de données (DDL) qui crée des objets de schéma (tables, clés primaires, clés étrangères) pour les métadonnées de <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />. La classe <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> charge les métadonnées à partir de fichiers SSDL (Store Schema Definition Language).</summary>
        <returns>Script DDL qui crée des objets de schéma pour les métadonnées de <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> pour afficher le script DDL. Appelez <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> pour exécuter le script.  
  
 L’essentiel du travail est déléguée à la <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> (méthode).  
  
 Pour plus d’informations, consultez [utilisation de Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Nom complet du jeu d'entités auquel appartient l'objet entité.</param>
        <param name="entity">Objet pour lequel la clé d'entité est récupérée.</param>
        <summary>Crée la clé d'entité pour un objet spécifique ou retourne la clé d'entité si elle existe déjà.</summary>
        <returns>
          <see cref="T:System.Data.EntityKey" /> de l'objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.Data.EntityKey> n’existe pas pour le `entity`, le <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> méthode crée une nouvelle clé pour celui-ci.  
  
 Cette méthode est utilisée pour déterminer si un objet ayant le même <xref:System.Data.EntityKey> est déjà attaché à l'objet <xref:System.Data.Objects.ObjectContext>. Si un objet ayant le même <xref:System.Data.EntityKey> est déjà attaché, une exception est levée. Utilisez la méthode <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> pour tenter de récupérer l'objet <xref:System.Data.EntityKey> de l'objet détaché avant d'appeler la méthode <xref:System.Data.Objects.ObjectContext.Attach%2A>.  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Dans cet exemple, la méthode <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> est utilisée pour récupérer la clé d'entité d'un objet existant.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Lorsque l'un ou l'autre paramètre est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Lorsque <paramref name="entitySetName" /> est vide.  
  
- ou - 
Lorsque le type de l'objet <paramref name="entity" /> n'existe pas dans le jeu d'entités.  
  
- ou - 
Lorsque <paramref name="entitySetName" /> n'est pas totalement qualifié.</exception>
        <exception cref="T:System.InvalidOperationException">Lorsque la clé d'entité ne peut pas être construite correctement avec les paramètres fournis.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Type d'objet à retourner.</typeparam>
        <summary>Crée et retourne une instance du type demandé.</summary>
        <returns>Instance du type <paramref name="T" /> demandé ou d'un type dérivé qui permet d'utiliser <paramref name="T" /> avec l'Entity Framework. L'objet retourné est une instance du type demandé ou une instance d'un type dérivé qui permet au type demandé d'être utilisé avec Entity Framework.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.CreateObject%2A> méthode est utilisée avec les classes de données personnalisées POCO pour vous assurer que l’objet retourné peut être géré correctement par Entity Framework. Pour plus d’informations, consultez [configuration requise pour la création de proxys POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) et [utilisation des entités POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Type d'entité du <see cref="T:System.Data.Objects.ObjectSet`1" /> demandé.</typeparam>
        <summary>Crée une nouvelle instance de <see cref="T:System.Data.Objects.ObjectSet`1" /> qui est utilisée pour interroger, ajouter, modifier et supprimer des objets du type d'entité spécifié.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> n'est pas définie pour <see cref="T:System.Data.Objects.ObjectContext" />.  
  
- ou - 
Le type spécifié appartient à plusieurs jeux d'entités.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Type d'entité du <see cref="T:System.Data.Objects.ObjectSet`1" /> demandé.</typeparam>
        <param name="entitySetName">Nom du jeu d'entités du <see cref="T:System.Data.Objects.ObjectSet`1" /> retourné. La chaîne doit être qualifiée par le nom du conteneur par défaut si la propriété <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> n'est pas définie sur le <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Crée une nouvelle instance de <see cref="T:System.Data.Objects.ObjectSet`1" /> qui est utilisée pour interroger, ajouter, modifier et supprimer des objets du type spécifié, portant le nom de jeu d'entité indiqué.</summary>
        <returns>Nouvelle instance <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> ne correspond pas au <see cref="T:System.Data.Metadata.Edm.EntitySet" /> du <see cref="T:System.Data.EntityKey" /> de l’objet.  
  
- ou - 
La propriété <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> n'est pas définie pour <see cref="T:System.Data.Objects.ObjectContext" /> et le nom n'est pas qualifié dans le cadre du paramètre <paramref name="entitySetName" />.  
  
- ou - 
Le type spécifié appartient à plusieurs jeux d'entités.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="types">Énumération d'objets <see cref="T:System.Type" /> représentant des classes de données personnalisées qui sont mappées au modèle conceptuel.</param>
        <summary>Génère un type équivalent qui peut être utilisé avec l'Entity Framework pour chaque type de l'énumération fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types individuels dans le `types` énumération qui ne correspondent pas à un type d’entité dans le modèle conceptuel sont ignorés.  
  
 Pour plus d’informations, consultez [configuration requise pour la création de proxys POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) et [utilisation des entités POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Type d'entité du <see cref="T:System.Data.Objects.ObjectQuery`1" /> retourné.</typeparam>
        <param name="queryString">Chaîne de requête à exécuter.</param>
        <param name="parameters">Paramètres à passer à la requête.</param>
        <summary>Crée un objet <see cref="T:System.Data.Objects.ObjectQuery`1" /> dans le contexte de l'objet actuel à l'aide de la chaîne de requête spécifiée.</summary>
        <returns>Objet <see cref="T:System.Data.Objects.ObjectQuery`1" /> du type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Data.Objects.ObjectContext.CreateQuery%2A> pour créer un objet <xref:System.Data.Objects.ObjectQuery%601> du type spécifié qui appartient au contexte de l'objet actuel.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 L’exemple crée une requête simple et itère au sein de la collection de résultats.  
  
 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="queryString" /> ou <paramref name="parameters" /> est <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation d'un modèle conceptuel</related>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie si la base de données spécifiée comme base de données dans la connexion à la source de données actuelle existe sur la source de données.</summary>
        <returns>
          <see langword="true" /> si la base de données existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’essentiel du travail est déléguée à la <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A> (méthode).  
  
 Pour plus d’informations, consultez [utilisation de Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de conteneur par défaut.</summary>
        <value>Valeur <see cref="T:System.String" /> qui correspond au nom de conteneur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> ne retourne jamais `null`; elle retourne la valeur a été définie ou une chaîne vide. L’utilisateur peut définir cette propriété `null`, mais en interne, le nom sera pour une chaîne vide définir une chaîne vide, et `null`.  
  
 Le nom de conteneur par défaut est également défini dans le cadre d'un constructeur. Si le nom de conteneur par défaut est défini par le biais du constructeur protégé, la propriété devient en lecture seule.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime la base de données spécifiée comme base de données dans la connexion à la source de données actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’essentiel du travail est déléguée à la <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A> (méthode).  
  
 Pour plus d’informations, consultez [utilisation de Data Definition Language](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Objet qui spécifie l'entité à supprimer. L'objet peut être dans tout état à l'exception de <see cref="F:System.Data.EntityState.Detached" />.</param>
        <summary>Marque un objet pour la suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marque un objet comme devant être supprimé de l'objet <xref:System.Data.Objects.ObjectStateManager>. L'objet est supprimé de la source de données lorsque la méthode <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> est appelée.  
  
 La suppression de l'objet parent supprime également tous les objets enfants dans la relation limitée. Ce résultat équivaut à activer la propriété `CascadeDelete` sur l'association pour la relation.  
  
 Le <xref:System.Data.Objects.ObjectContext.DeleteObject%2A> méthode peut être appelée sur des objets qui ont déjà été supprimés.  
  
   
  
## Examples  
 Ces exemples sont basés sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Cet exemple construit un <xref:System.Data.EntityKey> avec un ID de produit spécifique, utilise la clé pour récupérer un objet de produit à partir de la source de données, supprime le produit et enregistre les modifications apportées à la base de données.  
  
 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]  
  
 Cet exemple supprime un élément de commande existant, ajoute un nouvel élément et enregistre les modifications apportées à la base de données.  
  
 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> n’existe pas.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Objet à détacher. Seul <paramref name="entity" /> est supprimé ; si des objets connexes sont suivis par le même <see cref="T:System.Data.Objects.ObjectStateManager" />, ceux-ci ne seront pas détachés automatiquement.</param>
        <summary>Supprime l'objet du contexte de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Supprime l'objet de l'objet <xref:System.Data.Objects.ObjectStateManager>. Cela désactive le suivi des modifications et la résolution d’identité pour cet objet. Pour plus d’informations, consultez [attachement et détachement des objets](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Après l'appel de la méthode <xref:System.Data.Objects.ObjectContext.Detach%2A>, le système ne conserve plus de références qui pointent vers cet objet et il peut être recueilli par le garbage collector.  
  
> [!NOTE]
>  Le garbage collection peut se produire uniquement si le code utilisateur ne contient aucune référence à l'objet détaché.  
  
 Vous devez tenir compte des points suivants lors du détachement d'objets :  
  
-   <xref:System.Data.Objects.ObjectContext.Detach%2A> affecte uniquement l'objet spécifique passé à la méthode. Si l'objet qui est détaché possède des objets connexes dans le contexte de l'objet, ces objets ne sont pas détachés.  
  
-   Le détachement d'objets n'affecte pas les données contenues dans la source de données.  
  
-   Les directives de suppression en cascade et les contraintes référentielles ne sont pas appliquées pendant une opération de détachement.  
  
 Pour plus d’informations, consultez [attachement et détachement des objets](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'<paramref name="entity" /> n'est pas associée à ce <see cref="T:System.Data.Objects.ObjectContext" /> (par exemple, elle a été créée récemment et n'a encore été associée à un contexte ou elle a été obtenue par le biais d'un autre contexte ou elle a déjà été détachée).</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantit que les modifications de <see cref="T:System.Data.Objects.ObjectStateEntry" /> sont synchronisées avec celles de tous les objets suivis par <see cref="T:System.Data.Objects.ObjectStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par le contexte de l'objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par le contexte de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ferme la connexion si elle a été ouverte par Entity Framework. Après avoir <xref:System.Data.Objects.ObjectContext.Dispose%2A> est appelée, les opérations qui nécessitent une connexion ouverte, telles que l’exécution d’une requête ou en appelant le <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> méthode provoquera une exception. Les opérations qui ne requièrent pas de connexion ouverte, telles que la composition d'une requête ou l'attachement d'objets, ne provoquent pas d'exception. Le <xref:System.Data.Objects.ObjectContext.Dispose%2A> méthode ne ferme pas toutes les connexions ouvertes explicitement.  
  
 Limitez la portée d’un <xref:System.Data.Objects.ObjectContext> au sein d’un `using` bloc (`Using` en Visual Basic) garantit la suppression correcte des ressources. Pour plus d’informations, consultez [gestion des connexions et Transactions](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 Le <xref:System.Data.Objects.ObjectContext.Dispose> les appels de méthode le `virtual` (`Overridable` en Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources utilisées par le contexte de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ferme la connexion. Après avoir <xref:System.Data.Objects.ObjectContext.Dispose%2A> est appelée, les opérations qui nécessitent une connexion ouverte, telles que l’exécution d’une requête ou en appelant le <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> méthode provoquera une exception. Les opérations qui ne requièrent pas de connexion ouverte, telles que la composition d'une requête ou l'attachement d'objets, ne provoquent pas d'exception.  
  
 Limitez la portée d’un <xref:System.Data.Objects.ObjectContext> au sein d’un `using` bloc (`Using` en Visual Basic) garantit la suppression correcte des ressources. Pour plus d’informations, consultez [gestion des connexions et Transactions](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Nom de la fonction ou procédure stockée. Le nom peut inclure le nom du conteneur, tel que <c>&lt;Nom du conteneur&gt;.&lt;Nom de la fonction&gt;</c>. Lorsque le nom du conteneur par défaut est connu, seul le nom de la fonction est requis.</param>
        <param name="parameters">Tableau d'objets <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Exécute une fonction ou procédure stockée qui est définie dans la source de données et exprimée dans le modèle conceptuel, ignore les résultats retournés par la fonction et retourne le nombre de lignes affectées par l'exécution.</summary>
        <returns>Nombre de lignes affectées.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> a la valeur null ou est vide 
- ou - 
 <paramref name="function" /> est introuvable.</exception>
        <exception cref="T:System.InvalidOperationException">Le lecteur d'entités ne prend pas en charge ce <paramref name="function" />.  
  
- ou - 
Il existe une incompatibilité de type entre le lecteur et la <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Type d'entité du <see cref="T:System.Data.Objects.ObjectResult`1" /> retourné lorsque la fonction est exécutée sur la source de données. Ce type doit implémenter <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nom de la fonction ou procédure stockée. Le nom peut inclure le nom du conteneur, tel que <c>&lt;Nom du conteneur&gt;.&lt;Nom de la fonction&gt;</c>. Lorsque le nom du conteneur par défaut est connu, seul le nom de la fonction est requis.</param>
        <param name="parameters">Tableau d'objets <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Exécute une fonction ou procédure stockée qui est définie dans la source de données et mappée dans le modèle conceptuel, avec les paramètres spécifiés. Retourne un <see cref="T:System.Data.Objects.ObjectResult`1" /> typé.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectResult`1" /> pour les données retournées par la procédure stockée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> est une méthode d’assistance qui est utilisée pour exécuter des procédures stockées ou fonctions qui sont définies dans la source de données et exprimées dans le modèle conceptuel. Les outils Entity Data Model génèrent une méthode pour chacune d’elles dans le modèle conceptuel. Ces méthodes appellent une fortement typée `ExecuteFunction` pour retourner un typé <xref:System.Data.Objects.ObjectResult%601>. Pour plus d’informations, consultez [Code d’Application à l’aide de procédures stockées (Framework de l’entité)](https://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Tous les paramètres de la fonction sont requis dans le tableau de paramètres et tous les types sont vérifiés sur les métadonnées pour la fonction d’importation, y compris le type de la fonction elle-même. `null` les valeurs sont autorisées pour les types de valeur CLR. La validation des paramètres est effectuée par le fournisseur.  
  
 Le <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> méthode utilise le <xref:System.Data.Objects.MergeOption> valeur <xref:System.Data.Objects.MergeOption.AppendOnly>. Par conséquent, si un objet existe déjà dans le contexte d’objet, il ne sera pas chargé à partir de la source de données.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> a la valeur null ou est vide 
- ou - 
 <paramref name="function" /> est introuvable.</exception>
        <exception cref="T:System.InvalidOperationException">Le lecteur d'entités ne prend pas en charge ce <paramref name="function" />.  
  
- ou - 
Il existe une incompatibilité de type entre le lecteur et la <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Type d'entité du <see cref="T:System.Data.Objects.ObjectResult`1" /> retourné lorsque la fonction est exécutée sur la source de données. Ce type doit implémenter <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nom de la fonction ou procédure stockée. Le nom peut inclure le nom du conteneur, tel que <c>&lt;Nom du conteneur&gt;.&lt;Nom de la fonction&gt;</c>. Lorsque le nom du conteneur par défaut est connu, seul le nom de la fonction est requis.</param>
        <param name="mergeOption">Objet <see cref="T:System.Data.Objects.MergeOption" /> à utiliser lors de l'exécution de la requête.</param>
        <param name="parameters">Tableau d'objets <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Exécute la fonction ou procédure stockée indiquée qui est définie dans la source de données et exprimée dans le modèle conceptuel, avec les paramètres et l'option de fusion spécifiés. Retourne un <see cref="T:System.Data.Objects.ObjectResult`1" /> typé.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectResult`1" /> pour les données retournées par la procédure stockée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> méthode est une méthode d’assistance qui est utilisée pour exécuter des procédures stockées ou fonctions qui sont définies dans la source de données et exprimées dans le modèle conceptuel. Les outils Entity Data Model génèrent une méthode pour chacune d’elles dans le modèle conceptuel. Ces méthodes appellent une fortement typée `ExecuteFunction` pour retourner un typé <xref:System.Data.Objects.ObjectResult%601>. Pour plus d’informations, consultez [Code d’Application à l’aide de procédures stockées (Framework de l’entité)](https://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Tous les paramètres de la fonction sont requis dans le tableau de paramètres et tous les types sont vérifiés sur les métadonnées pour la fonction d’importation, y compris le type de la fonction elle-même. `null` les valeurs sont autorisées pour les types de valeur CLR. La validation des paramètres est effectuée par le fournisseur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> a la valeur null ou est vide 
- ou - 
 <paramref name="function" /> est introuvable.</exception>
        <exception cref="T:System.InvalidOperationException">Le lecteur d'entités ne prend pas en charge ce <paramref name="function" />.  
  
- ou - 
Il existe une incompatibilité de type entre le lecteur et la <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Commande à exécuter dans le langage natif de la source de données.</param>
        <param name="parameters">Tableau de paramètres à passer à la commande.</param>
        <summary>Exécute directement une commande arbitraire sur la source de données à l'aide de la connexion existante.</summary>
        <returns>Nombre de lignes affectées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utilisation des commandes paramétrées aide à se protéger des attaques par injection de code SQL, dans lesquelles un attaquant « injecte » une commande dans une instruction SQL qui compromet la sécurité sur le serveur. Les commandes paramétrables protègent contre une attaque d’injection SQL en garantissant que les valeurs reçues à partir d’une source externe sont passées en tant que valeurs uniquement et ne fait pas partie de l’instruction SQL. Par conséquent, les commandes SQL insérées dans une valeur ne sont pas exécutées au niveau de la source de données. Au lieu de cela, les valeurs sont évaluées uniquement comme valeurs de paramètre. Outre les avantages de la sécurité, les commandes paramétrées fournissent une méthode pratique d’organisation des valeurs passées avec une instruction SQL ou à une procédure stockée.  
  
 La valeur de `parameters` peut être un tableau d'objets <xref:System.Data.Common.DbParameter> ou un tableau de valeurs de paramètres. Si seules les valeurs sont fournies, un tableau de <xref:System.Data.Common.DbParameter> objets sont créés en fonction de l’ordre des valeurs dans le tableau.  
  
 La commande de stockage est exécutée dans le contexte de la transaction actuelle, si une transaction en cours existe.  
  
 Pour plus d'informations, voir :  
  
 [Exécuter directement des commandes de Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) et  
  
 [Comment : exécuter directement des commandes sur la Source de données](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="commandText">Commande à exécuter dans le langage natif de la source de données.</param>
        <param name="parameters">Tableau de paramètres à passer à la commande.</param>
        <summary>Exécute directement sur la source de données une requête qui retourne une séquence de résultats typés.</summary>
        <returns>Énumération d'objets de type <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> méthode utilise la connexion existante pour exécuter une commande arbitraire directement sur la source de données. La commande de stockage est exécutée dans le contexte de la transaction actuelle, si une telle transaction existe.  
  
 Appeler la méthode <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> revient à appeler la méthode <xref:System.Data.Common.DbCommand.ExecuteReader%2A> de la classe <xref:System.Data.Common.DbCommand>. Seulement, quand la méthode <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> retourne des entités, la méthode <xref:System.Data.Common.DbCommand.ExecuteReader%2A> retourne les valeurs de propriété de l'objet <xref:System.Data.Common.DbDataReader>.  
  
 Appelez le <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> avec l’entité spécifiée nom du jeu, si vous souhaitez que les résultats à suivre.  
  
 Appelez le <xref:System.Data.Objects.ObjectContext.Translate%2A> méthode pour traduire un <xref:System.Data.Common.DbDataReader> en objets entité lorsque le lecteur contient des lignes de données qui correspondent au type d’entité spécifié.  
  
 L'utilisation des commandes paramétrées aide à se protéger des attaques par injection de code SQL, dans lesquelles un attaquant « injecte » une commande dans une instruction SQL qui compromet la sécurité sur le serveur. Les commandes paramétrables protègent contre une attaque d’injection SQL en garantissant que les valeurs reçues à partir d’une source externe sont passées en tant que valeurs uniquement et ne fait pas partie de l’instruction SQL. Par conséquent, les commandes SQL insérées dans une valeur ne sont pas exécutées au niveau de la source de données. Au lieu de cela, les valeurs sont évaluées uniquement comme valeurs de paramètre. Outre les avantages de la sécurité, les commandes paramétrées fournissent une méthode pratique d’organisation des valeurs passées avec une instruction SQL ou à une procédure stockée.  
  
 La valeur de `parameters` peut être un tableau d'objets <xref:System.Data.Common.DbParameter> ou un tableau de valeurs de paramètres. Si seules les valeurs sont fournies, un tableau de <xref:System.Data.Common.DbParameter> objets sont créés en fonction de l’ordre des valeurs dans le tableau.  
  
 Pour plus d'informations, voir :  
  
 [Exécuter directement des commandes de Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) et  
  
 [Comment : exécuter directement des commandes sur la Source de données](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="commandText">Commande à exécuter dans le langage natif de la source de données.</param>
        <param name="entitySetName">Jeu d’entités du type <c>TResult</c>. Si aucun nom de jeu d'entités n'est fourni, les résultats ne seront pas suivis.</param>
        <param name="mergeOption">Objet <see cref="T:System.Data.Objects.MergeOption" /> à utiliser lors de l'exécution de la requête. La valeur par défaut est <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Tableau de paramètres à passer à la commande.</param>
        <summary>Exécute directement une requête sur la source de données et retourne une séquence de résultats typés. Spécifiez le jeu d'entités et l'option de fusion pour que les résultats de la requête puissent être suivis sous forme d'entités.</summary>
        <returns>Énumération d'objets de type <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> méthode utilise la connexion existante pour exécuter une commande arbitraire directement sur la source de données. La commande de stockage est exécutée dans le contexte de la transaction actuelle, si une telle transaction existe.  
  
 Appeler la méthode <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> revient à appeler la méthode <xref:System.Data.Common.DbCommand.ExecuteReader%2A> de la classe <xref:System.Data.Common.DbCommand>. Seulement, quand la méthode <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> retourne des entités, la méthode <xref:System.Data.Common.DbCommand.ExecuteReader%2A> retourne les valeurs de propriété de l'objet <xref:System.Data.Common.DbDataReader>.  
  
 Spécifiez que le jeu d’entités nom, si vous souhaitez que les résultats à suivre en tant qu’entités.  
  
 Appelez <xref:System.Data.Objects.ObjectContext.Translate%2A> méthode pour traduire un <xref:System.Data.Common.DbDataReader> en objets entité lorsque le lecteur contient des lignes de données qui correspondent au type d’entité spécifié.  
  
 L'utilisation des commandes paramétrées aide à se protéger des attaques par injection de code SQL, dans lesquelles un attaquant « injecte » une commande dans une instruction SQL qui compromet la sécurité sur le serveur. Les commandes paramétrables protègent contre une attaque d’injection SQL en garantissant que les valeurs reçues à partir d’une source externe sont passées en tant que valeurs uniquement et ne fait pas partie de l’instruction SQL. Par conséquent, les commandes SQL insérées dans une valeur ne sont pas exécutées au niveau de la source de données. Au lieu de cela, les valeurs sont évaluées uniquement comme valeurs de paramètre. Outre les avantages de la sécurité, les commandes paramétrées fournissent une méthode pratique d’organisation des valeurs passées avec une instruction SQL ou à une procédure stockée.  
  
 La valeur de `parameters` peut être un tableau d'objets <xref:System.Data.Common.DbParameter> ou un tableau de valeurs de paramètres. Si seules les valeurs sont fournies, un tableau de <xref:System.Data.Common.DbParameter> objets sont créés en fonction de l’ordre des valeurs dans le tableau.  
  
 Pour plus d'informations, voir :  
  
 [Exécuter directement des commandes de Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) et  
  
 [Comment : exécuter directement des commandes sur la Source de données](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne tous les types de proxies existants.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient tous les types de proxies existants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A> méthode est utilisée lors de la génération d’objet proxy est activée pour les entités POCO. Pour plus d’informations, consultez [configuration requise pour la création de proxys POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) et [utilisation des entités POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'objet à rechercher.</param>
        <summary>Retourne un objet qui a la clé d'entité spécifiée.</summary>
        <returns>Objet <see cref="T:System.Object" /> qui correspond à une instance d'un type d'entité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> essaie de récupérer un objet qui a l'objet <xref:System.Data.EntityKey> spécifié à partir de l'objet <xref:System.Data.Objects.ObjectStateManager>. Si l'objet n'est pas chargé actuellement dans le contexte de l'objet, une requête est exécutée en vue de retourner l'objet à partir de la source de données. Pour plus d’informations, consultez [requêtes d’objet](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> lève une exception <xref:System.Data.ObjectNotFoundException> lorsque l'objet est introuvable. Pour éviter de gérer cette exception, utilisez plutôt la méthode <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>.  
  
 Cette méthode retourne des objets à l'état <xref:System.Data.EntityState.Deleted>.  
  
 Une clé temporaire ne peut pas être utilisée pour retourner un objet à partir de la source de données.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple crée un objet <xref:System.Data.EntityKey> pour une entité du type donné, puis il récupère une entité par clé.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="key" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Data.ObjectNotFoundException">L'objet est introuvable dans l'objet <see cref="T:System.Data.Objects.ObjectStateManager" /> ou dans la source de données.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Interrogation des données sous forme d'objets (Entity Framework)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> de l'objet proxy.</param>
        <summary>Retourne le type d'entité de l'entité POCO associée à un objet proxy du type spécifié.</summary>
        <returns>
          <see cref="T:System.Type" /> de l'entité POCO associée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.GetObjectType%2A> méthode est utilisée lors de la génération d’objet proxy est activée pour les entités POCO. Pour plus d’informations, consultez [configuration requise pour la création de proxys POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) et [utilisation des entités POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge explicitement un objet connexe lorsque vous utilisez des classes de données personnalisées POCO.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez des classes de données personnalisées POCO, les objets connexes ne peut pas être chargées explicitement comme instances de types d’entités qui sont générés par les outils Entity Data Model. Il s’agit, car les outils génèrent les propriétés de navigation qui retournent un <xref:System.Data.Objects.DataClasses.EntityCollection%601> ou <xref:System.Data.Objects.DataClasses.EntityReference%601> d’objets connexes lorsque <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> est appelée sur un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Les entités POCO peuvent être chargées à l’aide de chargement différé en définissant le <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propriété `true` sur l’instance de <xref:System.Data.Objects.ObjectContextOptions> qui est retourné par la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propriété, ou en utilisant le chargement hâtif avec le <xref:System.Data.Objects.ObjectQuery%601.Include%2A> sur le (méthode)<xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entity">Entité pour laquelle les objets connexes seront chargés.</param>
        <param name="navigationProperty">Nom de la propriété de navigation qui retourne les objets connexes à charger.</param>
        <summary>Charge explicitement, à l'aide de l'option de fusion par défaut, un objet lié à l'objet fourni par la propriété de navigation spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> méthode doit être appelée pour accomplir le chargement explicite lorsque vous utilisez des classes de données personnalisées POCO.  
  
 Après avoir appelé <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l’objet connexe est accessible via les propriétés de navigation de l’entité source.  
  
 Lorsque vous utilisez des classes de données personnalisées POCO, les objets connexes ne peut pas être chargées explicitement comme instances de types d’entités qui sont générés par les outils Entity Data Model. Il s’agit, car les outils génèrent les propriétés de navigation qui retournent un <xref:System.Data.Objects.DataClasses.EntityCollection%601> ou <xref:System.Data.Objects.DataClasses.EntityReference%601> d’objets connexes lorsque <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> est appelée sur un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Les entités POCO peuvent être chargées à l’aide de chargement différé en définissant le <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propriété `true` sur l’instance de <xref:System.Data.Objects.ObjectContextOptions> qui est retourné par la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propriété, ou en utilisant le chargement hâtif avec le <xref:System.Data.Objects.ObjectQuery%601.Include%2A> sur le (méthode)<xref:System.Data.Objects.ObjectQuery%601>.  
  
 Lorsque le <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> est appelée, les objets sont chargés dans le <xref:System.Data.Objects.ObjectContext> à l’aide de la valeur par défaut <xref:System.Data.Objects.MergeOption> valeur <xref:System.Data.Objects.MergeOption.AppendOnly>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> est à l'état <see cref="F:System.Data.EntityState.Detached" />,  <see cref="F:System.Data.EntityState.Added" /> ou <see cref="F:System.Data.EntityState.Deleted" />. 
- ou - 
<paramref name="entity" /> est joint à une autre instance de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="entity">Entité pour laquelle les objets connexes seront chargés.</param>
        <param name="navigationProperty">Nom de la propriété de navigation qui retourne les objets connexes à charger.</param>
        <param name="mergeOption">Valeur <see cref="T:System.Data.Objects.MergeOption" /> à utiliser lors du chargement des objets connexes.</param>
        <summary>Charge explicitement, à l'aide de l'option de fusion spécifiée, un objet lié à l'objet fourni par la propriété de navigation indiquée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> méthode doit être appelée pour accomplir le chargement explicite lorsque vous utilisez des classes de données personnalisées POCO.  
  
 Après avoir appelé <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l’objet connexe est accessible via les propriétés de navigation de l’entité source.  
  
 Lorsque vous utilisez des classes de données personnalisées POCO, les objets connexes ne peut pas être chargées explicitement comme instances de types d’entités qui sont générés par les outils Entity Data Model. Il s’agit, car les outils génèrent les propriétés de navigation qui retournent un <xref:System.Data.Objects.DataClasses.EntityCollection%601> ou <xref:System.Data.Objects.DataClasses.EntityReference%601> d’objets connexes lorsque <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> est appelée sur un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Les entités POCO peuvent être chargées à l’aide de chargement différé en définissant le <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propriété `true` sur l’instance de <xref:System.Data.Objects.ObjectContextOptions> qui est retourné par la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propriété, ou en utilisant le chargement hâtif avec le <xref:System.Data.Objects.ObjectQuery%601.Include%2A> sur le (méthode)<xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> est à l'état <see cref="F:System.Data.EntityState.Detached" />,  <see cref="F:System.Data.EntityState.Added" /> ou <see cref="F:System.Data.EntityState.Deleted" />. 
- ou - 
<paramref name="entity" /> est joint à une autre instance de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Objet source pour lequel les objets connexes seront chargés.</param>
        <param name="selector">Expression LINQ qui définit les objets connexes à charger.</param>
        <summary>Charge explicitement, à l'aide de l'option de fusion par défaut, un objet lié à l'objet fourni par la requête LINQ spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> méthode doit être appelée pour accomplir le chargement explicite lorsque vous utilisez des classes de données personnalisées POCO.  
  
 Après avoir appelé <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l’objet connexe est accessible via les propriétés de navigation de l’entité source.  
  
 La propriété à charger est spécifiée par une expression LINQ, qui doit être sous la forme d’un accès au membre de propriété simple, comme dans `(entity) => entity.PropertyName`, où *PropertyName* est la propriété de navigation qui retourne les objets connexes à charger. Une exception se produira si d’autres formes de l’expression LINQ sont utilisés.  
  
 Lorsque vous utilisez des classes de données personnalisées POCO, les objets connexes ne peut pas être chargées explicitement comme instances de types d’entités qui sont générés par les outils Entity Data Model. Il s’agit, car les outils génèrent les propriétés de navigation qui retournent un <xref:System.Data.Objects.DataClasses.EntityCollection%601> ou <xref:System.Data.Objects.DataClasses.EntityReference%601> d’objets connexes lorsque <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> est appelée sur un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Les entités POCO peuvent être chargées à l’aide de chargement différé en définissant le <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propriété `true` sur l’instance de <xref:System.Data.Objects.ObjectContextOptions> qui est retourné par la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propriété, ou en utilisant le chargement hâtif avec le <xref:System.Data.Objects.ObjectQuery%601.Include%2A> sur le (méthode)<xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> ne fournit pas de paramètre d'entrée valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> a la valeur null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> est à l'état <see cref="F:System.Data.EntityState.Detached" />,  <see cref="F:System.Data.EntityState.Added" /> ou <see cref="F:System.Data.EntityState.Deleted" />. 
- ou - 
<paramref name="entity" /> est joint à une autre instance de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Objet source pour lequel les objets connexes seront chargés.</param>
        <param name="selector">Expression LINQ qui définit les objets connexes à charger.</param>
        <param name="mergeOption">Valeur <see cref="T:System.Data.Objects.MergeOption" /> à utiliser lors du chargement des objets connexes.</param>
        <summary>Charge explicitement, à l'aide de l'option de fusion spécifiée, un objet lié à l'objet fourni par la requête LINQ indiquée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> méthode doit être appelée pour accomplir le chargement explicite lorsque vous utilisez des classes de données personnalisées POCO.  
  
 Après avoir appelé <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, l’objet connexe est accessible via les propriétés de navigation de l’entité source.  
  
 La propriété à charger est spécifiée par une expression LINQ, qui doit être sous la forme d’un accès au membre de propriété simple, comme dans `(entity) => entity.PropertyName` où *PropertyName* est la propriété de navigation qui retourne les objets connexes à charger. Une exception se produira si d’autres formes de l’expression LINQ sont utilisés.  
  
 Lorsque vous utilisez des classes de données personnalisées POCO, les objets connexes ne peut pas être chargées explicitement comme instances de types d’entités qui sont générés par les outils Entity Data Model. Il s’agit, car les outils génèrent les propriétés de navigation qui retournent un <xref:System.Data.Objects.DataClasses.EntityCollection%601> ou <xref:System.Data.Objects.DataClasses.EntityReference%601> d’objets connexes lorsque <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> est appelée sur un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Les entités POCO peuvent être chargées à l’aide de chargement différé en définissant le <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propriété `true` sur l’instance de <xref:System.Data.Objects.ObjectContextOptions> qui est retourné par la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propriété, ou en utilisant le chargement hâtif avec le <xref:System.Data.Objects.ObjectQuery%601.Include%2A> sur le (méthode)<xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> ne fournit pas de paramètre d'entrée valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> a la valeur null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> est à l'état <see cref="F:System.Data.EntityState.Detached" />,  <see cref="F:System.Data.EntityState.Added" /> ou <see cref="F:System.Data.EntityState.Deleted" />. 
- ou - 
<paramref name="entity" /> est joint à une autre instance de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'espace de travail des métadonnées utilisé par le contexte de l'objet.</summary>
        <value>Objet <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> associé à cet objet <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.Data.Metadata.Edm.MetadataWorkspace> est une API d'exécution centrale que vous pouvez utiliser pour interagir avec les métadonnées EDM (Entity Data Model) dans le contexte d'une application. Pour plus d’informations, consultez [espace de travail de métadonnées](https://msdn.microsoft.com/library/601aee56-3eda-4caa-9082-a01df76c5e84).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un nouvel objet d'entité est créé à partir des données de la source de données dans le cadre d'une requête ou d'une opération de chargement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché après tous les scalaires, complexes et des propriétés de référence ont été définies sur un objet, mais avant le chargement des collections. Si un objet avec la même valeur de clé existe dans le contexte d’objet, Entity Framework ne recrée pas l’objet et cet événement ne sera pas déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le gestionnaire d'état d'objet utilisé par le contexte de l'objet pour assurer le suivi des modifications d'objets.</summary>
        <value>Objet <see cref="T:System.Data.Objects.ObjectStateManager" /> utilisé par cet objet <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ces exemples sont basés sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Cet exemple obtient l'objet <xref:System.Data.Objects.ObjectStateManager> à partir de l'objet <xref:System.Data.Objects.ObjectContext> et utilise le gestionnaire d'état pour accéder à un objet dans le contexte.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]  
  
 Cet exemple utilise la méthode <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A> sur l'objet <xref:System.Data.Objects.ObjectStateManager> retourné pour obtenir un objet en fonction de sa clé d'entité.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le fournisseur de requête LINQ associé à ce contexte d'objet.</summary>
        <value>Instance de <see cref="T:System.Linq.IQueryProvider" /> utilisée par ce contexte d'objet.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met à jour des objets spécifiques dans le contexte de l'objet avec des données de la source de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordre dans lequel les objets sont actualisés est non déterministe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Valeur <see cref="T:System.Data.Objects.RefreshMode" /> qui indique si les modifications de propriétés dans le contexte de l'objet sont remplacées par les valeurs de propriété de la source de données.</param>
        <param name="collection">Collection <see cref="T:System.Collections.IEnumerable" /> d’objets à actualiser.</param>
        <summary>Met à jour une collection d’objets dans le contexte de l’objet avec des données de la source de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d'actualiser les objets dans le contexte de l'objet avec les données de la source de données et constitue le mécanisme par lequel les conflits peuvent être résolus. Pour plus d’informations, consultez [enregistrement des modifications et la gestion de l’accès concurrentiel](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 L'ordre dans lequel les objets sont actualisés est non déterministe.  
  
 Après avoir <xref:System.Data.Objects.ObjectContext.Refresh%2A> est appelée, l’objet des valeurs d’origine seront toujours être mis à jour avec la valeur de source de données, mais les valeurs actuelles ne peuvent pas être mis à jour avec la valeur de source de données. Cela dépend de la valeur de <xref:System.Data.Objects.RefreshMode>. Le <xref:System.Data.Objects.RefreshMode.StoreWins> mode signifie que les objets dans la collection doivent être mis à jour pour correspondre aux valeurs de source de données. <xref:System.Data.Objects.RefreshMode.ClientWins> signifie que seules les modifications dans le contexte d’objet sont persistantes, même s’il a eu d’autres modifications dans la source de données.  
  
 Pour vous assurer que les objets ont été mis à jour par la logique de la source de données, vous pouvez appeler <xref:System.Data.Objects.ObjectContext.Refresh%2A> avec <xref:System.Data.Objects.RefreshMode.StoreWins> après avoir appelé la méthode <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> est vide.  
  
- ou - 
Un objet n'est pas attaché au contexte.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">L'une des valeurs <see cref="T:System.Data.Objects.RefreshMode" /> qui spécifie le mode à utiliser pour l'actualisation de l'objet <see cref="T:System.Data.Objects.ObjectStateManager" />.</param>
        <param name="entity">Objet à actualiser.</param>
        <summary>Met à jour un objet dans le contexte de l'objet avec des données de la source de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Refresh%2A> permet d'actualiser un objet avec les données de la source de données et constitue le mécanisme par lequel les conflits peuvent être résolus. Pour plus d’informations, consultez [enregistrement des modifications et la gestion de l’accès concurrentiel](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 L'ordre dans lequel les objets sont actualisés est non déterministe.  
  
 Après le <xref:System.Data.Objects.ObjectContext.Refresh%2A> méthode est appelée, les valeurs d’origine de l’objet seront toujours être mis à jour avec la valeur de source de données, mais les valeurs actuelles ne peuvent pas être mis à jour avec la valeur de source de données. Cela dépend de l'objet <xref:System.Data.Objects.RefreshMode>. Le mode <xref:System.Data.Objects.RefreshMode.StoreWins> signifie que l'objet doit être mis à jour de façon à correspondre aux valeurs de la source de données. La valeur <xref:System.Data.Objects.RefreshMode.ClientWins> signifie que seules les modifications dans le contexte de l'objet sont rendues persistantes, même s'il y a eu d'autres modifications dans la source de données.  
  
 Pour vous assurer qu'un objet a été mis à jour par la logique de la source de données, vous pouvez appeler la méthode <xref:System.Data.Objects.ObjectContext.Refresh%2A> avec la valeur <xref:System.Data.Objects.RefreshMode.StoreWins> après avoir appelé la méthode <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple tente d'enregistrer des modifications, ce qui peut provoquer un conflit d'accès concurrentiel. Ensuite, il montre comment résoudre le conflit d'accès concurrentiel en actualisant le contexte de l'objet avant de réenregistrer les modifications.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> est vide.  
  
- ou - 
Un objet n'est pas attaché au contexte.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend toutes les mises à jour persistantes dans la source de données.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend toutes les mises à jour persistantes dans la source de données et réinitialise le suivi des modifications dans le contexte de l'objet.</summary>
        <returns>Nombre d'objets à l'état <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> ou <see cref="F:System.Data.EntityState.Deleted" /> lorsque la méthode <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> a été appelée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour vous assurer que les objets sur le client ont été mis à jour par la logique de la source de données, vous pouvez appeler la méthode <xref:System.Data.Objects.ObjectContext.Refresh%2A> avec la valeur <xref:System.Data.Objects.RefreshMode.StoreWins> après avoir appelé <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Pour plus d’informations, consultez [enregistrement des modifications et la gestion de l’accès concurrentiel](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> fonctionne dans une transaction. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> annule cette transaction et lève une exception si un de modifiés <xref:System.Data.Objects.ObjectStateEntry> objets ne peut pas être persistante.  
  
 Si une violation d'accès concurrentiel optimiste s'est produite, une exception <xref:System.Data.OptimisticConcurrencyException> est levée. Vous pouvez résoudre une violation d'accès concurrentiel optimiste en l'interceptant, en appelant la méthode <xref:System.Data.Objects.ObjectContext.Refresh%2A> avec la valeur <xref:System.Data.Objects.RefreshMode.StoreWins> ou <xref:System.Data.Objects.RefreshMode.ClientWins> et en appelant de nouveau <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Pour plus d’informations, consultez [Comment : gérer les accès concurrentiel aux données dans le contexte d’objet](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Cet exemple tente d'enregistrer des modifications, ce qui peut provoquer un conflit d'accès concurrentiel. Ensuite, il montre comment résoudre le conflit d'accès concurrentiel en actualisant le contexte de l'objet avant de réenregistrer les modifications.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Une violation d'accès concurrentiel optimiste s'est produite dans la source de données.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Ce paramètre est nécessaire pour la prise en charge des transactions côté client. S'il a la valeur <see langword="true" />, le suivi des modifications de tous les objets est réinitialisé une fois que l'exécution de la méthode <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" /> est terminée. S'il a la valeur <see langword="false" />, vous devez appeler la méthode <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" /> après <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />.</param>
        <summary>Rend toutes les mises à jour persistantes dans la source de données et réinitialise éventuellement le suivi des modifications dans le contexte de l'objet.</summary>
        <returns>Nombre d'objets à l'état <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> ou <see cref="F:System.Data.EntityState.Deleted" /> lorsque la méthode <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> a été appelée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29> méthode à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Une violation d'accès concurrentiel optimiste s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">Valeur <see cref="T:System.Data.Objects.SaveOptions" /> qui détermine le comportement de l'opération.</param>
        <summary>Rend persistantes toutes les mises à jour de la source de données avec le <see cref="T:System.Data.Objects.SaveOptions" /> spécifié.</summary>
        <returns>Nombre d'objets à l'état <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> ou <see cref="F:System.Data.EntityState.Deleted" /> lorsque la méthode <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> a été appelée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge spécifique de <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> soit vous assurer que <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> est appelée avant que vous enregistrez des modifications sur la source de données ou qui <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> est appelée après avoir enregistré les modifications à la source de données.  
  
 Cette énumération a un <xref:System.FlagsAttribute> qui permet une combinaison au niveau du bit de ses valeurs membres.  
  
 Pour vous assurer que les objets sur le client ont été mis à jour par la logique de la source de données, vous pouvez appeler la <xref:System.Data.Objects.ObjectContext.Refresh%2A> méthode avec le <xref:System.Data.Objects.RefreshMode.StoreWins> valeur après avoir appelé <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Le <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> méthode opère dans une transaction. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> annule cette transaction et lève une exception si l’une des modifiés <xref:System.Data.Objects.ObjectStateEntry> objets ne peut pas être persistante.  
  
 Si une violation d'accès concurrentiel optimiste s'est produite, une exception <xref:System.Data.OptimisticConcurrencyException> est levée. Vous pouvez résoudre une violation d'accès concurrentiel optimiste en l'interceptant, en appelant la méthode <xref:System.Data.Objects.ObjectContext.Refresh%2A> avec les valeurs <xref:System.Data.Objects.RefreshMode.StoreWins> ou <xref:System.Data.Objects.RefreshMode.ClientWins>, puis en appelant de nouveau la méthode <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Pour plus d’informations, consultez [Comment : gérer les accès concurrentiel aux données dans le contexte d’objet](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Une violation d'accès concurrentiel optimiste s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque des modifications sont enregistrées dans la source de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'événement <xref:System.Data.Objects.ObjectContext.SavingChanges> est déclenché au démarrage d'une opération <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> sur un objet <xref:System.Data.Objects.ObjectContext>. Cet événement est utilisé en général pour valider les objets modifiés avant que les nouvelles valeurs soient écrites dans la base de données.  
  
   
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Il inscrit un gestionnaire pour l’événement <xref:System.Data.Objects.ObjectContext.SavingChanges> qui exécute la validation de l’état d’entité.  
  
 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" /> qui contient les données d'entité à traduire en objets d'entité.</param>
        <summary>Traduit un <see cref="T:System.Data.Common.DbDataReader" /> qui contient des lignes de données d'entité en objets du type d'entité demandé.</summary>
        <returns>Énumération d'objets de type <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.Translate%2A> méthode est utilisée pour convertir les données d’entité dans un <xref:System.Data.Common.DbDataReader> en objets du type demandé. Ce processus est exécuté automatiquement lorsqu’un <xref:System.Data.Objects.ObjectQuery%601> est exécutée pour retourner des données d’entité. Le <xref:System.Data.Objects.ObjectContext.Translate%2A> méthode vous permet d’exécuter une requête ADO.NET standard par rapport à une source de données et de traduire les lignes de données retournées dans des objets entité.  
  
 Fourni <xref:System.Data.Common.DbDataReader> doit contenir des données qui mappe au type d’entité demandé.  
  
 Pour plus d'informations, voir :  
  
 [Exécuter directement des commandes de Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) et  
  
 [Comment : exécuter directement des commandes sur la Source de données](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Lorsque <paramref name="reader" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" /> qui contient les données d'entité à traduire en objets d'entité.</param>
        <param name="entitySetName">Jeu d’entités du type <c>TResult</c>.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> à utiliser lors de l'ajout des objets traduits au contexte de l'objet. La valeur par défaut est <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Traduit un <see cref="T:System.Data.Common.DbDataReader" /> qui contient des lignes de données d'entité en objets du type d'entité demandé, dans un jeu d'entités spécifique et avec l'option de fusion indiquée.</summary>
        <returns>Énumération d'objets de type <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.Objects.ObjectContext.Translate%2A> méthode est utilisée pour convertir les données d’entité dans un <xref:System.Data.Common.DbDataReader> en objets du type demandé. Ce processus est exécuté automatiquement lorsqu’un <xref:System.Data.Objects.ObjectQuery%601> est exécutée pour retourner des données d’entité. Le <xref:System.Data.Objects.ObjectContext.Translate%2A> méthode vous permet d’exécuter une requête ADO.NET standard par rapport à une source de données et de traduire les lignes de données retournées dans des objets entité.  
  
 Fourni <xref:System.Data.Common.DbDataReader> doit contenir des données qui mappe au type d’entité demandé.  
  
 Pour plus d'informations, voir :  
  
 [Exécuter directement des commandes de Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) et  
  
 [Comment : exécuter directement des commandes sur la Source de données](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Lorsque <paramref name="reader" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Lorsque le <paramref name="mergeOption" /> fourni n'est pas une valeur <see cref="T:System.Data.Objects.MergeOption" /> valide.</exception>
        <exception cref="T:System.InvalidOperationException">Lorsque le <paramref name="entitySetName" /> fourni n'est pas un jeu d'entités valide pour le type <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'objet à rechercher.</param>
        <param name="value">Lorsque cette méthode retourne, contient l'objet.</param>
        <summary>Retourne un objet qui a la clé d'entité spécifiée.</summary>
        <returns>
          <see langword="true" /> si l'objet a été récupéré avec succès. <see langword="false" /> si le paramètre <paramref name="key" /> est temporaire, la connexion est <see langword="null" /> ou le paramètre <paramref name="value" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> essaie de récupérer un objet qui a l'objet <xref:System.Data.EntityKey> spécifié à partir de l'objet <xref:System.Data.Objects.ObjectStateManager>. Si l'objet n'est pas chargé actuellement dans le contexte de l'objet, une requête est exécutée en vue de retourner l'objet à partir de la source de données. Pour plus d’informations, consultez [requêtes d’objet](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Utilisez la méthode <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> pour éviter de gérer l'exception <xref:System.Data.ObjectNotFoundException> levée par <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> lorsque l'objet est introuvable.  
  
 Cette méthode retourne des objets à l'état <xref:System.Data.EntityState.Deleted>.  
  
 Une clé temporaire ne peut pas être utilisée pour retourner un objet à partir de la source de données.  
  
 Le <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> méthode s’applique à .NET standard `TryParse` de modèle pour le <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> méthode, en retournant `false` lorsque le <xref:System.Data.ObjectNotFoundException> est interceptée.  
  
   
  
## Examples  
 L’exemple de cette rubrique est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L'exemple crée un objet <xref:System.Data.EntityKey> pour une entité du type donné, puis il essaie de récupérer une entité par clé.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Métadonnées incompatibles pour <paramref name="key" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Utilisation des objets (Entity Framework)</related>
      </Docs>
    </Member>
  </Members>
</Type>