<Type Name="MergeOption" FullName="System.Data.Objects.MergeOption">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7a293338991ef78298771270dfb73a3f393ab030" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66006390" /></Metadata><TypeSignature Language="C#" Value="public enum MergeOption" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed MergeOption extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.MergeOption" />
  <TypeSignature Language="VB.NET" Value="Public Enum MergeOption" />
  <TypeSignature Language="C++ CLI" Value="public enum class MergeOption" />
  <TypeSignature Language="F#" Value="type MergeOption = " />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Spécifie comment les objets qui sont chargés dans le contexte de l'objet sont fusionnés avec les objets déjà présents dans le contexte de l'objet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entity Framework conserve uniquement une seule instance d’un objet avec une clé d’entité spécifique dans le cache. Le <xref:System.Data.EntityKey> objets sont des objets immuables qui représentent l’identité de l’objet. Les clés d’entité sont utilisées pour assurer la résolution d’identité dans le contexte de l’objet. Pour plus d’informations, consultez [utilisation des clés d’entité](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd283139(v=vs.100)). Si une entité avec la même identité est déjà suivie, les données provenant de la source de données et les données figurant déjà dans le Gestionnaire d’état sont fusionnées en fonction de la <xref:System.Data.Objects.MergeOption> de la requête.  

### <a name="additional-information-on-mergeoptionpreservechanges"></a>Informations supplémentaires sur `MergeOption.PreserveChanges`

 Si l'état de l'entité est <xref:System.Data.EntityState.Unchanged?displayProperty=nameWithType>, les valeurs actuelles et d'origine dans l'entrée sont remplacées par les valeurs de la source de données. L'état de l'entité reste <xref:System.Data.EntityState.Unchanged?displayProperty=nameWithType> et aucune propriété n'est marquée comme modifiée.  
  
 Si l'état de l'entité est <xref:System.Data.EntityState.Modified?displayProperty=nameWithType>, les valeurs actuelles des propriétés modifiées ne sont pas remplacées par les valeurs de la source de données. Les valeurs d'origine des propriétés non modifiées sont remplacées par les valeurs de la source de données.  
  
 Dans .NET Framework 4, Entity Framework compare les valeurs actuelles des propriétés non modifiées avec les valeurs qui ont été retournées à partir de la source de données. Si les valeurs ne sont pas identiques, la propriété est marquée comme modifiée.  
  
 Dans .NET Framework 3.5 SP1, Entity Framework ne marque pas la propriété comme modifiée même si la valeur dans la source de données est différente.  
  
 Seules les propriétés modifiées sont rendues persistantes dans la source de données lorsque vous appelez <xref:System.Data.Objects.ObjectContext.SaveChanges%2A?displayProperty=nameWithType>.  
  
 Pour conserver le comportement de .NET Framework 3.5 SP1, affectez <xref:System.Data.Objects.ObjectContextOptions.UseLegacyPreserveChangesBehavior%2A?displayProperty=nameWithType> à `true`. L'option `PreserveChanges` peut être utilisée pour résoudre les exceptions d'accès concurrentiel optimiste tout en préservant les modifications dans le contexte local. Pour plus d’informations, consultez [enregistrement des modifications et la gestion de l’accès concurrentiel](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/bb738618(v=vs.100)).
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AppendOnly">
      <MemberSignature Language="C#" Value="AppendOnly" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption AppendOnly = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.AppendOnly" />
      <MemberSignature Language="VB.NET" Value="AppendOnly" />
      <MemberSignature Language="C++ CLI" Value="AppendOnly" />
      <MemberSignature Language="F#" Value="AppendOnly = 0" Usage="System.Data.Objects.MergeOption.AppendOnly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Les objets qui n'existent pas dans le contexte de l'objet ne sont pas attachés au contexte. Si un objet est déjà présent dans le contexte, les valeurs actuelles et d'origine des propriétés de l'objet dans l'entrée ne sont pas remplacées par les valeurs de la source de données. L'état de l'entrée de l'objet et l'état des propriétés de l'objet dans l'entrée ne changent pas. <see cref="F:System.Data.Objects.MergeOption.AppendOnly" /> est l'option de fusion par défaut.</summary>
      </Docs>
    </Member>
    <Member MemberName="NoTracking">
      <MemberSignature Language="C#" Value="NoTracking" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption NoTracking = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.NoTracking" />
      <MemberSignature Language="VB.NET" Value="NoTracking" />
      <MemberSignature Language="C++ CLI" Value="NoTracking" />
      <MemberSignature Language="F#" Value="NoTracking = 3" Usage="System.Data.Objects.MergeOption.NoTracking" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary>Les objets sont maintenus dans un état <see cref="F:System.Data.EntityState.Detached" /> et ne sont pas suivis dans l'objet <see cref="T:System.Data.Objects.ObjectStateManager" />. Toutefois, les entités générées par [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] et les entités POCO avec proxys conservent une référence au contexte de l'objet pour faciliter le chargement d'objets connexes.</summary>
      </Docs>
    </Member>
    <Member MemberName="OverwriteChanges">
      <MemberSignature Language="C#" Value="OverwriteChanges" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption OverwriteChanges = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.OverwriteChanges" />
      <MemberSignature Language="VB.NET" Value="OverwriteChanges" />
      <MemberSignature Language="C++ CLI" Value="OverwriteChanges" />
      <MemberSignature Language="F#" Value="OverwriteChanges = 1" Usage="System.Data.Objects.MergeOption.OverwriteChanges" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Les objets qui n'existent pas dans le contexte de l'objet ne sont pas attachés au contexte. Si un objet est déjà présent dans le contexte, les valeurs actuelles et d'origine des propriétés de l'objet dans l'entrée sont remplacées par les valeurs de la source de données. L'état de l'entrée de l'objet a la valeur <see cref="F:System.Data.EntityState.Unchanged" />, aucune propriété n'est marquée comme modifiée.</summary>
      </Docs>
    </Member>
    <Member MemberName="PreserveChanges">
      <MemberSignature Language="C#" Value="PreserveChanges" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption PreserveChanges = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.PreserveChanges" />
      <MemberSignature Language="VB.NET" Value="PreserveChanges" />
      <MemberSignature Language="C++ CLI" Value="PreserveChanges" />
      <MemberSignature Language="F#" Value="PreserveChanges = 2" Usage="System.Data.Objects.MergeOption.PreserveChanges" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Les objets qui n'existent pas dans le contexte de l'objet ne sont pas attachés au contexte.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>