<Type Name="D3DImage" FullName="System.Windows.Interop.D3DImage">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a7c61f02ac2c5dc3b0e3bc8d542bcdce21fef3dc" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48628086" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class D3DImage : System.Windows.Media.ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi D3DImage extends System.Windows.Media.ImageSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.D3DImage" />
  <TypeSignature Language="VB.NET" Value="Public Class D3DImage&#xA;Inherits ImageSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class D3DImage : System::Windows::Media::ImageSource" />
  <TypeSignature Language="F#" Value="type D3DImage = class&#xA;    inherit ImageSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.ImageSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Windows.Media.ImageSource" /> qui affiche une surface Direct3D créée par l'utilisateur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Windows.Interop.D3DImage> classe pour héberger le contenu Direct3D dans une application Windows Presentation Foundation (WPF).  
  
 Appelez le <xref:System.Windows.Interop.D3DImage.Lock%2A> méthode pour modifier le contenu Direct3D affiché par le <xref:System.Windows.Interop.D3DImage>. Appelez le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> méthode pour attribuer une surface Direct3D à un <xref:System.Windows.Interop.D3DImage>. Appelez le <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> méthode pour effectuer le suivi des mises à jour vers la surface Direct3D. Appelez le <xref:System.Windows.Interop.D3DImage.Unlock%2A> méthode pour afficher les zones modifiées.  
  
 Le <xref:System.Windows.Interop.D3DImage> classe gère deux mémoires tampons d’affichage, qui sont appelées les *mémoire tampon d’arrière-plan* et *tampon d’affichage*. La mémoire tampon d’arrière-plan est votre surface Direct3D.  Modifications apportées à la mémoire tampon d’arrière-plan sont copiées en avant dans le tampon d’affichage lorsque vous appelez le <xref:System.Windows.Interop.D3DImage.Unlock%2A> méthode, où il est affiché sur le matériel. Parfois, le tampon d’affichage n’est plus disponible. Ce manque de disponibilité peut être dû de verrouillage de l’écran, les applications Direct3D exclusives plein écran, changement d’utilisateur ou autres activités du système. Lorsque cela se produit, votre application WPF est notifiée en gérant la <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement.  Comment votre application répond à la mémoire tampon avant d’indisponible dépend de Si WPF est activé à revenir au rendu logiciel. Le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> méthode a une surcharge qui accepte un paramètre qui spécifie si WPF revient au rendu logiciel.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-does-not-fall-back-to-software-rendering"></a>Répondre à un tampon d’affichage indisponible lorsque WPF ne revient pas au logiciel rendu  
 Lorsque vous appelez le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> surcharger ou appeler le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> surcharge avec le `enableSoftwareFallback` paramètre défini sur `false`, le système de rendu libère sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible et que rien n’est affiché. Lorsque le tampon d’affichage est à nouveau disponible, le système de rendu déclenche le <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement pour avertir votre application WPF.  Vous pouvez créer un gestionnaire d’événements pour le <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement pour redémarrer le rendu avec une surface Direct3D valide. Pour redémarrer le rendu, vous devez appeler <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-falls-back-to-software-rendering"></a>Répondre à un tampon d’affichage non disponible lors de WPF revient au rendu logiciel  
 Lorsque vous appelez le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> surcharge avec le `enableSoftwareFallback` paramètre défini sur `true`, le système de rendu conserve sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible, il est donc inutile d’appeler <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> lors de l’avant mémoire tampon est à nouveau disponible.  Il peut arriver dans lequel le périphérique l’utilisateur n’est plus disponible.  Lorsque cela se produit, appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> pour libérer la référence de WPF à la mémoire tampon d’arrière-plan.  Si vous devez réinitialiser votre appareil, appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> avec la `backBuffer` paramètre défini sur `null`, puis appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> avec `backBuffer` défini sur une surface Direct3D valide.  
  
> [!NOTE]
>  Performances varie considérablement selon les paramètres de la surface Direct3D. Pour plus d’informations, consultez [Performance Considerations for Direct3D9 et WPF interopérabilité](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
> [!NOTE]
>  Le <xref:System.Windows.Interop.D3DImage> classe n’affiche pas le contenu de Direct3D lorsque WPF est rendu dans le logiciel, telles que via une connexion Bureau à distance, sauf si vous appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> et spécifiez `true` pour le `enableSoftwareFallback` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déclarer un <xref:System.Windows.Interop.D3DImage> dans XAML. Vous devez mapper le <xref:System.Windows.Interop> espace de noms, car il n’est pas inclus dans les espaces de noms XAML par défaut. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-xaml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La résolution d’affichage par défaut est 1/96e de pouce.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage (double dpiX, double dpiY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 dpiX, float64 dpiY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dpiX As Double, dpiY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage(double dpiX, double dpiY);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.D3DImage : double * double -&gt; System.Windows.Interop.D3DImage" Usage="new System.Windows.Interop.D3DImage (dpiX, dpiY)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dpiX">Résolution d'affichage sur l'axe X.</param>
        <param name="dpiY">Résolution d'affichage sur l'axe Y.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Interop.D3DImage" /> avec la résolution d'affichage spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La résolution d’affichage par défaut est 1/96e de pouce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dpiX" /> ou <paramref name="dpiY" /> est inférieur à zéro.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberSignature Language="F#" Value="member this.AddDirtyRect : System.Windows.Int32Rect -&gt; unit" Usage="d3DImage.AddDirtyRect dirtyRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">
          <see cref="T:System.Windows.Int32Rect" /> qui représente la zone qui a été modifiée.</param>
        <summary>Spécifie la zone de la mémoire tampon d'arrière-plan qui a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> méthode pour indiquer les modifications apportées par votre code à la mémoire tampon d’arrière-plan. Pour être rendue, la zone modifiée sur la mémoire tampon d’arrière-plan doit avoir une zone modifiée correspondante le <xref:System.Windows.Interop.D3DImage>.  
  
 Appelez le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> et <xref:System.Windows.Interop.D3DImage.Lock%2A> méthodes avant d’appeler le <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> (méthode).  
  
 Appelez le <xref:System.Windows.Interop.D3DImage.Unlock%2A> méthode pour copier les zones modifiées dans le tampon d’affichage.  
  
> [!NOTE]
>  Après quelques appels à la <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> (méthode), les zones modifiées sont fusionnées dans une seule zone. Cela signifie que vous devez disposer des données valides en dehors des zones modifiées.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> méthode pour spécifier la région modifiée dans la mémoire tampon d’arrière-plan. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La bitmap n'a pas été verrouillée par un appel à la méthode <see cref="M:System.Windows.Interop.D3DImage.Lock" /> ou <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />.  
  
- ou - 
La mémoire tampon d'arrière-plan n'a pas été assignée par un appel à la méthode <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une ou plusieurs des conditions suivantes sont vraies.  
  
 <paramref name="dirtyRect.X" /> &lt; 0 
 <paramref name="dirtyRect.Y" /> &lt; 0 
 <paramref name="dirtyRect.Width" /> &lt; 0 ou <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 ou <paramref name="dirtyRect.Height" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un clone modifiable de cet objet <see cref="T:System.Windows.Interop.D3DImage" />, en créant des copies intégrales des valeurs de l'objet. Lors de la copie de propriétés de dépendance, cette méthode copie les références de ressources et les liaisons de données (même si elles ne peuvent plus être résolues), mais pas les animations ni leurs valeurs actuelles.</summary>
        <returns>Clone modifiable de l'objet actif. La propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l’objet cloné sera <see langword="false" />, même si la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source était <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour générer des copies modifiables de figé <xref:System.Windows.Freezable> objets (ou n’importe quel <xref:System.Windows.Freezable> objet). Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.  
  
 Pour plus d'informations, consultez <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Fait de l’instance un clone (copie complète) du <see cref="T:System.Windows.Freezable" /> spécifié utilisant des valeurs de propriété (non animée) de base.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un clone modifiable de cet objet <see cref="T:System.Windows.Interop.D3DImage" />, en effectuant une copie complète des valeurs actuelles de cet objet. Contrairement à leurs valeurs actuelles, les références de ressources, les liaisons de données et les animations ne sont pas copiées.</summary>
        <returns>Clone modifiable de l'objet actif. La valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l'objet cloné est <see langword="false" />, même si la valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source était <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour générer des copies modifiables de figé <xref:System.Windows.Freezable> objets (ou n’importe quel <xref:System.Windows.Freezable> objet). Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.  
  
 Pour plus d'informations, consultez <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <see cref="T:System.Windows.Freezable" /> à cloner.</param>
        <summary>Fait de l’instance un clone (copie complète) modifiable du <see cref="T:System.Windows.Freezable" /> spécifié à l’aide des valeurs de propriété actuelles.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CopyBackBuffer">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.Media.Imaging.BitmapSource CopyBackBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CopyBackBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CopyBackBuffer () As BitmapSource" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::Media::Imaging::BitmapSource ^ CopyBackBuffer();" />
      <MemberSignature Language="F#" Value="abstract member CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource&#xA;override this.CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource" Usage="d3DImage.CopyBackBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.BitmapSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie logicielle du <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <returns>
          <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> qui est une copie logicielle de l'état actuel de la mémoire tampon d'arrière-plan ; sinon, <see langword="null" /> si la mémoire tampon d'arrière-plan ne peut pas être lue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> méthode est appelée par les clients, tels que le système d’impression et la <xref:System.Windows.Media.Imaging.RenderTargetBitmap> classe.  
  
 Si vous le souhaitez remplacer le <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> méthode pour implémenter une logique personnalisée et retourner un autre <xref:System.Windows.Media.Imaging.BitmapSource>. Par exemple, vous pouvez retourner un espace réservé <xref:System.Windows.Media.Imaging.BitmapSource> si la valeur par défaut <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implémentation retourne `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable&#xA;override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="d3DImage.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Une fois implémentée dans une classe dérivée, initialise une nouvelle instance de la classe dérivée <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <returns>Nouvelle instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous dérivez de la <xref:System.Windows.Interop.D3DImage> (classe), vous devez substituer la <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> méthode pour activer un clonage correct. L’implémentation par défaut effectue une `return new D3DImage()`, qui ne seront pas correct si l’instance est une classe différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!D3DImage ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="d3DImage.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources et exécute d’autres opérations de nettoyage avant la récupération du <see cref="T:System.Windows.Interop.D3DImage" /> par la garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Object.Finalize%2A>. Code d’application ne doit pas appeler cette méthode ; d’un objet `Finalize` méthode est appelée automatiquement lors du garbage collection, à moins que la finalisation par le garbage collector a été désactivée par un appel à la <xref:System.GC.SuppressFinalize%2A> (méthode).  
  
 Pour plus d’informations, consultez [destructeurs et méthodes Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md), et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override sealed bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="d3DImage.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">N'a aucun effet.</param>
        <summary>Rend le <see cref="T:System.Windows.Interop.D3DImage" /> non modifiable ou détermine s'il peut être rendu non modifiable.</summary>
        <returns>
          <see langword="false" /> dans tous les cas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Interop.D3DImage> classe n’autorise pas le gel car des modifications sont toujours possibles en raison de la disponibilité du tampon d’affichage.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Instance à copier.</param>
        <summary>Convertit l'instance en clone figé du <see cref="T:System.Windows.Freezable" /> spécifié à l'aide des valeurs de propriétés (non-animées) de base.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <see cref="T:System.Windows.Freezable" /> à copier et figer.</param>
        <summary>Convertit l'instance actuelle en un clone figé du <see cref="T:System.Windows.Freezable" /> spécifié. Si l’objet a des propriétés de dépendance animées, leurs valeurs animées actuelles sont copiées.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public override sealed double Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Height" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Height : double" Usage="System.Windows.Interop.D3DImage.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la hauteur du <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <value>Hauteur du <see cref="T:System.Windows.Interop.D3DImage" /> en unités de mesure. Une unité de mesure est égale à 1/96e de pouce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de <xref:System.Windows.Interop.D3DImage.Height%2A> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailable">
      <MemberSignature Language="C#" Value="public bool IsFrontBufferAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrontBufferAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrontBufferAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrontBufferAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailable : bool" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si un tampon d'affichage existe.</summary>
        <value>
          <see langword="true" /> si un tampon d'affichage existe ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parfois, le tampon d’affichage n’est plus disponible. Ce manque de disponibilité peut être dû de verrouillage de l’écran, les applications Direct3D exclusives plein écran, changement d’utilisateur ou autres activités du système. Lorsque cela se produit, votre application WPF est notifiée en gérant la <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement.  Comment votre application répond à la mémoire tampon avant d’indisponible dépend de Si WPF est activé à revenir au rendu logiciel. Le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> méthode a une surcharge qui accepte un paramètre qui spécifie si WPF revient au rendu logiciel. Pour plus d’informations, consultez la section Notes dans la <xref:System.Windows.Interop.D3DImage> classe.  
  
<a name="dependencyPropertyInfo_IsFrontBufferAvailable"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple de code suivant montre comment vérifier la <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> propriété lors du rendu de la cible de composition. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
        <altmember cref="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsFrontBufferAvailableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la propriété <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gérer la <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> d’être averti lorsque l’état du tampon d’affichage change. Comment votre application répond à la mémoire tampon avant d’indisponible dépend de Si WPF est activé à revenir au rendu logiciel. Le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> méthode a une surcharge qui accepte un paramètre qui spécifie si WPF revient au rendu logiciel. Pour plus d’informations, consultez la section Notes dans la <xref:System.Windows.Interop.D3DImage> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFrontBufferAvailableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFrontBufferAvailableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFrontBufferAvailableProperty : System.Windows.DependencyProperty" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberSignature Language="F#" Value="member this.Lock : unit -&gt; unit" Usage="d3DImage.Lock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verrouille le <see cref="T:System.Windows.Interop.D3DImage" /> et active des opérations sur la mémoire tampon d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.Interop.D3DImage.Lock%2A> méthode pour modifier la mémoire tampon d’arrière-plan en appelant le <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> et <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> méthodes. Bien que le <xref:System.Windows.Interop.D3DImage> est verrouillé, votre application peut également rendre à la surface Direct3D affectée à la mémoire tampon d’arrière-plan.  
  
> [!NOTE]
>  Le <xref:System.Windows.Interop.D3DImage.Lock%2A> méthode se bloque lorsque le système de rendu lit la mémoire tampon d’arrière-plan pour mettre à jour le tampon d’affichage. Utilisez le <xref:System.Windows.Interop.D3DImage.TryLock%2A> méthode pour éviter de bloquer indéfiniment.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Windows.Interop.D3DImage.Lock%2A> méthode d’activation des mises à jour de la mémoire tampon d’arrière-plan. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le nombre de verrous est égal à <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.Media.ImageMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Metadata As ImageMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageMetadata ^ Metadata { System::Windows::Media::ImageMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Metadata : System.Windows.Media.ImageMetadata" Usage="System.Windows.Interop.D3DImage.Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les métadonnées associées à la source d'image.</summary>
        <value>
          <see langword="null" /> dans tous les cas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelHeight">
      <MemberSignature Language="C#" Value="public int PixelHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelHeight : int" Usage="System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la hauteur du <see cref="T:System.Windows.Interop.D3DImage" /> en pixels.</summary>
        <value>Hauteur du <see cref="T:System.Windows.Interop.D3DImage" /> en pixels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> propriété pour spécifier la région modifiée dans la mémoire tampon d’arrière-plan. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelWidth" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PixelWidth">
      <MemberSignature Language="C#" Value="public int PixelWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelWidth : int" Usage="System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la largeur du <see cref="T:System.Windows.Interop.D3DImage" /> en pixels.</summary>
        <value>Largeur du <see cref="T:System.Windows.Interop.D3DImage" />, en pixels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> propriété pour spécifier la région modifiée dans la mémoire tampon d’arrière-plan. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelHeight" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBackBuffer">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Assigne une surface Direct3D comme source de la mémoire tampon d'arrière-plan.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Type de surface Direct3D. Doit être un <see cref="T:System.Windows.Interop.D3DResourceType" /> valide.</param>
        <param name="backBuffer">Surface Direct3D à attribuer comme mémoire tampon d'arrière-plan.</param>
        <summary>Assigne une surface Direct3D comme source de la mémoire tampon d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> méthode pour attribuer une surface Direct3D à la mémoire tampon d’arrière-plan.  
  
> [!NOTE]
>  Performances varie considérablement selon les paramètres de la surface Direct3D. Pour plus d’informations, consultez [Performance Considerations for Direct3D9 et WPF interopérabilité](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
 Appelant le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> surcharge est identique à l’appel le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> surcharge avec le `enableSoftwareFallback` paramètre défini sur `false`. Lorsque vous appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> ou appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> avec la `enableSoftwareFallback` paramètre défini sur `false`, le système de rendu libère sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible et rien ne s’affiche. Lorsque le tampon d’affichage est à nouveau disponible, le système de rendu déclenche le <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement pour avertir votre application WPF.  Vous pouvez créer un gestionnaire d’événements pour le <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement pour redémarrer le rendu avec une surface Direct3D valide. Pour redémarrer le rendu, vous devez appeler <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
 La liste suivante présente les paramètres de mémoire tampon d’arrière-plan requis pour le `IDirect3DSurface9` type.  
  
-   `D3DFMT_A8R8G8B8` ou `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 L’échantillonnage multiple est autorisée sur `IDirect3DSurface9Ex` met en évidence uniquement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> méthode pour attribuer une surface Direct3D. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Windows.Interop.D3DImage" /> n'a pas été verrouillé par un appel à la méthode <see cref="M:System.Windows.Interop.D3DImage.Lock" /> ou <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="backBufferType" /> n’est pas un <see cref="T:System.Windows.Interop.D3DResourceType" /> valide.</exception>
        <exception cref="T:System.ArgumentException">Les paramètres de création de <paramref name="backBuffer" /> ne répondent pas aux spécifications pour <paramref name="backBufferType" /> - ou- Le périphérique <paramref name="backBuffer" /> n'est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer, bool enableSoftwareFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr, enableSoftwareFallback As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint * bool -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer, enableSoftwareFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
        <Parameter Name="enableSoftwareFallback" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Type de surface Direct3D. Doit être un <see cref="T:System.Windows.Interop.D3DResourceType" /> valide.</param>
        <param name="backBuffer">Surface Direct3D à attribuer comme mémoire tampon d'arrière-plan.</param>
        <param name="enableSoftwareFallback">
          <see langword="true" /> pour revenir au rendu logiciel ; sinon, <see langword="false" />.</param>
        <summary>Assigne une surface Direct3D comme source de la mémoire tampon d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appelez le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> surcharger ou appeler le <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> surcharge avec le `enableSoftwareFallback` paramètre défini sur `false`, le système de rendu libère sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible et que rien n’est affiché. Lorsque le tampon d’affichage est à nouveau disponible, le système de rendu déclenche le <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement pour avertir votre application WPF.  Vous pouvez créer un gestionnaire d’événements pour le <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> événement pour redémarrer le rendu avec une surface Direct3D valide. Pour redémarrer le rendu, vous devez appeler <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
 Lorsque vous appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> avec la `enableSoftwareFallback` paramètre défini sur `true`, le système de rendu conserve sa référence à la mémoire tampon d’arrière-plan lorsque le tampon d’affichage n’est plus disponible, il est donc inutile d’appeler <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> lorsque le tampon d’affichage est disponible à nouveau.  Il peut arriver dans lequel le périphérique l’utilisateur n’est plus disponible.  Lorsque cela se produit, appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> pour libérer la référence de WPF à la mémoire tampon d’arrière-plan.  Si vous devez réinitialiser votre appareil, appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> avec `backBuffer` définie sur `null`, puis appelez <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> avec `backBuffer` défini sur une surface Direct3D valide.  
  
 La liste suivante présente les paramètres de mémoire tampon d’arrière-plan requis pour le `IDirect3DSurface9` type.  
  
-   `D3DFMT_A8R8G8B8` ou `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 L’échantillonnage multiple est autorisée sur `IDirect3DSurface9Ex` met en évidence uniquement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberSignature Language="F#" Value="member this.TryLock : System.Windows.Duration -&gt; bool" Usage="d3DImage.TryLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Durée d'attente avant l'acquisition du verrou.</param>
        <summary>Tente de verrouiller le <see cref="T:System.Windows.Interop.D3DImage" /> et attend pendant la durée spécifiée.</summary>
        <returns>
          <see langword="true" /> si le verrou a été acquis ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> a la valeur <see cref="P:System.Windows.Duration.Automatic" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le nombre de verrous est égal à <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberSignature Language="F#" Value="member this.Unlock : unit -&gt; unit" Usage="d3DImage.Unlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décrémente le nombre de verrous pour le <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le nombre de verrous pour la <xref:System.Windows.Interop.D3DImage> atteint zéro, le <xref:System.Windows.Interop.D3DImage> est entièrement déverrouillé. Le <xref:System.Windows.Interop.D3DImage> est marqué pour le rendu si l’image a modifié des zones qui ont été spécifiés par les appels précédents à la <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> (méthode).  
  
 Lorsque les modifications sont validées et le rendu se produit, des appels supplémentaires à la <xref:System.Windows.Interop.D3DImage.Lock%2A> un bloc de méthode jusqu'à ce que le thread de rendu a copié le contenu de la mémoire tampon d’arrière-plan dans le tampon d’affichage. Cette synchronisation évite les artefacts d’affichage, telles que la destruction.  
  
> [!NOTE]
>  Ne mettez pas à jour la surface Direct3D lors de la <xref:System.Windows.Interop.D3DImage> est déverrouillé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Windows.Interop.D3DImage.Unlock%2A> méthode pour copier la mémoire tampon d’arrière-plan mise à jour vers le tampon d’affichage. Pour plus d’informations, consultez [procédure pas à pas : hébergement de contenu Direct3D9 dans WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public override sealed double Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Width" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Width : double" Usage="System.Windows.Interop.D3DImage.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la largeur du <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <value>Largeur du <see cref="T:System.Windows.Interop.D3DImage" /> en unités de mesure. Une unité de mesure est égale à 1/96e de pouce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de <xref:System.Windows.Interop.D3DImage.Width%2A> peut changer lorsqu’une nouvelle mémoire tampon d’arrière-plan est assignée par un appel à la <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
  </Members>
</Type>