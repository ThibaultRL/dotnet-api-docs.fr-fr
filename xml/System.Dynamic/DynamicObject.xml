<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="441ffdca4dc64bd1fee3aff7e839255c64f79d34" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65003616" /></Metadata><TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une classe de base pour spécifier le comportement dynamique au moment de l'exécution. Cette classe doit être héritée ; vous ne pouvez pas l'instancier directement.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `DynamicObject` classe vous permet de définir quelles opérations peuvent être effectuées sur les objets dynamiques et comment effectuer ces opérations. Par exemple, vous pouvez définir ce qui se passe lorsque vous tentez d’obtenir ou définir une propriété d’objet, appeler une méthode ou effectuent des opérations mathématiques standards telles que l’addition et la multiplication.  
  
 Cette classe peut être utile si vous souhaitez créer un protocole plus commode pour une bibliothèque. Par exemple, si les utilisateurs de votre bibliothèque doivent utiliser une syntaxe comme `Scriptobj.SetProperty("Count", 1)`, vous pouvez fournir la possibilité d’utiliser la syntaxe beaucoup plus simple, comme `scriptobj.Count = 1`.  
  
 Vous ne pouvez pas créer directement une instance de la `DynamicObject` classe. Pour implémenter le comportement dynamique, vous souhaiterez héritent la `DynamicObject` classe et substituer les méthodes nécessaires. Par exemple, si vous avez besoin d’opérations uniquement pour définir et obtenir les propriétés, vous pouvez remplacer simplement le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes.  
  
 En c#, pour activer le comportement dynamique pour les instances des classes dérivées de la `DynamicObject` (classe), vous devez utiliser le `dynamic` mot clé. Pour plus d’informations, consultez [Utilisation du type dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 En Visual Basic, les opérations dynamiques sont pris en charge par la liaison tardive. Pour plus d’informations, consultez [liaison anticipée et liaison tardive](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 L’exemple de code suivant montre comment créer une instance d’une classe dérivée de la `DynamicObject` classe.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Vous pouvez également ajouter vos propres membres aux classes dérivées de la `DynamicObject` classe. Si votre classe définit des propriétés et substitue la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (méthode), le dynamic language runtime (DLR) utilise d’abord le classeur de langage pour rechercher une définition statique d’une propriété dans la classe. S’il n’existe pas de propriété, le DLR appelle le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (méthode).  
  
 Le `DynamicObject` classe implémente l’interface DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, ce qui vous permet de partager des instances de la `DynamicObject` classe entre les langages qui prennent en charge le modèle d’interopérabilité DLR. Par exemple, vous pouvez créer une instance de la `DynamicObject` classe en c# et puis de le passer à une fonction IronPython. Pour plus d’informations, consultez [Dynamic Language Runtime Overview](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Si vous avez un scénario simple dans lequel vous avez besoin d’un objet qui peut uniquement ajouter et supprimer des membres au moment de l’exécution, mais qui ne doivent pas définir des opérations spécifiques et ne pas avoir de membres statiques, utilisez la <xref:System.Dynamic.ExpandoObject> classe.  
>   
>  Si vous avez un scénario plus avancé dans lequel vous devez définir comment les objets dynamiques participent au protocole d’interopérabilité, ou vous avez besoin gérer la mise en cache de distribution dynamiques rapides DLR, créez votre propre implémentation de la <xref:System.Dynamic.IDynamicMetaObjectProvider> interface.  
  
   
  
## Examples  
 Supposons que vous voulez fournir une autre syntaxe pour accéder aux valeurs dans un dictionnaire, ainsi que, au lieu de la rédaction de `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), vous pouvez écrire `sampleDictionary.Text = "Sample text"`. En outre, vous souhaitez que cette syntaxe à respecter la casse, afin que `sampleDictionary.Text` équivaut à `sampleDictionary.text`.  
  
 L’exemple de code suivant montre le `DynamicDictionary` (classe), qui est dérivée de la `DynamicObject` classe. Le `DynamicDictionary` classe contient un objet de la `Dictionary<string, object>` type (`Dictionary(Of String, Object)` en Visual Basic) pour stocker les paires clé-valeur et les remplacements le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour prendre en charge la nouvelle syntaxe. Il fournit également un `Count` contient de la propriété, qui affiche le nombre de propriétés dynamique du dictionnaire.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Pour plus d’exemples, consultez [création de Wrappers avec DynamicObject](https://devblogs.microsoft.com/csharpfaq/dynamic-in-c-4-0-creating-wrappers-with-dynamicobject/) sur le blog de C# Forum aux Questions.  
 
 
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Permet aux types dérivés d’initialiser une nouvelle instance de la <see cref="T:System.Dynamic.DynamicObject" /> type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas créer directement une instance de la <xref:System.Dynamic.DynamicObject> classe. Pour implémenter le comportement dynamique, vous devez hériter de la <xref:System.Dynamic.DynamicObject> classe et substituer les méthodes nécessaires.  
  
 En c#, pour activer le comportement dynamique pour les instances des classes dérivées de la <xref:System.Dynamic.DynamicObject> (classe), vous devez utiliser le `dynamic` mot clé. Pour plus d’informations, consultez [Utilisation du type dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 En Visual Basic, les opérations dynamiques sont pris en charge par la liaison tardive. Pour plus d’informations, consultez [liaison anticipée et liaison tardive](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une instance des classes dérivées de la <xref:System.Dynamic.DynamicObject> classe.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l’énumération de tous les noms de membre dynamique.</summary>
        <returns>Séquence qui contient les noms de membres dynamiques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode existe uniquement à des fins de débogage.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">L’expression qui représente <see cref="T:System.Dynamic.DynamicMetaObject" /> à distribuer aux méthodes virtuelles dynamiques.</param>
        <summary>Fournit un <see cref="T:System.Dynamic.DynamicMetaObject" /> qui distribue aux méthodes virtuelles dynamiques. L’objet peut être encapsulé dans un autre <see cref="T:System.Dynamic.DynamicMetaObject" /> pour fournir un comportement personnalisé pour des actions individuelles. Cette méthode prend en charge l’infrastructure Dynamic Language Runtime pour les implémenteurs de langage et elle n’est pas destinée à être utilisée directement à partir de votre code.</summary>
        <returns>Un objet de la <see cref="T:System.Dynamic.DynamicMetaObject" /> type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération binaire. La propriété <c>binder.Operation</c> retourne un objet <see cref="T:System.Linq.Expressions.ExpressionType" />. Par exemple, pour l’instruction <c>sum = first + second</c>, où <c>first</c> et <c>second</c> sont dérivés de la classe <see langword="DynamicObject" />, <c>binder.Operation</c> retourne <c>ExpressionType.Add</c>.</param>
        <param name="arg">L’opérande de droite pour l’opération binaire. Par exemple, pour l’instruction <c>sum = first + second</c>, où <c>first</c> et <c>second</c> sont dérivés de la classe <see langword="DynamicObject" />, <paramref name="arg" /> est égal à <c>second</c>.</param>
        <param name="result">Le résultat de l’opération binaire.</param>
        <summary>Fournit l’implémentation pour les opérations binaires. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations telles que l’addition et la multiplication.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment les opérations binaires doivent être exécutées pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Cette méthode est appelée lorsque vous avez des opérations binaires telles que l’addition ou la multiplication. Par exemple, si le <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> méthode est substituée, elle est automatiquement appelée pour des instructions comme `sum = first + second` ou `multiply = first*second`, où `first` est dérivé le `DynamicObject` classe.  
  
 Vous pouvez obtenir des informations sur le type de l’opération binaire à l’aide de la `Operation` propriété de le `binder` paramètre.  
  
 Si votre objet dynamique est utilisé uniquement dans c# et Visual Basic, le `binder.Operation` propriété peut avoir l’une des valeurs suivantes à partir de la <xref:System.Linq.Expressions.ExpressionType> énumération. Toutefois, dans d’autres langages tels que IronPython ou IronRuby, vous pouvez avoir d’autres valeurs.
  
|Value|Description|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Une opération d’ajout sans vérification de dépassement, pour les opérandes numériques.|`a + b`|`a + b`|  
|`AddAssign`|Une opération d’assignation composée ajout sans vérification de dépassement, pour les opérandes numériques.|`a += b`|Non pris en charge.|  
|`And`|Une opération de bits `AND` opération.|`a & b`|`a And b`|  
|`AndAssign`|Une opération de bits `AND` opération d’assignation composée.|`a &= b`|Non pris en charge.|  
|`Divide`|Une opération de division arithmétique.|`a / b`|`a / b`|  
|`DivideAssign`|Une opération d’assignation composée de division arithmétique.|`a /= b`|Non pris en charge.|  
|`ExclusiveOr`|Une opération de bits `XOR` opération.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Une opération de bits `XOR` opération d’assignation composée.|`a ^= b`|Non pris en charge.|  
|`GreaterThan`|Comparaison « supérieure à ».|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Comparaison « supérieure ou égal à ».|`a >= b`|Non pris en charge.|  
|`LeftShift`|Une opération de décalage vers la gauche au niveau du bit.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Une opération au niveau du bit assignation composée de décalage vers la gauche.|`a <<= b`|Non pris en charge.|  
|`LessThan`|Comparaison « inférieur à ».|`a < b`|`a < b`|  
|`LessThanOrEqual`|Comparaison « inférieur ou égal à ».|`a <= b`|Non pris en charge.|  
|`Modulo`|Une opération arithmétique relative au reste.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Une opération d’assignation composée de reste arithmétique.|`a %= b`|Non pris en charge.|  
|`Multiply`|Une opération de multiplication sans vérification de dépassement, pour les opérandes numériques.|`a * b`|`a * b`|  
|`MultiplyAssign`|Une opération d’assignation composée de multiplication sans vérification de dépassement, pour les opérandes numériques.|`a *= b`|Non pris en charge.|  
|`NotEqual`|Comparaison d’inégalité.|`a != b`|`a <> b`|  
|`Or`|Au niveau du bit ou logique `OR` opération.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Au niveau du bit ou logique `OR` assignation composée.|`a &#124;= b`|Non pris en charge.|  
|`Power`|Une opération mathématique de l’élévation d’un nombre à une puissance.|Non pris en charge.|`a ^ b`|  
|`RightShift`|Une opération de décalage vers la droite au niveau du bit.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Une opération au niveau du bit assignation composée de décalage vers la droite.|`a >>= b`|Non pris en charge.|  
|`Subtract`|Une opération de soustraction sans vérification de dépassement, pour les opérandes numériques.|`a - b`|`a - b`|  
|`SubtractAssign`|Une opération d’assignation composée de soustraction sans vérification de dépassement, pour les opérandes numériques.|`a -= b`|Non pris en charge.|  
  
> [!NOTE]
>  Pour implémenter `OrElse` (`a || b`) et `AndAlso` (`a && b`) des opérations pour les objets dynamiques en c#, vous souhaiterez implémenter les deux le <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> (méthode) et le <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> (méthode).  
>   
>  Le `OrElse` opération se compose de l’unaire `IsTrue` opération et le fichier binaire `Or` opération. Le `Or` opération est effectuée uniquement si le résultat de la `IsTrue` opération est `false`.  
>   
>  Le `AndAlso` opération se compose de l’unaire `IsFalse` opération et le fichier binaire `And` opération. Le `And` opération est effectuée uniquement si le résultat de la `IsFalse` opération est `false`.  
  
   
  
## Examples  
 Supposons que vous avez besoin d’une structure de données pour stocker des représentations textuelles et numériques de nombres, et que vous souhaitez définir des opérations mathématiques de base comme l’addition et soustraction pour ce type de données.  
  
 L’exemple de code suivant montre le `DynamicNumber` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` remplace le <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> méthode pour permettre des opérations mathématiques. Il substitue également la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour activer l’accès aux éléments.  
  
 Dans cet exemple, les seules opérations d’addition et de soustraction sont prises en charge. Si vous essayez d’écrire une instruction telle que `resultNumber = firstNumber*secondNumber`, une exception au moment de l’exécution est levée.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération de conversion. La propriété <c>binder.Type</c> fournit le type dans lequel l’objet doit être converti. Par exemple, pour l’instruction <c>(String)sampleObject</c> en C# (<c>CType(sampleObject, Type)</c> en Visual Basic), où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> retourne le type <see cref="T:System.String" />. La propriété <c>binder.Explicit</c> fournit des informations sur le genre de conversion qui se produit. Elle retourne <see langword="true" /> pour la conversion explicite et <see langword="false" /> pour la conversion implicite.</param>
        <param name="result">Le résultat de l’opération de conversion de type.</param>
        <summary>Fournit l’implémentation pour le type des opérations de conversion. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour certaines opérations qui convertissent un objet d’un type vers un autre.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment une conversion de type doit être exécutée pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 En c#, si cette méthode est substituée, elle est automatiquement appelée lorsque vous avez une conversion explicite ou implicite, comme illustré dans l’exemple de code ci-dessous.  
  
 Dans Visual Basic, seule la conversion explicite est pris en charge. Si vous substituez cette méthode, vous l’appelez à l’aide de la <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> ou <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> fonctions.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Supposons que vous avez besoin d’une structure de données pour stocker des représentations textuelles et numériques de nombres, et que vous souhaitez définir des conversions de cette structure de données pour les chaînes et les entiers.  
  
 L’exemple de code suivant montre le `DynamicNumber` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` remplace le <xref:System.Dynamic.DynamicObject.TryConvert%2A> méthode pour permettre la conversion de type. Il substitue également la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour activer l’accès aux éléments de données.  
  
 Dans cet exemple, seule la conversion en chaînes et en entiers est prise en charge. Si vous essayez de convertir un objet en un autre type, une exception au moment de l’exécution est levée.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération d’initialisation.</param>
        <param name="args">Les arguments qui sont passés à l’objet pendant l’initialisation. Par exemple, pour l’opération <c>new SampleType(100)</c>, où <c>SampleType</c> est le type dérivé la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
        <param name="result">Le résultat de l’initialisation.</param>
        <summary>Fournit l’implémentation pour les opérations qui initialisent une nouvelle instance d’un objet dynamique. Cette méthode n’est pas conçue pour une utilisation en c# ou Visual Basic.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment une nouvelle instance de l’objet dynamique doit être initialisée. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Compilateurs c# et Visual Basic émettent jamais de code pour utiliser cette méthode, car ils ne gèrent pas les types de première classe. Cette méthode est conçue pour les langages qui prennent en charge l’initialisation des objets dynamiques à l’aide d’une syntaxe comme `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur la suppression.</param>
        <param name="indexes">Les index à supprimer.</param>
        <summary>Fournit l’implémentation pour les opérations qui suppriment un objet par index. Cette méthode n’est pas conçue pour une utilisation en c# ou Visual Basic.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment une valeur qui a un index spécifié doit être supprimée. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Compilateurs c# et Visual Basic émettent jamais de code pour utiliser cette méthode, car ils ne prennent pas en charge ce type d’opération. Cette méthode est conçue pour les langages qui prennent en charge la syntaxe pour la suppression d’objets par index, tels que `del sampleObject[1,2]` dans Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur la suppression.</param>
        <summary>Fournit l’implémentation pour les opérations qui suppriment un membre objet. Cette méthode n’est pas conçue pour une utilisation en c# ou Visual Basic.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment un membre d’objet doit être supprimé. Si cette méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Compilateurs c# et Visual Basic émettent jamais de code pour utiliser cette méthode, car ils ne prennent pas en charge ce type d’opération. Cette méthode est conçue pour les langages qui prennent en charge la syntaxe pour la suppression de membres, tels que `del sampleObject.SampleMember` dans Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération.</param>
        <param name="indexes">Les index sont utilisés dans l’opération. Par exemple, pour l’opération <c>sampleObject[3]</c> en C# (<c>sampleObject(3)</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see langword="DynamicObject" />, <c>index[0]</c> est égal à 3.</param>
        <param name="result">Le résultat de l’opération d’index.</param>
        <summary>Fournit l’implémentation pour les opérations qui obtiennent une valeur par index. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations d’indexation.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception au moment de l’exécution est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment l’obtention d’une valeur par index doit être effectuée pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception au moment de l’exécution est levée.)  
  
 Si cette méthode est substituée, elle est automatiquement appelée lorsqu’une opération telle que `sampleObject[3]` en c# ou `sampleObject(3)` en Visual Basic, où `sampleObject` est dérivé le <xref:System.Dynamic.DynamicObject> classe.  
  
   
  
## Examples  
 Supposons que vous souhaitez créer un objet dans lequel les propriétés peuvent être accessibles par des noms tels que `Property0`, `Property1`, et ainsi de suite, ou par index, afin que, par exemple, `sampleObject.Property0` équivaut à `sampleObject[0]` en c# ou `sampleObject(0)` en Visual Basic.  
  
 L’exemple de code suivant montre le `SampleDynamicObject` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. Le `SampleDynamicObject` classe contient un objet de la `Dictionary<string, object>` type (`Dictionary(Of String, Object)` en Visual Basic) pour stocker les paires clé-valeur. `SampleDynamicObject` remplace le <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> et <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> méthodes pour activer l’accès par index. Ce paramètre remplace le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour activer l’accès par nom de propriété.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’objet qui a appelé l’opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre sur lequel l’opération dynamique est exécutée. Par exemple, pour l’instruction <c>console.WriteLine(sampleObject.SampleProperty)</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleProperty ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
        <param name="result">Le résultat de l’opération get. Par exemple, si la méthode est appelée pour une propriété, vous pouvez affecter la valeur de propriété à <paramref name="result" />.</param>
        <summary>Fournit l’implémentation pour les opérations qui obtiennent des valeurs membres. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations telles que l’obtention d’une valeur pour une propriété.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception au moment de l’exécution est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment les opérations qui obtiennent des valeurs de membre doivent être exécutées pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception au moment de l’exécution est levée.)  
  
 Cette méthode est appelée lorsque vous avez des instructions telles que `Console.WriteLine(sampleObject.SampleProperty)`, où `sampleObject` est une instance de la classe dérivée de la <xref:System.Dynamic.DynamicObject> classe.  
  
 Vous pouvez également ajouter vos propres membres aux classes dérivées de la `DynamicObject` classe. Si votre classe définit des propriétés et substitue la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (méthode), le dynamic language runtime (DLR) utilise d’abord le classeur de langage pour rechercher une définition statique d’une propriété dans la classe. S’il n’existe pas de propriété, le DLR appelle le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (méthode).  
  
   
  
## Examples  
 Supposons que vous voulez fournir une autre syntaxe pour accéder aux valeurs dans un dictionnaire, ainsi que, au lieu de la rédaction de `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), vous pouvez écrire `sampleDictionary.Text = "Sample text"`. En outre, cette syntaxe doit être la casse, afin que `sampleDictionary.Text` équivaut à `sampleDictionary.text`.  
  
 L’exemple de code suivant montre le `DynamicDictionary` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. Le `DynamicDictionary` classe contient un objet de la `Dictionary<string, object>` type (`Dictionary(Of String, Object)` en Visual Basic) pour stocker les paires clé-valeur et les remplacements le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour prendre en charge la nouvelle syntaxe. Il fournit également un `Count` contient de la propriété, qui affiche le nombre de propriétés dynamique du dictionnaire.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération d’appel.</param>
        <param name="args">Les arguments qui sont passés à l’objet pendant l’opération d’appel. Par exemple, pour l’opération <c>sampleObject[100]</c>, où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
        <param name="result">Le résultat de l’appel de l’objet.</param>
        <summary>Fournit l’implémentation pour les opérations qui appellent un objet. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations telles que l’appel d’un objet ou un délégué.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment les opérations qui appellent un objet doivent être exécutées pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception au moment de l’exécution est levée.)  
  
 Si cette méthode est substituée, elle est automatiquement appelée lorsqu’une opération telle que `sampleObject(100)`, où `sampleObject` est dérivé le <xref:System.Dynamic.DynamicObject> classe.  
  
 L’opération d’appel d’un objet est pris en charge en c#, mais pas dans Visual Basic. Le compilateur Visual Basic n’émet jamais de code pour utiliser cette méthode, et le langage Visual Basic ne prend pas en charge une syntaxe comme `sampleObject(100)`.  
  
   
  
## Examples  
 Supposons que vous avez besoin d’une structure de données pour stocker des représentations textuelles et numériques de nombres. Vous souhaitez être en mesure de spécifier la valeur de chaque propriété individuellement et être en mesure d’initialiser toutes les propriétés dans une instruction unique.  
  
 L’exemple de code suivant montre le `DynamicNumber` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` remplace le <xref:System.Dynamic.DynamicObject.TryInvoke%2A> méthode pour activer l’initialisation de toutes les propriétés en même temps. Il substitue également la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour activer l’accès aux propriétés de l’objet individuel.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre sur lequel l’opération dynamique est exécutée. Par exemple, pour l’instruction <c>sampleObject.SampleMethod(100)</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleMethod ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
        <param name="args">Les arguments passés au membre de l’objet pendant l’opération d’appel. Par exemple, pour l’instruction <c>sampleObject.SampleMethod(100)</c>, où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> est égal à 100.</param>
        <param name="result">Le résultat de l’appel de membre.</param>
        <summary>Fournit l’implémentation pour les opérations qui appellent un membre. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations telles que l’appel d’une méthode.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment les opérations qui appellent un membre d’objet doivent être exécutées pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Si cette méthode est substituée, elle est appelée automatiquement lorsque vous effectuez une opération telle que `sampleObject.SampleMethod(100)`, où `sampleObject` est dérivé le `DynamicObject` classe.  
  
 Vous pouvez également ajouter vos propres méthodes aux classes dérivées de la <xref:System.Dynamic.DynamicObject> classe. Par exemple, si vous remplacez le <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> (méthode), le système de distribution dynamique tente d’abord déterminer si la méthode spécifiée existe dans la classe. S’il ne trouve pas la méthode, il utilise le <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> implémentation.  
  
 Cette méthode ne prend pas en charge `ref` et `out` paramètres. Tous les paramètres dans le `args` tableau sont passés par valeur.  
  
   
  
## Examples  
 Supposons que vous voulez fournir une autre syntaxe pour accéder aux valeurs dans un dictionnaire, ainsi que, au lieu de la rédaction de `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), vous pouvez écrire `sampleDictionary.Text = "Sample text"`. En outre, vous souhaitez être en mesure d’appeler toutes les méthodes de dictionnaire standard sur ce dictionnaire.  
  
 L’exemple de code suivant montre le `DynamicDictionary` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. Le `DynamicDictionary` classe contient un objet de la `Dictionary<string, object>` type (`Dictionary(Of String, Object)` en Visual Basic) pour stocker les paires clé-valeur. Ce paramètre remplace le <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> méthode pour prendre en charge les méthodes de la <xref:System.Collections.Generic.Dictionary%602> classe et substitue le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour prendre en charge la nouvelle syntaxe. Il fournit également un `Print` (méthode), qui imprime toutes les valeurs et clés de dictionnaire.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération.</param>
        <param name="indexes">Les index sont utilisés dans l’opération. Par exemple, pour l’opération <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>index[0]</c> est égal à 3.</param>
        <param name="value">La valeur à définir pour l’objet qui possède l’index spécifié. Par exemple, pour l’opération <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), où <c>sampleObject</c> est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> est égal à 10.</param>
        <summary>Fournit l’implémentation pour les opérations qui définissent une valeur par index. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations qui accèdent aux objets par un index spécifié.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment les opérations qui accèdent à un objet par index doivent être exécutées pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Si cette méthode est substituée, elle est automatiquement appelée lorsqu’une opération telle que `sampleObject[3] = 10` en c# ou `sampleObject(3) = 10` en Visual Basic, où `sampleObject` est dérivé le <xref:System.Dynamic.DynamicObject> classe.  
  
   
  
## Examples  
 Supposons que vous souhaitez créer un objet dans lequel les propriétés peuvent être accessibles par des noms tels que `Property0`, `Property1`, et ainsi de suite, ou par index, afin que, par exemple, `sampleObject.Property0` équivaut à `sampleObject[0]` en c# ou `sampleObject(0)` en Visual Basic.  
  
 L’exemple de code suivant montre le `SampleDynamicObject` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. Le `SampleDynamicObject` classe contient un objet de la `Dictionary<string, object>` type (`Dictionary(Of String, Object)` en Visual Basic) pour stocker les paires clé-valeur. `SampleDynamicObject` remplace le <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> et <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> méthodes pour activer l’accès par index. Ce paramètre remplace le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour activer l’accès par nom de propriété.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’objet qui a appelé l’opération dynamique. La propriété <c>binder.Name</c> fournit le nom du membre auquel la valeur est attribuée. Par exemple, pour l’instruction <c>sampleObject.SampleProperty = "Test"</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retourne " SampleProperty ". La propriété <c>binder.IgnoreCase</c> spécifie si le nom du membre respecte la casse.</param>
        <param name="value">La valeur à définir pour le membre. Par exemple, pour <c>sampleObject.SampleProperty = "Test"</c>, où <c>sampleObject</c> est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> est " Test ".</param>
        <summary>Fournit l’implémentation pour les opérations qui définissent les valeurs de membre. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations telles que la définition d’une valeur pour une propriété.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment les opérations qui définissent une valeur à un membre doivent être exécutées pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Cette méthode est appelée lorsque vous avez des instructions telles que `sampleObject.SampleProperty = "Test"`, où `sampleObject` est une instance de la classe est dérivée de la <xref:System.Dynamic.DynamicObject> classe.  
  
 Vous pouvez également ajouter vos propres membres aux classes dérivées de la `DynamicObject` classe. Si votre classe définit des propriétés et substitue la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (méthode), le dynamic language runtime (DLR) utilise d’abord le classeur de langage pour rechercher une définition statique d’une propriété dans la classe. S’il n’existe pas de propriété, le DLR appelle le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> (méthode).  
  
   
  
## Examples  
 Supposons que vous voulez fournir une autre syntaxe pour accéder aux valeurs dans un dictionnaire, ainsi que, au lieu de la rédaction de `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), vous pouvez écrire `sampleDictionary.Text = "Sample text"`. En outre, cette syntaxe doit être la casse, afin que `sampleDictionary.Text` équivaut à `sampleDictionary.text`.  
  
 L’exemple de code suivant montre le `DynamicDictionary` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. Le `DynamicDictionary` classe contient un objet de la `Dictionary<string, object>` type (`Dictionary(Of String, Object)` en Visual Basic) pour stocker les paires clé-valeur et les remplacements le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour prendre en charge la nouvelle syntaxe. Il fournit également un `Count` contient de la propriété, qui affiche le nombre de propriétés dynamique du dictionnaire.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fournit des informations sur l’opération unaire. La propriété <c>binder.Operation</c> retourne un objet <see cref="T:System.Linq.Expressions.ExpressionType" />. Par exemple, pour l’instruction <c>negativeNumber = -number</c>, où <c>number</c> est dérivé de la classe <see langword="DynamicObject" />, <c>binder.Operation</c> retourne "Negate".</param>
        <param name="result">Le résultat de l’opération unaire.</param>
        <summary>Fournit l’implémentation pour les opérations unaires. Les classes dérivées de la <see cref="T:System.Dynamic.DynamicObject" /> classe peut substituer cette méthode pour spécifier le comportement dynamique pour les opérations telles que la négation, l’incrémentation ou la décrémentation.</summary>
        <returns><see langword="true" /> si l'opération réussit ; sinon <see langword="false" />. Si cette méthode retourne <see langword="false" />, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées de la <xref:System.Dynamic.DynamicObject> classe peut substituer cette méthode pour spécifier comment les opérations unaires doivent être exécutées pour un objet dynamique. Si la méthode n’est pas substituée, le binder d’exécution du langage détermine le comportement. (Dans la plupart des cas, une exception runtime spécifique au langage est levée.)  
  
 Cette méthode est appelée lorsque les opérations unaires tels que de négation, l’incrémentation ou de décrémentation. Par exemple, si le <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> méthode est substituée, cette méthode est appelée automatiquement pour des instructions comme `negativeNumber = -number`, où `number` est dérivé le <xref:System.Dynamic.DynamicObject> classe.  
  
 Vous pouvez obtenir des informations sur le type de l’opération unaire à l’aide de la `Operation` propriété de le `binder` paramètre.  
  
 Si votre objet dynamique est utilisé uniquement dans c# et Visual Basic, le `binder.Operation` propriété peut avoir l’une des valeurs suivantes à partir de la <xref:System.Linq.Expressions.ExpressionType> énumération. Toutefois, dans d’autres langages tels que IronPython ou IronRuby, vous pouvez avoir d’autres valeurs.
  
|Value|Description|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Une opération de décrémentation unaire.|`a--`|Non pris en charge.|  
|`Increment`|Une opération d’incrémentation unaire.|`a++`|Non pris en charge.|  
|`Negate`|Négation arithmétique.|`-a`|`-a`|  
|`Not`|Négation logique.|`!a`|`Not a`|  
|`OnesComplement`|Un complément.|`~a`|Non pris en charge.|  
|`IsFalse`|Une valeur de condition false.|`a && b`|Non pris en charge.|  
|`IsTrue`|Une valeur de la condition est vraie.|`a &#124;&#124; b`|Non pris en charge.|  
|`UnaryPlus`|Plus unaire.|`+a`|`+a`|  
  
> [!NOTE]
>  Pour implémenter `OrElse` (`a || b`) et `AndAlso` (`a && b`) des opérations pour les objets dynamiques en c#, vous souhaiterez implémenter les deux le <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> (méthode) et le <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> (méthode).  
>   
>  Le `OrElse` opération se compose de l’unaire `IsTrue` opération et le fichier binaire `Or` opération. Le `Or` opération est effectuée uniquement si le résultat de la `IsTrue` opération est `false`.  
>   
>  Le `AndAlso` opération se compose de l’unaire `IsFalse` opération et le fichier binaire `And` opération. Le `And` opération est effectuée uniquement si le résultat de la `IsFalse` opération est `false`.  
  
   
  
## Examples  
 Supposons que vous avez besoin d’une structure de données pour stocker des représentations textuelles et numériques de nombres, et que vous souhaitez définir une opération de négation mathématique pour ces données.  
  
 L’exemple de code suivant montre le `DynamicNumber` (classe), qui est dérivée de la <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` remplace le <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> méthode pour permettre à l’opération de négation mathématique. Est également remplacements le <xref:System.Dynamic.DynamicObject.TrySetMember%2A> et <xref:System.Dynamic.DynamicObject.TryGetMember%2A> méthodes pour activer l’accès aux éléments.  
  
 Dans cet exemple, seule l’opération de négation mathématique est prise en charge. Si vous essayez d’écrire une instruction telle que `negativeNumber = +number`, une exception au moment de l’exécution se produit.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>