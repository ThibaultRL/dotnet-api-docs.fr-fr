<Type Name="WriteableBitmap" FullName="System.Windows.Media.Imaging.WriteableBitmap">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f2ff1cfc560ddf202bdc749e4c3c7495a8e6db78" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65010566" /></Metadata><TypeSignature Language="C#" Value="public sealed class WriteableBitmap : System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WriteableBitmap extends System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Imaging.WriteableBitmap" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WriteableBitmap&#xA;Inherits BitmapSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class WriteableBitmap sealed : System::Windows::Media::Imaging::BitmapSource" />
  <TypeSignature Language="F#" Value="type WriteableBitmap = class&#xA;    inherit BitmapSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Imaging.BitmapSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="4ac61-101">Fournit un <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> qui peuvent être écrits dans et mises à jour.</span><span class="sxs-lookup"><span data-stu-id="4ac61-101">Provides a <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> that can be written to and updated.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-102">Utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap> classe pour mettre à jour et afficher un bitmap sur une base d’image par image.</span><span class="sxs-lookup"><span data-stu-id="4ac61-102">Use the <xref:System.Windows.Media.Imaging.WriteableBitmap> class to update and render a bitmap on a per-frame basis.</span></span> <span data-ttu-id="4ac61-103">Cela est utile pour générer du contenu algorithmique, tel qu’une image fractale et pour la visualisation des données, par exemple un visualiseur de musique.</span><span class="sxs-lookup"><span data-stu-id="4ac61-103">This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.</span></span>  
  
 <span data-ttu-id="4ac61-104">Le <xref:System.Windows.Media.Imaging.WriteableBitmap> classe utilise deux mémoires tampons.</span><span class="sxs-lookup"><span data-stu-id="4ac61-104">The <xref:System.Windows.Media.Imaging.WriteableBitmap> class uses two buffers.</span></span> <span data-ttu-id="4ac61-105">Le *mémoire tampon d’arrière-plan* est alloué dans la mémoire système et accumule le contenu qui n’est pas affichée.</span><span class="sxs-lookup"><span data-stu-id="4ac61-105">The *back buffer* is allocated in system memory and accumulates content that is not currently displayed.</span></span> <span data-ttu-id="4ac61-106">Le *tampon d’affichage* est alloué dans la mémoire système et contient le contenu qui est actuellement affiché.</span><span class="sxs-lookup"><span data-stu-id="4ac61-106">The *front buffer* is allocated in system memory and contains the content that is currently displayed.</span></span> <span data-ttu-id="4ac61-107">Le système de rendu copie le tampon d’affichage vers la mémoire vidéo pour l’affichage.</span><span class="sxs-lookup"><span data-stu-id="4ac61-107">The rendering system copies the front buffer to video memory for display.</span></span>  
  
 <span data-ttu-id="4ac61-108">Deux threads utilisent ces mémoires tampons.</span><span class="sxs-lookup"><span data-stu-id="4ac61-108">Two threads use these buffers.</span></span> <span data-ttu-id="4ac61-109">Le *thread d’interface (UI) utilisateur* génère l’interface utilisateur, mais ne pas présenter à l’écran.</span><span class="sxs-lookup"><span data-stu-id="4ac61-109">The *user interface (UI) thread* generates the UI but does not present it to the screen.</span></span> <span data-ttu-id="4ac61-110">Le thread d’interface utilisateur répond aux entrées d’utilisateur, les minuteurs et les autres événements.</span><span class="sxs-lookup"><span data-stu-id="4ac61-110">The UI thread responds to user input, timers, and other events.</span></span> <span data-ttu-id="4ac61-111">Une application peut avoir plusieurs threads d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="4ac61-111">An application can have multiple UI threads.</span></span> <span data-ttu-id="4ac61-112">Le *thread de rendu* compose et restitue les modifications à partir du thread d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="4ac61-112">The *render thread* composes and renders changes from the UI thread.</span></span> <span data-ttu-id="4ac61-113">Il est thread de rendu qu’une seule par application.</span><span class="sxs-lookup"><span data-stu-id="4ac61-113">There is only one render thread per application.</span></span>  
  
 <span data-ttu-id="4ac61-114">Le thread d’interface utilisateur écrit le contenu de la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-114">The UI thread writes content to the back buffer.</span></span> <span data-ttu-id="4ac61-115">Le thread de rendu lit le contenu du tampon d’affichage et le copie dans la mémoire vidéo.</span><span class="sxs-lookup"><span data-stu-id="4ac61-115">The render thread reads content from the front buffer and copies it to video memory.</span></span> <span data-ttu-id="4ac61-116">Modifications apportées à la mémoire tampon d’arrière-plan sont suivies avec des régions rectangulaires modifiées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-116">Changes to the back buffer are tracked with changed rectangular regions.</span></span>  
  
 <span data-ttu-id="4ac61-117">Appelez une de la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> surcharges pour mettre à jour et afficher automatiquement le contenu dans la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-117">Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically.</span></span>  
  
 <span data-ttu-id="4ac61-118">Pour mieux contrôler les mises à jour et pour l’accès multithread à la mémoire tampon d’arrière-plan, utilisez le workflow suivant.</span><span class="sxs-lookup"><span data-stu-id="4ac61-118">For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.</span></span>  
  
1.  <span data-ttu-id="4ac61-119">Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> méthode pour réserver de la mémoire tampon d’arrière-plan pour les mises à jour.</span><span class="sxs-lookup"><span data-stu-id="4ac61-119">Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates.</span></span>  
  
2.  <span data-ttu-id="4ac61-120">Obtenir un pointeur vers la mémoire tampon d’arrière-plan en accédant à la <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="4ac61-120">Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property.</span></span>  
  
3.  <span data-ttu-id="4ac61-121">Enregistrer les modifications sur la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-121">Write changes to the back buffer.</span></span> <span data-ttu-id="4ac61-122">Autres threads peuvent écrire des modifications à l’arrière de la mémoire tampon lorsque la <xref:System.Windows.Media.Imaging.WriteableBitmap> est verrouillé.</span><span class="sxs-lookup"><span data-stu-id="4ac61-122">Other threads may write changes to the back buffer when the <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked.</span></span>  
  
4.  <span data-ttu-id="4ac61-123">Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode pour indiquer les zones qui ont été modifiés.</span><span class="sxs-lookup"><span data-stu-id="4ac61-123">Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed.</span></span>  
  
5.  <span data-ttu-id="4ac61-124">Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthode pour libérer la mémoire tampon d’arrière-plan et de permettre la présentation à l’écran.</span><span class="sxs-lookup"><span data-stu-id="4ac61-124">Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen.</span></span>  
  
 <span data-ttu-id="4ac61-125">Lorsque les mises à jour sont envoyés au thread de rendu, le thread de rendu copie les rectangles modifiés à partir de la mémoire tampon d’arrière-plan dans le tampon d’affichage.</span><span class="sxs-lookup"><span data-stu-id="4ac61-125">When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer.</span></span> <span data-ttu-id="4ac61-126">Le système de rendu contrôle cet échange pour éviter les interblocages et redessiner les artefacts tels que « déchirement ».</span><span class="sxs-lookup"><span data-stu-id="4ac61-126">The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as "tearing".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ac61-127">L’exemple suivant montre comment un <xref:System.Windows.Media.Imaging.WriteableBitmap> peut être utilisé comme source d’un <xref:System.Windows.Controls.Image> pour dessiner les pixels lorsque la souris se déplace.</span><span class="sxs-lookup"><span data-stu-id="4ac61-127">The following example demonstrates how a <xref:System.Windows.Media.Imaging.WriteableBitmap> can be used as the source of an <xref:System.Windows.Controls.Image> to draw pixels when the mouse moves.</span></span>  
  
 [!code-csharp[WriteableBitmap2#WriteableBitmapFullPage](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#writeablebitmapfullpage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4ac61-128">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-128">Initializes a new instance of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (System.Windows.Media.Imaging.BitmapSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Media.Imaging.BitmapSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (source As BitmapSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(System::Windows::Media::Imaging::BitmapSource ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.Imaging.WriteableBitmap : System.Windows.Media.Imaging.BitmapSource -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="new System.Windows.Media.Imaging.WriteableBitmap source" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Media.Imaging.BitmapSource" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="4ac61-129">Le <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> à utiliser pour l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="4ac61-129">The <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> to use for initialization.</span></span></param>
        <summary><span data-ttu-id="4ac61-130">Initialise une nouvelle instance de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> classe à l’aide de la donnée <see cref="T:System.Windows.Media.Imaging.BitmapSource" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-130">Initializes a new instance of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> class using the given <see cref="T:System.Windows.Media.Imaging.BitmapSource" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-131">Le <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructeur est préféré à l’aide de ce constructeur.</span><span class="sxs-lookup"><span data-stu-id="4ac61-131">The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor.</span></span>  
  
 <span data-ttu-id="4ac61-132">Si `source` n’utilise pas un format bitmap pris en charge en mode natif, format conversions sont appliquées pour chaque mise à jour de frame, ce qui réduit les performances.</span><span class="sxs-lookup"><span data-stu-id="4ac61-132">If `source` does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-133">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-133">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-134">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-134">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-135">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-135">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (int pixelWidth, int pixelHeight, double dpiX, double dpiY, System.Windows.Media.PixelFormat pixelFormat, System.Windows.Media.Imaging.BitmapPalette palette);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 pixelWidth, int32 pixelHeight, float64 dpiX, float64 dpiY, valuetype System.Windows.Media.PixelFormat pixelFormat, class System.Windows.Media.Imaging.BitmapPalette palette) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, System::Windows::Media::PixelFormat pixelFormat, System::Windows::Media::Imaging::BitmapPalette ^ palette);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.Imaging.WriteableBitmap : int * int * double * double * System.Windows.Media.PixelFormat * System.Windows.Media.Imaging.BitmapPalette -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="new System.Windows.Media.Imaging.WriteableBitmap (pixelWidth, pixelHeight, dpiX, dpiY, pixelFormat, palette)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pixelWidth" Type="System.Int32" />
        <Parameter Name="pixelHeight" Type="System.Int32" />
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
        <Parameter Name="pixelFormat" Type="System.Windows.Media.PixelFormat" />
        <Parameter Name="palette" Type="System.Windows.Media.Imaging.BitmapPalette" />
      </Parameters>
      <Docs>
        <param name="pixelWidth"><span data-ttu-id="4ac61-136">La largeur souhaitée de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-136">The desired width of the bitmap.</span></span></param>
        <param name="pixelHeight"><span data-ttu-id="4ac61-137">La hauteur souhaitée de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-137">The desired height of the bitmap.</span></span></param>
        <param name="dpiX"><span data-ttu-id="4ac61-138">Horizontal [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-138">The horizontal [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap.</span></span></param>
        <param name="dpiY"><span data-ttu-id="4ac61-139">Vertical [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-139">The vertical [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap.</span></span></param>
        <param name="pixelFormat"><span data-ttu-id="4ac61-140">Le <see cref="T:System.Windows.Media.PixelFormat" /> de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-140">The <see cref="T:System.Windows.Media.PixelFormat" /> of the bitmap.</span></span></param>
        <param name="palette"><span data-ttu-id="4ac61-141">Le <see cref="T:System.Windows.Media.Imaging.BitmapPalette" /> de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-141">The <see cref="T:System.Windows.Media.Imaging.BitmapPalette" /> of the bitmap.</span></span></param>
        <summary><span data-ttu-id="4ac61-142">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> avec les paramètres spécifiés.</span><span class="sxs-lookup"><span data-stu-id="4ac61-142">Initializes a new instance of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> class with the specified parameters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-143">Les valeurs par défaut pour `pixelFormat` sont <xref:System.Windows.Media.PixelFormats.Bgr32%2A> et <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ac61-143">The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>.</span></span> <span data-ttu-id="4ac61-144">Ces formats sont en mode natif pris en charge et ne nécessitent pas une conversion de format.</span><span class="sxs-lookup"><span data-stu-id="4ac61-144">These formats are natively supported and do not require a format conversion.</span></span> <span data-ttu-id="4ac61-145">Autres `pixelFormat` valeurs requièrent une conversion de format pour chaque mise à jour de frame, ce qui réduit les performances.</span><span class="sxs-lookup"><span data-stu-id="4ac61-145">Other `pixelFormat` values require a format conversion for each frame update, which reduces performance.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-146">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-146">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-147">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-147">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-148">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-148">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberSignature Language="F#" Value="member this.AddDirtyRect : System.Windows.Int32Rect -&gt; unit" Usage="writeableBitmap.AddDirtyRect dirtyRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect"><span data-ttu-id="4ac61-149">Un <see cref="T:System.Windows.Int32Rect" /> représentant la zone qui a changé.</span><span class="sxs-lookup"><span data-stu-id="4ac61-149">An <see cref="T:System.Windows.Int32Rect" /> representing the area that changed.</span></span> <span data-ttu-id="4ac61-150">Les dimensions sont en pixels.</span><span class="sxs-lookup"><span data-stu-id="4ac61-150">Dimensions are in pixels.</span></span></param>
        <summary><span data-ttu-id="4ac61-151">Spécifie la zone de la bitmap qui a changé.</span><span class="sxs-lookup"><span data-stu-id="4ac61-151">Specifies the area of the bitmap that changed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-152">Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode pour indiquer les modifications apportées par votre code à la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-152">Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer.</span></span>  
  
 <span data-ttu-id="4ac61-153">Lorsque vous appelez cette méthode plusieurs fois, les zones modifiées sont accumulées dans une représentation suffisante, mais pas nécessairement minimale.</span><span class="sxs-lookup"><span data-stu-id="4ac61-153">When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation.</span></span> <span data-ttu-id="4ac61-154">Pour plus d’efficacité, uniquement les zones qui sont marquées comme étant modifiées sont garanties à transférer dans le tampon d’affichage.</span><span class="sxs-lookup"><span data-stu-id="4ac61-154">For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer.</span></span> <span data-ttu-id="4ac61-155">Toutefois, toute partie de l’image bitmap peut-être être copiée vers l’avant, vous devez donc vous assurer que la mémoire tampon d’arrière-plan entier est toujours valide.</span><span class="sxs-lookup"><span data-stu-id="4ac61-155">However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.</span></span>  
  
 <span data-ttu-id="4ac61-156">Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode uniquement entre les appels à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthodes, comme décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe.</span><span class="sxs-lookup"><span data-stu-id="4ac61-156">Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ac61-157">L’exemple de code suivant montre comment spécifier la zone de l’arrière-plan de la mémoire tampon qui a changé à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="4ac61-157">The following code example shows how to specify the area of the back buffer that changed by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method.</span></span>  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4ac61-158">L’image bitmap n’a pas été verrouillé par un appel à la <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> ou <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" /> méthodes.</span><span class="sxs-lookup"><span data-stu-id="4ac61-158">The bitmap has not been locked by a call to the <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> or <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" /> methods.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4ac61-159"><paramref name="dirtyRect" /> se situe en dehors des limites de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-159"><paramref name="dirtyRect" /> falls outside the bounds of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-160">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-160">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-161">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-161">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-162">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-162">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BackBuffer">
      <MemberSignature Language="C#" Value="public IntPtr BackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int BackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBuffer As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr BackBuffer { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.BackBuffer : nativeint" Usage="System.Windows.Media.Imaging.WriteableBitmap.BackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4ac61-163">Obtient un pointeur vers la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-163">Gets a pointer to the back buffer.</span></span></summary>
        <value><span data-ttu-id="4ac61-164">Un <see cref="T:System.IntPtr" /> qui pointe vers l’adresse de base de la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-164">An <see cref="T:System.IntPtr" /> that points to the base address of the back buffer.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-165">La mémoire tampon d’arrière-plan contient le contenu de la bitmap dans le format de pixel demandé par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="4ac61-165">The back buffer contains the bitmap contents in the pixel format requested by the user.</span></span>  
  
 <span data-ttu-id="4ac61-166">Mettre à jour de la mémoire tampon d’arrière-plan uniquement entre les appels à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="4ac61-166">Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods.</span></span> <span data-ttu-id="4ac61-167">Si vous ne suivez pas le workflow de verrouillage/déverrouillage décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe, des comportements indéfinis, tels que déchirement, peut se produire.</span><span class="sxs-lookup"><span data-stu-id="4ac61-167">If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.</span></span>  
  
 <span data-ttu-id="4ac61-168">L’adresse de la mémoire tampon d’arrière-plan ne change pas.</span><span class="sxs-lookup"><span data-stu-id="4ac61-168">The address of the back buffer does not change.</span></span>  
  
## <a name="thread-safety"></a><span data-ttu-id="4ac61-169">Sécurité des threads</span><span class="sxs-lookup"><span data-stu-id="4ac61-169">Thread Safety</span></span>  
 <span data-ttu-id="4ac61-170">Vous pouvez passer le <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointeur vers les composants externes et des autres threads pour le traitement, mais si vous le faites, vous devez fournir votre propre coordination de threads.</span><span class="sxs-lookup"><span data-stu-id="4ac61-170">You can pass the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination.</span></span> <span data-ttu-id="4ac61-171">En particulier, vous devez vous assurer que le thread d’interface utilisateur spécifie les zones modifiées en appelant le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> (méthode), et que le thread d’interface utilisateur déverrouille la mémoire tampon en appelant le <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="4ac61-171">In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackBufferStride">
      <MemberSignature Language="C#" Value="public int BackBufferStride { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BackBufferStride" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBufferStride As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BackBufferStride { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BackBufferStride : int" Usage="System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4ac61-172">Obtient une valeur qui indique le nombre d’octets dans une seule ligne de données de pixels.</span><span class="sxs-lookup"><span data-stu-id="4ac61-172">Gets a value indicating the number of bytes in a single row of pixel data.</span></span></summary>
        <value><span data-ttu-id="4ac61-173">Entier indiquant le nombre d’octets dans une seule ligne de données de pixels.</span><span class="sxs-lookup"><span data-stu-id="4ac61-173">An integer indicating the number of bytes in a single row of pixel data.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="writeableBitmap.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4ac61-174">Crée un clone modifiable de ce <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />, en créant des copies complètes des valeurs de cet objet.</span><span class="sxs-lookup"><span data-stu-id="4ac61-174">Creates a modifiable clone of this <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />, making deep copies of this object's values.</span></span> <span data-ttu-id="4ac61-175">Pendant la copie des propriétés de dépendance, cette méthode copie les références de ressources et les liaisons de données (qui risquent toutefois de ne plus pouvoir se résoudre), mais pas les animations ni leurs valeurs actuelles.</span><span class="sxs-lookup"><span data-stu-id="4ac61-175">When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.</span></span></summary>
        <returns><span data-ttu-id="4ac61-176">Clone modifiable de l'objet actif.</span><span class="sxs-lookup"><span data-stu-id="4ac61-176">A modifiable clone of the current object.</span></span> <span data-ttu-id="4ac61-177">La propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l’objet cloné sera <see langword="false" />, même si la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source était <see langword="true." />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-177">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true." /></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-178">Cette méthode est utilisée pour générer des copies modifiables de figé <xref:System.Windows.Freezable> objets (ou n’importe quel <xref:System.Windows.Freezable> objet).</span><span class="sxs-lookup"><span data-stu-id="4ac61-178">This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object).</span></span> <span data-ttu-id="4ac61-179">Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.</span><span class="sxs-lookup"><span data-stu-id="4ac61-179">For convenience, this method shadows the inherited version with a strongly typed implementation.</span></span>  
  
 <span data-ttu-id="4ac61-180">Pour plus d'informations, consultez <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ac61-180">For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="writeableBitmap.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4ac61-181">Crée un clone modifiable de cet objet <see cref="T:System.Windows.Media.Animation.ByteAnimationUsingKeyFrames" />, en effectuant une copie complète des valeurs actuelles de cet objet.</span><span class="sxs-lookup"><span data-stu-id="4ac61-181">Creates a modifiable clone of this <see cref="T:System.Windows.Media.Animation.ByteAnimationUsingKeyFrames" /> object, making deep copies of this object's current values.</span></span> <span data-ttu-id="4ac61-182">Contrairement à leurs valeurs actuelles, les références de ressources, les liaisons de données et les animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-182">Resource references, data bindings, and animations are not copied, but their current values are.</span></span></summary>
        <returns><span data-ttu-id="4ac61-183">Clone modifiable de l'objet actif.</span><span class="sxs-lookup"><span data-stu-id="4ac61-183">A modifiable clone of the current object.</span></span> <span data-ttu-id="4ac61-184">La valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l'objet cloné est <see langword="false" />, même si la valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source était <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-184">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-185">Cette méthode est utilisée pour générer des copies modifiables de figé <xref:System.Windows.Freezable> objets (ou n’importe quel <xref:System.Windows.Freezable> objet).</span><span class="sxs-lookup"><span data-stu-id="4ac61-185">This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object).</span></span> <span data-ttu-id="4ac61-186">Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.</span><span class="sxs-lookup"><span data-stu-id="4ac61-186">For convenience, this method shadows the inherited version with a strongly typed implementation.</span></span>  
  
 <span data-ttu-id="4ac61-187">Pour plus d'informations, consultez <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ac61-187">For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="writeableBitmap.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="writeableBitmap.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberSignature Language="F#" Value="member this.Lock : unit -&gt; unit" Usage="writeableBitmap.Lock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4ac61-188">Réserve la mémoire tampon d’arrière-plan pour les mises à jour.</span><span class="sxs-lookup"><span data-stu-id="4ac61-188">Reserves the back buffer for updates.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-189">Le <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> méthode incrémente le nombre de verrous.</span><span class="sxs-lookup"><span data-stu-id="4ac61-189">The <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method increments the lock count.</span></span> <span data-ttu-id="4ac61-190">Quand un <xref:System.Windows.Media.Imaging.WriteableBitmap> est verrouillé, le système de rendu n’envoie pas de mises à jour jusqu'à ce que le <xref:System.Windows.Media.Imaging.WriteableBitmap> est déverrouillée entièrement par les appels à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="4ac61-190">When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.</span></span>  
  
 <span data-ttu-id="4ac61-191">Vous pouvez utiliser la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> méthode pour prendre en charge des implémentations multithreads.</span><span class="sxs-lookup"><span data-stu-id="4ac61-191">You can use the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to support multi-threaded implementations.</span></span> <span data-ttu-id="4ac61-192">Dans ces scénarios, le thread d’interface utilisateur verrouille la bitmap et expose la mémoire tampon d’arrière-plan à d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="4ac61-192">In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads.</span></span> <span data-ttu-id="4ac61-193">Lorsque le thread de travail a terminé une image, le thread d’interface utilisateur ajoute des rectangles modifiés et déverrouille la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="4ac61-193">When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.</span></span>  
  
 <span data-ttu-id="4ac61-194">Le thread d’interface utilisateur peut bloquer lorsque le thread de rendu acquiert un verrou sur la mémoire tampon d’arrière-plan pour le copier dans le tampon d’affichage.</span><span class="sxs-lookup"><span data-stu-id="4ac61-194">The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer.</span></span> <span data-ttu-id="4ac61-195">Si la latence à partir de ce bloc est trop longue, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> méthode pour attendre pendant une courte période, puis débloquez le thread d’interface utilisateur pour effectuer d’autres tâches pendant que la mémoire tampon d’arrière-plan est verrouillé.</span><span class="sxs-lookup"><span data-stu-id="4ac61-195">If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ac61-196">L’exemple de code suivant montre comment réserver de la mémoire tampon d’arrière-plan à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="4ac61-196">The following code example shows how to reserve the back buffer by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.</span></span>  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberSignature Language="F#" Value="member this.TryLock : System.Windows.Duration -&gt; bool" Usage="writeableBitmap.TryLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="4ac61-197">Un <see cref="T:System.Windows.Duration" /> qui représente la longueur du délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="4ac61-197">A <see cref="T:System.Windows.Duration" /> that represents the length of time to wait.</span></span> <span data-ttu-id="4ac61-198">La valeur 0 retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="4ac61-198">A value of 0 returns immediately.</span></span> <span data-ttu-id="4ac61-199">La valeur <see cref="P:System.Windows.Duration.Forever" /> bloque indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="4ac61-199">A value of <see cref="P:System.Windows.Duration.Forever" /> blocks indefinitely.</span></span></param>
        <summary><span data-ttu-id="4ac61-200">Tente de verrouiller la bitmap, en attente pour n’en avez plus à la longueur spécifiée de temps.</span><span class="sxs-lookup"><span data-stu-id="4ac61-200">Attempts to lock the bitmap, waiting for no longer than the specified length of time.</span></span></summary>
        <returns><span data-ttu-id="4ac61-201"><see langword="true" /> Si le verrou a été acquis ; Sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-201"><see langword="true" /> if the lock was acquired; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-202">Lorsqu’un verrou est acquis, le comportement de la <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> méthode est identique à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="4ac61-202">When a lock is acquired, the behavior of the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4ac61-203"><paramref name="timeout" /> a la valeur <see cref="P:System.Windows.Duration.Automatic" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-203"><paramref name="timeout" /> is set to <see cref="P:System.Windows.Duration.Automatic" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-204">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-204">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-205">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-205">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-206">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-206">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberSignature Language="F#" Value="member this.Unlock : unit -&gt; unit" Usage="writeableBitmap.Unlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4ac61-207">Libère la mémoire tampon d’arrière-plan pour le rendre disponible pour l’affichage.</span><span class="sxs-lookup"><span data-stu-id="4ac61-207">Releases the back buffer to make it available for display.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-208">Le <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthode décrémente le nombre de verrous.</span><span class="sxs-lookup"><span data-stu-id="4ac61-208">The <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method decrements the lock count.</span></span> <span data-ttu-id="4ac61-209">Lorsque le nombre de verrous atteint 0, une passe de rendu est demandée si la <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode a été appelée.</span><span class="sxs-lookup"><span data-stu-id="4ac61-209">When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ac61-210">L’exemple de code suivant montre comment libérer la mémoire tampon d’arrière-plan à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="4ac61-210">The following code example shows how to release the back buffer by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.</span></span>  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4ac61-211">L’image bitmap n’a pas été verrouillé par un appel à la <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> ou <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" /> méthodes.</span><span class="sxs-lookup"><span data-stu-id="4ac61-211">The bitmap has not been locked by a call to the <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> or <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" /> methods.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-212">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-212">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-213">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-213">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-214">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-214">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WritePixels">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4ac61-215">Met à jour les pixels de la bitmap accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="4ac61-215">Updates the pixels of the writeable bitmap.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array pixels, int stride, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array pixels, int32 stride, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, pixels As Array, stride As Integer, offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ pixels, int stride, int offset);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * Array * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, pixels, stride, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="pixels" Type="System.Array" />
        <Parameter Name="stride" Type="System.Int32" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect"><span data-ttu-id="4ac61-216">Le rectangle de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> pour mettre à jour.</span><span class="sxs-lookup"><span data-stu-id="4ac61-216">The rectangle of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> to update.</span></span></param>
        <param name="pixels"><span data-ttu-id="4ac61-217">Le tableau de pixels utilisé pour mettre à jour la bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-217">The pixel array used to update the bitmap.</span></span></param>
        <param name="stride"><span data-ttu-id="4ac61-218">La largeur de numérisation de la région de mise à jour dans <paramref name="pixels" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-218">The stride of the update region in <paramref name="pixels" />.</span></span></param>
        <param name="offset"><span data-ttu-id="4ac61-219">L’offset de mémoire tampon d’entrée.</span><span class="sxs-lookup"><span data-stu-id="4ac61-219">The input buffer offset.</span></span></param>
        <summary><span data-ttu-id="4ac61-220">Met à jour les pixels dans la région spécifiée de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-220">Updates the pixels in the specified region of the bitmap.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-221">Le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> et <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> surcharges sont préférables à l’aide de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="4ac61-221">The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ac61-222">En mode de confiance partielle, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="4ac61-222">In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ac61-223">L’exemple de code suivant montre comment mettre à jour un pixel dans la mémoire tampon d’arrière-plan à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="4ac61-223">The following code example shows how to update a pixel in the back buffer by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method.</span></span>  
  
 [!code-csharp[WriteableBitmap2#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4ac61-224">Un ou plusieurs des conditions suivantes sont true.</span><span class="sxs-lookup"><span data-stu-id="4ac61-224">One or more of the following conditions is true.</span></span>  
  
 <span data-ttu-id="4ac61-225"><paramref name="sourceRect" /> se situe en dehors des limites de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-225"><paramref name="sourceRect" /> falls outside the bounds of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span></span>  
  
 <span data-ttu-id="4ac61-226"><paramref name="stride" /> &lt; 1</span><span class="sxs-lookup"><span data-stu-id="4ac61-226"><paramref name="stride" /> &lt; 1</span></span> 
 <span data-ttu-id="4ac61-227"><paramref name="offset" /> &lt; 0</span><span class="sxs-lookup"><span data-stu-id="4ac61-227"><paramref name="offset" /> &lt; 0</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ac61-228"><paramref name="pixels" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-228"><paramref name="pixels" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ac61-229"><paramref name="pixels" /> a un rang différent de 1 ou 2, ou sa longueur est inférieure ou égale à 0.</span><span class="sxs-lookup"><span data-stu-id="4ac61-229"><paramref name="pixels" /> has a rank other than 1 or 2, or its length is less than or equal to 0.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-230">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-230">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-231">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-231">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-232">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-232">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int buffer, int32 bufferSize, int32 stride) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, buffer As IntPtr, bufferSize As Integer, stride As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * nativeint * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, buffer, bufferSize, stride)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="buffer" Type="System.IntPtr" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="stride" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect"><span data-ttu-id="4ac61-233">Le rectangle de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> pour mettre à jour.</span><span class="sxs-lookup"><span data-stu-id="4ac61-233">The rectangle of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> to update.</span></span></param>
        <param name="buffer"><span data-ttu-id="4ac61-234">La mémoire tampon d’entrée utilisée pour mettre à jour la bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-234">The input buffer used to update the bitmap.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="4ac61-235">La taille de la mémoire tampon d’entrée.</span><span class="sxs-lookup"><span data-stu-id="4ac61-235">The size of the input buffer.</span></span></param>
        <param name="stride"><span data-ttu-id="4ac61-236">La largeur de numérisation de la région de mise à jour dans <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-236">The stride of the update region in <paramref name="buffer" />.</span></span></param>
        <summary><span data-ttu-id="4ac61-237">Met à jour les pixels dans la région spécifiée de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-237">Updates the pixels in the specified region of the bitmap.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-238">Le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> et <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> surcharges sont préférables à l’aide de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="4ac61-238">The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ac61-239">En mode de confiance partielle, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="4ac61-239">In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4ac61-240">Un ou plusieurs des conditions suivantes sont true.</span><span class="sxs-lookup"><span data-stu-id="4ac61-240">One or more of the following conditions is true.</span></span>  
  
 <span data-ttu-id="4ac61-241"><paramref name="sourceRect" /> se situe en dehors des limites de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-241"><paramref name="sourceRect" /> falls outside the bounds of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span></span>  
  
 <span data-ttu-id="4ac61-242"><paramref name="bufferSize" /> &lt; 1</span><span class="sxs-lookup"><span data-stu-id="4ac61-242"><paramref name="bufferSize" /> &lt; 1</span></span> 
 <span data-ttu-id="4ac61-243"><paramref name="stride" /> &lt; 1</span><span class="sxs-lookup"><span data-stu-id="4ac61-243"><paramref name="stride" /> &lt; 1</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ac61-244"><paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-244"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-245">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-245">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-246">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-246">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-247">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-247">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array sourceBuffer, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As Array, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * Array * int * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, sourceBuffer, sourceBufferStride, destinationX, destinationY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.Array" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect"><span data-ttu-id="4ac61-248">Le rectangle dans <paramref name="sourceBuffer" /> à copier.</span><span class="sxs-lookup"><span data-stu-id="4ac61-248">The rectangle in <paramref name="sourceBuffer" /> to copy.</span></span></param>
        <param name="sourceBuffer"><span data-ttu-id="4ac61-249">La mémoire tampon d’entrée utilisée pour mettre à jour la bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-249">The input buffer used to update the bitmap.</span></span></param>
        <param name="sourceBufferStride"><span data-ttu-id="4ac61-250">La largeur de numérisation de la mémoire tampon d’entrée, en octets.</span><span class="sxs-lookup"><span data-stu-id="4ac61-250">The stride of the input buffer, in bytes.</span></span></param>
        <param name="destinationX"><span data-ttu-id="4ac61-251">Coordonnée x de destination du pixel le plus à gauche dans la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-251">The destination x-coordinate of the left-most pixel in the back buffer.</span></span></param>
        <param name="destinationY"><span data-ttu-id="4ac61-252">Coordonnée y de destination du pixel plus haut dans la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-252">The destination y-coordinate of the top-most pixel in the back buffer.</span></span></param>
        <summary><span data-ttu-id="4ac61-253">Met à jour les pixels dans la région spécifiée de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-253">Updates the pixels in the specified region of the bitmap.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-254">Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> méthode pour mettre à jour le <xref:System.Windows.Media.Imaging.WriteableBitmap> automatiquement avec le contenu de `sourceBuffer`.</span><span class="sxs-lookup"><span data-stu-id="4ac61-254">Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`.</span></span> <span data-ttu-id="4ac61-255">Appel de cette méthode est l’équivalent de l’utilisation de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe.</span><span class="sxs-lookup"><span data-stu-id="4ac61-255">Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ac61-256">Utilisez cette surcharge en confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="4ac61-256">Use this overload in partial trust.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4ac61-257">Un ou plusieurs des conditions suivantes sont true.</span><span class="sxs-lookup"><span data-stu-id="4ac61-257">One or more of the following conditions is true.</span></span>  
  
 <span data-ttu-id="4ac61-258"><paramref name="sourceRect" /> se situe en dehors des limites de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-258"><paramref name="sourceRect" /> falls outside the bounds of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span></span>  
  
 <span data-ttu-id="4ac61-259"><paramref name="destinationX" /> ou <paramref name="destinationY" /> est en dehors des limites de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-259"><paramref name="destinationX" /> or <paramref name="destinationY" /> is outside the bounds of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span></span>  
  
 <span data-ttu-id="4ac61-260"><paramref name="sourceBufferStride" /> &lt; 1</span><span class="sxs-lookup"><span data-stu-id="4ac61-260"><paramref name="sourceBufferStride" /> &lt; 1</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ac61-261"><paramref name="sourceBuffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-261"><paramref name="sourceBuffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ac61-262"><paramref name="sourceBuffer" /> a un rang différent de 1 ou 2, ou sa longueur est inférieure ou égale à 0.</span><span class="sxs-lookup"><span data-stu-id="4ac61-262"><paramref name="sourceBuffer" /> has a rank other than 1 or 2, or its length is less than or equal to 0.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-263">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-263">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-264">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-264">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-265">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-265">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int sourceBuffer, int32 sourceBufferSize, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As IntPtr, sourceBufferSize As Integer, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * nativeint * int * int * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, sourceBuffer, sourceBufferSize, sourceBufferStride, destinationX, destinationY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.IntPtr" />
        <Parameter Name="sourceBufferSize" Type="System.Int32" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect"><span data-ttu-id="4ac61-266">Le rectangle dans <paramref name="sourceBuffer" /> à copier.</span><span class="sxs-lookup"><span data-stu-id="4ac61-266">The rectangle in <paramref name="sourceBuffer" /> to copy.</span></span></param>
        <param name="sourceBuffer"><span data-ttu-id="4ac61-267">La mémoire tampon d’entrée utilisée pour mettre à jour la bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-267">The input buffer used to update the bitmap.</span></span></param>
        <param name="sourceBufferSize"><span data-ttu-id="4ac61-268">La taille de la mémoire tampon d’entrée.</span><span class="sxs-lookup"><span data-stu-id="4ac61-268">The size of the input buffer.</span></span></param>
        <param name="sourceBufferStride"><span data-ttu-id="4ac61-269">La largeur de numérisation de la mémoire tampon d’entrée, en octets.</span><span class="sxs-lookup"><span data-stu-id="4ac61-269">The stride of the input buffer, in bytes.</span></span></param>
        <param name="destinationX"><span data-ttu-id="4ac61-270">Coordonnée x de destination du pixel le plus à gauche dans la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-270">The destination x-coordinate of the left-most pixel in the back buffer.</span></span></param>
        <param name="destinationY"><span data-ttu-id="4ac61-271">Coordonnée y de destination du pixel plus haut dans la mémoire tampon d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="4ac61-271">The destination y-coordinate of the top-most pixel in the back buffer.</span></span></param>
        <summary><span data-ttu-id="4ac61-272">Met à jour les pixels dans la région spécifiée de l’image bitmap.</span><span class="sxs-lookup"><span data-stu-id="4ac61-272">Updates the pixels in the specified region of the bitmap.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ac61-273">Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> méthode pour mettre à jour le <xref:System.Windows.Media.Imaging.WriteableBitmap> automatiquement avec le contenu de `sourceBuffer`.</span><span class="sxs-lookup"><span data-stu-id="4ac61-273">Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`.</span></span> <span data-ttu-id="4ac61-274">Appel de cette méthode est l’équivalent de l’utilisation de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe.</span><span class="sxs-lookup"><span data-stu-id="4ac61-274">Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ac61-275">En mode de confiance partielle, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="4ac61-275">In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4ac61-276">Un ou plusieurs des conditions suivantes sont true.</span><span class="sxs-lookup"><span data-stu-id="4ac61-276">One or more of the following conditions is true.</span></span>  
  
 <span data-ttu-id="4ac61-277"><paramref name="sourceRect" /> se situe en dehors des limites de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-277"><paramref name="sourceRect" /> falls outside the bounds of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span></span>  
  
 <span data-ttu-id="4ac61-278"><paramref name="destinationX" /> ou <paramref name="destinationY" /> est en dehors des limites de la <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-278"><paramref name="destinationX" /> or <paramref name="destinationY" /> is outside the bounds of the <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</span></span>  
  
 <span data-ttu-id="4ac61-279"><paramref name="sourceBufferSize" /> &lt; 1</span><span class="sxs-lookup"><span data-stu-id="4ac61-279"><paramref name="sourceBufferSize" /> &lt; 1</span></span> 
 <span data-ttu-id="4ac61-280"><paramref name="sourceBufferStride" /> &lt; 1</span><span class="sxs-lookup"><span data-stu-id="4ac61-280"><paramref name="sourceBufferStride" /> &lt; 1</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ac61-281"><paramref name="sourceBuffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-281"><paramref name="sourceBuffer" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4ac61-282">Pour accéder aux ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="4ac61-282">for access to unmanaged resources.</span></span> <span data-ttu-id="4ac61-283">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="4ac61-283">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span> <span data-ttu-id="4ac61-284">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="4ac61-284">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>