<Type Name="WriteableBitmap" FullName="System.Windows.Media.Imaging.WriteableBitmap">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d713e9fd460f296306d7c34eec1008dc3af2ffb2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55403710" /></Metadata><TypeSignature Language="C#" Value="public sealed class WriteableBitmap : System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WriteableBitmap extends System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Imaging.WriteableBitmap" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WriteableBitmap&#xA;Inherits BitmapSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class WriteableBitmap sealed : System::Windows::Media::Imaging::BitmapSource" />
  <TypeSignature Language="F#" Value="type WriteableBitmap = class&#xA;    inherit BitmapSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Imaging.BitmapSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit une source <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> qui peut être modifiée et mise à jour.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap> classe pour mettre à jour et afficher un bitmap sur une base d’image par image. Cela est utile pour générer du contenu algorithmique, tel qu’une image fractale et pour la visualisation des données, par exemple un visualiseur de musique.  
  
 Le <xref:System.Windows.Media.Imaging.WriteableBitmap> classe utilise deux mémoires tampons. Le *mémoire tampon d’arrière-plan* est alloué dans la mémoire système et accumule le contenu qui n’est pas affichée. Le *tampon d’affichage* est alloué dans la mémoire système et contient le contenu qui est actuellement affiché. Le système de rendu copie le tampon d’affichage vers la mémoire vidéo pour l’affichage.  
  
 Deux threads utilisent ces mémoires tampons. Le *thread d’interface (UI) utilisateur* génère l’interface utilisateur, mais ne pas présenter à l’écran. Le thread d’interface utilisateur répond aux entrées d’utilisateur, les minuteurs et les autres événements. Une application peut avoir plusieurs threads d’interface utilisateur. Le *thread de rendu* compose et restitue les modifications à partir du thread d’interface utilisateur. Il est thread de rendu qu’une seule par application.  
  
 Le thread d’interface utilisateur écrit le contenu de la mémoire tampon d’arrière-plan. Le thread de rendu lit le contenu du tampon d’affichage et le copie dans la mémoire vidéo. Modifications apportées à la mémoire tampon d’arrière-plan sont suivies avec des régions rectangulaires modifiées.  
  
 Appelez une de la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> surcharges pour mettre à jour et afficher automatiquement le contenu dans la mémoire tampon d’arrière-plan.  
  
 Pour mieux contrôler les mises à jour et pour l’accès multithread à la mémoire tampon d’arrière-plan, utilisez le workflow suivant.  
  
1.  Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> méthode pour réserver de la mémoire tampon d’arrière-plan pour les mises à jour.  
  
2.  Obtenir un pointeur vers la mémoire tampon d’arrière-plan en accédant à la <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> propriété.  
  
3.  Enregistrer les modifications sur la mémoire tampon d’arrière-plan. Autres threads peuvent écrire des modifications à l’arrière de la mémoire tampon lorsque la <xref:System.Windows.Media.Imaging.WriteableBitmap> est verrouillé.  
  
4.  Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode pour indiquer les zones qui ont été modifiés.  
  
5.  Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthode pour libérer la mémoire tampon d’arrière-plan et de permettre la présentation à l’écran.  
  
 Lorsque les mises à jour sont envoyés au thread de rendu, le thread de rendu copie les rectangles modifiés à partir de la mémoire tampon d’arrière-plan dans le tampon d’affichage. Le système de rendu contrôle cet échange pour éviter les interblocages et redessiner les artefacts tels que « déchirement ».  
  
   
  
## Examples  
 L’exemple suivant montre comment un <xref:System.Windows.Media.Imaging.WriteableBitmap> peut être utilisé comme source d’un <xref:System.Windows.Controls.Image> pour dessiner les pixels lorsque la souris se déplace.  
  
 [!code-csharp[WriteableBitmap2#WriteableBitmapFullPage](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#writeablebitmapfullpage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (System.Windows.Media.Imaging.BitmapSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Media.Imaging.BitmapSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (source As BitmapSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(System::Windows::Media::Imaging::BitmapSource ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.Imaging.WriteableBitmap : System.Windows.Media.Imaging.BitmapSource -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="new System.Windows.Media.Imaging.WriteableBitmap source" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Media.Imaging.BitmapSource" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Windows.Media.Imaging.BitmapSource" /> à utiliser pour l'initialisation.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> avec le <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructeur est préféré à l’aide de ce constructeur.  
  
 Si `source` n’utilise pas un format bitmap pris en charge en mode natif, format conversions sont appliquées pour chaque mise à jour de frame, ce qui réduit les performances.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (int pixelWidth, int pixelHeight, double dpiX, double dpiY, System.Windows.Media.PixelFormat pixelFormat, System.Windows.Media.Imaging.BitmapPalette palette);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 pixelWidth, int32 pixelHeight, float64 dpiX, float64 dpiY, valuetype System.Windows.Media.PixelFormat pixelFormat, class System.Windows.Media.Imaging.BitmapPalette palette) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, System::Windows::Media::PixelFormat pixelFormat, System::Windows::Media::Imaging::BitmapPalette ^ palette);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.Imaging.WriteableBitmap : int * int * double * double * System.Windows.Media.PixelFormat * System.Windows.Media.Imaging.BitmapPalette -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="new System.Windows.Media.Imaging.WriteableBitmap (pixelWidth, pixelHeight, dpiX, dpiY, pixelFormat, palette)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pixelWidth" Type="System.Int32" />
        <Parameter Name="pixelHeight" Type="System.Int32" />
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
        <Parameter Name="pixelFormat" Type="System.Windows.Media.PixelFormat" />
        <Parameter Name="palette" Type="System.Windows.Media.Imaging.BitmapPalette" />
      </Parameters>
      <Docs>
        <param name="pixelWidth">Largeur souhaitée de la bitmap.</param>
        <param name="pixelHeight">Hauteur souhaitée de la bitmap.</param>
        <param name="dpiX">[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] horizontal de la bitmap.</param>
        <param name="dpiY">[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] vertical de la bitmap.</param>
        <param name="pixelFormat"><see cref="T:System.Windows.Media.PixelFormat" /> de la bitmap.</param>
        <param name="palette"><see cref="T:System.Windows.Media.Imaging.BitmapPalette" /> de la bitmap.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> avec les paramètres spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs par défaut pour `pixelFormat` sont <xref:System.Windows.Media.PixelFormats.Bgr32%2A> et <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. Ces formats sont en mode natif pris en charge et ne nécessitent pas une conversion de format. Autres `pixelFormat` valeurs requièrent une conversion de format pour chaque mise à jour de frame, ce qui réduit les performances.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberSignature Language="F#" Value="member this.AddDirtyRect : System.Windows.Int32Rect -&gt; unit" Usage="writeableBitmap.AddDirtyRect dirtyRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect"><see cref="T:System.Windows.Int32Rect" /> représentant la zone qui a été modifiée. Les dimensions sont en pixels.</param>
        <summary>Spécifie la zone de la bitmap qui a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode pour indiquer les modifications apportées par votre code à la mémoire tampon d’arrière-plan.  
  
 Lorsque vous appelez cette méthode plusieurs fois, les zones modifiées sont accumulées dans une représentation suffisante, mais pas nécessairement minimale. Pour plus d’efficacité, uniquement les zones qui sont marquées comme étant modifiées sont garanties à transférer dans le tampon d’affichage. Toutefois, toute partie de l’image bitmap peut-être être copiée vers l’avant, vous devez donc vous assurer que la mémoire tampon d’arrière-plan entier est toujours valide.  
  
 Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode uniquement entre les appels à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthodes, comme décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment spécifier la zone de l’arrière-plan de la mémoire tampon qui a changé à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> (méthode).  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La bitmap n'a pas été verrouillée par un appel à la méthode <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> ou <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dirtyRect" /> est en dehors des limites du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BackBuffer">
      <MemberSignature Language="C#" Value="public IntPtr BackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int BackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBuffer As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr BackBuffer { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.BackBuffer : nativeint" Usage="System.Windows.Media.Imaging.WriteableBitmap.BackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un pointeur vers la mémoire tampon d'arrière-plan.</summary>
        <value><see cref="T:System.IntPtr" /> qui pointe vers l'adresse de base de la mémoire tampon d'arrière-plan.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mémoire tampon d’arrière-plan contient le contenu de la bitmap dans le format de pixel demandé par l’utilisateur.  
  
 Mettre à jour de la mémoire tampon d’arrière-plan uniquement entre les appels à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthodes. Si vous ne suivez pas le workflow de verrouillage/déverrouillage décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe, des comportements indéfinis, tels que déchirement, peut se produire.  
  
 L’adresse de la mémoire tampon d’arrière-plan ne change pas.  
  
## <a name="thread-safety"></a>Sécurité des threads  
 Vous pouvez passer le <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointeur vers les composants externes et des autres threads pour le traitement, mais si vous le faites, vous devez fournir votre propre coordination de threads. En particulier, vous devez vous assurer que le thread d’interface utilisateur spécifie les zones modifiées en appelant le <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> (méthode), et que le thread d’interface utilisateur déverrouille la mémoire tampon en appelant le <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackBufferStride">
      <MemberSignature Language="C#" Value="public int BackBufferStride { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BackBufferStride" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBufferStride As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BackBufferStride { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BackBufferStride : int" Usage="System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant le nombre d'octets d'une ligne unique de données de pixels.</summary>
        <value>Entier indiquant le nombre d'octets d'une ligne unique de données de pixels.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="writeableBitmap.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un clone modifiable de ce <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />, en créant des copies complètes des valeurs de cet objet. Pendant la copie des propriétés de dépendance, cette méthode copie les références de ressources et les liaisons de données (qui risquent toutefois de ne plus pouvoir se résoudre), mais pas les animations ni leurs valeurs actuelles.</summary>
        <returns>Clone modifiable de l'objet actif. La propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l’objet cloné sera <see langword="false" />, même si la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source était <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour générer des copies modifiables de figé <xref:System.Windows.Freezable> objets (ou n’importe quel <xref:System.Windows.Freezable> objet). Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.  
  
 Pour plus d'informations, consultez <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Media.Imaging.WriteableBitmap" Usage="writeableBitmap.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un clone modifiable de cet objet <see cref="T:System.Windows.Media.Animation.ByteAnimationUsingKeyFrames" />, en effectuant une copie complète des valeurs actuelles de cet objet. Contrairement à leurs valeurs actuelles, les références de ressources, les liaisons de données et les animations ne sont pas copiées.</summary>
        <returns>Clone modifiable de l'objet actif. La valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l'objet cloné est <see langword="false" />, même si la valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source était <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour générer des copies modifiables de figé <xref:System.Windows.Freezable> objets (ou n’importe quel <xref:System.Windows.Freezable> objet). Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.  
  
 Pour plus d'informations, consultez <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="writeableBitmap.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="writeableBitmap.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="writeableBitmap.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberSignature Language="F#" Value="member this.Lock : unit -&gt; unit" Usage="writeableBitmap.Lock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réserve la mémoire tampon d'arrière-plan aux mises à jour.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> méthode incrémente le nombre de verrous. Quand un <xref:System.Windows.Media.Imaging.WriteableBitmap> est verrouillé, le système de rendu n’envoie pas de mises à jour jusqu'à ce que le <xref:System.Windows.Media.Imaging.WriteableBitmap> est déverrouillée entièrement par les appels à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> (méthode).  
  
 Vous pouvez utiliser la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> méthode pour prendre en charge des implémentations multithreads. Dans ces scénarios, le thread d’interface utilisateur verrouille la bitmap et expose la mémoire tampon d’arrière-plan à d’autres threads. Lorsque le thread de travail a terminé une image, le thread d’interface utilisateur ajoute des rectangles modifiés et déverrouille la mémoire tampon.  
  
 Le thread d’interface utilisateur peut bloquer lorsque le thread de rendu acquiert un verrou sur la mémoire tampon d’arrière-plan pour le copier dans le tampon d’affichage. Si la latence à partir de ce bloc est trop longue, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> méthode pour attendre pendant une courte période, puis débloquez le thread d’interface utilisateur pour effectuer d’autres tâches pendant que la mémoire tampon d’arrière-plan est verrouillé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment réserver de la mémoire tampon d’arrière-plan à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> (méthode).  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberSignature Language="F#" Value="member this.TryLock : System.Windows.Duration -&gt; bool" Usage="writeableBitmap.TryLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.Windows.Duration" /> qui représente la durée d'attente. Une valeur de 0 entraîne un retour immédiat. La valeur <see cref="P:System.Windows.Duration.Forever" /> entraîne un blocage infini.</param>
        <summary>Tente de verrouiller la bitmap, en attendant la durée spécifié.</summary>
        <returns><see langword="true" /> si le verrou a été acquis ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un verrou est acquis, le comportement de la <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> méthode est identique à la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> a la valeur <see cref="P:System.Windows.Duration.Automatic" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberSignature Language="F#" Value="member this.Unlock : unit -&gt; unit" Usage="writeableBitmap.Unlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère la mémoire tampon d'arrière-plan afin qu'elle soit disponible pour l'affichage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> méthode décrémente le nombre de verrous. Lorsque le nombre de verrous atteint 0, une passe de rendu est demandée si la <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> méthode a été appelée.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment libérer la mémoire tampon d’arrière-plan à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> (méthode).  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La bitmap n'a pas été verrouillée par un appel à la méthode <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" /> ou <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WritePixels">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met à jour les pixels de la bitmap accessible en écriture.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array pixels, int stride, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array pixels, int32 stride, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, pixels As Array, stride As Integer, offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ pixels, int stride, int offset);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * Array * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, pixels, stride, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="pixels" Type="System.Array" />
        <Parameter Name="stride" Type="System.Int32" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Rectangle du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> à mettre à jour.</param>
        <param name="pixels">Tableau de pixels utilisé pour mettre à jour la bitmap.</param>
        <param name="stride">Pas de la région de mise à jour, en <paramref name="pixels" />.</param>
        <param name="offset">Offset de la mémoire tampon d'entrée.</param>
        <summary>Met à jour les pixels dans la zone spécifiée pour la bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> et <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> surcharges sont préférables à l’aide de cette méthode.  
  
> [!NOTE]
>  En mode de confiance partielle, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de surcharge.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment mettre à jour un pixel dans la mémoire tampon d’arrière-plan à l’aide de la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> (méthode).  
  
 [!code-csharp[WriteableBitmap2#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une ou plusieurs des conditions suivantes sont vraies.  
  
 <paramref name="sourceRect" /> est en dehors des limites du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="stride" /> &lt; 1 
 <paramref name="offset" /> &lt; 0</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pixels" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le rang de <paramref name="pixels" /> est différent de 1 ou 2 ou sa longueur est inférieure ou égale à 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int buffer, int32 bufferSize, int32 stride) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, buffer As IntPtr, bufferSize As Integer, stride As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * nativeint * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, buffer, bufferSize, stride)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="buffer" Type="System.IntPtr" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="stride" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Rectangle du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" /> à mettre à jour.</param>
        <param name="buffer">Mémoire tampon d'entrée utilisée pour mettre à jour la bitmap.</param>
        <param name="bufferSize">Taille de la mémoire tampon d'entrée.</param>
        <param name="stride">Pas de la région de mise à jour, en <paramref name="buffer" />.</param>
        <summary>Met à jour les pixels dans la zone spécifiée pour la bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> et <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> surcharges sont préférables à l’aide de cette méthode.  
  
> [!NOTE]
>  En mode de confiance partielle, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une ou plusieurs des conditions suivantes sont vraies.  
  
 <paramref name="sourceRect" /> est en dehors des limites du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="bufferSize" /> &lt; 1 
 <paramref name="stride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array sourceBuffer, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As Array, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * Array * int * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, sourceBuffer, sourceBufferStride, destinationX, destinationY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.Array" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Rectangle dans <paramref name="sourceBuffer" /> à copier.</param>
        <param name="sourceBuffer">Mémoire tampon d'entrée utilisée pour mettre à jour la bitmap.</param>
        <param name="sourceBufferStride">Pas de la mémoire tampon d'entrée, en octets.</param>
        <param name="destinationX">Coordonnée x de destination du pixel le plus à gauche dans la mémoire tampon d'arrière-plan.</param>
        <param name="destinationY">Coordonnée y de destination du pixel le plus haut dans la mémoire tampon d'arrière-plan.</param>
        <summary>Met à jour les pixels dans la zone spécifiée pour la bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> méthode pour mettre à jour le <xref:System.Windows.Media.Imaging.WriteableBitmap> automatiquement avec le contenu de `sourceBuffer`. Appel de cette méthode est l’équivalent de l’utilisation de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe.  
  
> [!NOTE]
>  Utilisez cette surcharge en confiance partielle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une ou plusieurs des conditions suivantes sont vraies.  
  
 <paramref name="sourceRect" /> est en dehors des limites du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" /> ou <paramref name="destinationY" /> est en dehors des limites du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceBuffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le rang de <paramref name="sourceBuffer" /> est différent de 1 ou 2 ou sa longueur est inférieure ou égale à 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int sourceBuffer, int32 sourceBufferSize, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As IntPtr, sourceBufferSize As Integer, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="F#" Value="member this.WritePixels : System.Windows.Int32Rect * nativeint * int * int * int * int -&gt; unit" Usage="writeableBitmap.WritePixels (sourceRect, sourceBuffer, sourceBufferSize, sourceBufferStride, destinationX, destinationY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.IntPtr" />
        <Parameter Name="sourceBufferSize" Type="System.Int32" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Rectangle dans <paramref name="sourceBuffer" /> à copier.</param>
        <param name="sourceBuffer">Mémoire tampon d'entrée utilisée pour mettre à jour la bitmap.</param>
        <param name="sourceBufferSize">Taille de la mémoire tampon d'entrée.</param>
        <param name="sourceBufferStride">Pas de la mémoire tampon d'entrée, en octets.</param>
        <param name="destinationX">Coordonnée x de destination du pixel le plus à gauche dans la mémoire tampon d'arrière-plan.</param>
        <param name="destinationY">Coordonnée y de destination du pixel le plus haut dans la mémoire tampon d'arrière-plan.</param>
        <summary>Met à jour les pixels dans la zone spécifiée pour la bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> méthode pour mettre à jour le <xref:System.Windows.Media.Imaging.WriteableBitmap> automatiquement avec le contenu de `sourceBuffer`. Appel de cette méthode est l’équivalent de l’utilisation de la <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> et <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow décrit dans le <xref:System.Windows.Media.Imaging.WriteableBitmap> notes concernant la classe.  
  
> [!NOTE]
>  En mode de confiance partielle, utilisez la <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une ou plusieurs des conditions suivantes sont vraies.  
  
 <paramref name="sourceRect" /> est en dehors des limites du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" /> ou <paramref name="destinationY" /> est en dehors des limites du <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferSize" /> &lt; 1 
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceBuffer" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder aux ressources non managées. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>