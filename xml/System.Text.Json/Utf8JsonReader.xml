<Type Name="Utf8JsonReader" FullName="System.Text.Json.Utf8JsonReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="36d9e821ddc52d86e50fb6acd5e8b7576271de24" /><Meta Name="ms.sourcegitcommit" Value="e28b7b371ead27d99e20387b8243f09b0cdb9fb3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="04/12/2019" /><Meta Name="ms.locfileid" Value="59541519" /></Metadata><TypeSignature Language="C#" Value="public struct Utf8JsonReader" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Utf8JsonReader extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Utf8JsonReader" />
  <TypeSignature Language="VB.NET" Value="Public Structure Utf8JsonReader" />
  <TypeSignature Language="C++ CLI" Value="public value class Utf8JsonReader" />
  <TypeSignature Language="F#" Value="type Utf8JsonReader = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une API hautes performances pour un accès en transfert seul et en lecture seule au texte JSON encodé en UTF-8.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## Remarks

`Utf8JsonReader` le texte de façon séquentielle avec aucune mise en cache et, par défaut respecte strictement à des processus la [JSON RFC](https://tools.ietf.org/html/rfc8259).

Lorsque `Utf8JsonReader` rencontre JSON non valide, elle lève une <xref:System.Text.Json.JsonReaderException> avec les informations d’erreur de base comme numéro et octet la position de la ligne.
Dans la mesure où ce type est un struct ref, il ne prend directement en charge async. Toutefois, il ne prend en charge la réentrance pour lire des données incomplètes et poursuivez la lecture une fois plus de données sont présentées.
Pour être en mesure de définir la profondeur maximale lors de la lecture ou autoriser ignorant les commentaires, créez une instance de <xref:System.Text.Json.JsonReaderState> et passez-le au lecteur.

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ref System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor([in]valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt;&amp; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte}@,System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ByRef jsonData As ReadOnlySequence(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(System::Buffers::ReadOnlySequence&lt;System::Byte&gt; % jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader :  * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData">Texte JSON encodé en UTF-8 à traiter.</param>
        <param name="isFinalBlock"><see langword="true" /> quand la séquence d’entrée contient la totalité des données à traiter. <see langword="false" /> seulement s’il est connu que l’étendue d’entrée contient des données partielles avec plus de données à suivre.</param>
        <param name="state">Si c’est le premier appel au constructeur, passez à un état par défaut. Sinon, capturez l’état de l’instance précédente du <see cref="T:System.Text.Json.Utf8JsonReader" /> et repassez-le.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.Json.Utf8JsonReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Dans la mesure où ce type est un struct ref, c’est un type de pile uniquement et lui appliquent toutes les limitations de structs par référence.
C’est la raison pourquoi le constructeur accepte un <xref:System.Text.Json.JsonReaderState>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(ReadOnlySpan&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData">Texte JSON encodé en UTF-8 à traiter.</param>
        <param name="isFinalBlock"><see langword="true" /> quand l’étendue d’entrée contient la totalité des données à traiter. <see langword="false" /> seulement s’il est connu que l’étendue d’entrée contient des données partielles avec plus de données à suivre.</param>
        <param name="state">Struct qui contient l’état du lecteur. Lors du premier appel au constructeur, il doit refléter un état par défaut ; sinon, il doit capturer l’état de l’instance précédente du <see cref="T:System.Text.Json.Utf8JsonReader" /> et le repasser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.Json.Utf8JsonReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Dans la mesure où ce type est un struct ref, c’est un type de pile uniquement et lui appliquent toutes les limitations de structs par référence.
C’est la raison pourquoi le constructeur accepte un <xref:System.Text.Json.JsonReaderState>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BytesConsumed">
      <MemberSignature Language="C#" Value="public long BytesConsumed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BytesConsumed" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesConsumed As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long BytesConsumed { long get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesConsumed : int64" Usage="System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre total d’octets consommés par le <see cref="T:System.Text.Json.Utf8JsonReader" /> jusqu’ici pour l’instance actuelle du <see cref="T:System.Text.Json.Utf8JsonReader" /> avec le texte d’entrée encodé en UTF-8 donné.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDepth">
      <MemberSignature Language="C#" Value="public int CurrentDepth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentDepth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDepth : int" Usage="System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la profondeur du jeton actuel.</summary>
        <value>La profondeur du jeton en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Le `CurrentDepth` propriété effectue le suivi de la profondeur récursive des objets imbriqués / tableaux dans le texte JSON traité jusqu'à présent.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentState">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonReaderState CurrentState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonReaderState CurrentState" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentState As JsonReaderState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonReaderState CurrentState { System::Text::Json::JsonReaderState get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentState : System.Text.Json.JsonReaderState" Usage="System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonReaderState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’instantané actuel de l’état du <see cref="T:System.Text.Json.Utf8JsonReader" /> qui doit être capturé par l’appelant et repassé au constructeur <see cref="T:System.Text.Json.Utf8JsonReader" /> avec davantage de données.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Contrairement à la <xref:System.Text.Json.Utf8JsonReader>, qui est un struct par référence, l’état peut survivre au-delà des limites d’async/await, et par conséquent, ce type est nécessaire pour prendre en charge pour la lecture dans plus de données de façon asynchrone avant de continuer avec une nouvelle instance de la <xref:System.Text.Json.Utf8JsonReader>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public bool GetBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetBoolean();" />
      <MemberSignature Language="F#" Value="member this.GetBoolean : unit -&gt; bool" Usage="utf8JsonReader.GetBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source comme <see cref="T:System.Boolean" />.</summary>
        <returns><see langword="true" /> si <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> est <see cref="F:System.Text.Json.JsonTokenType.True" /> ; <see langword="false" /> si <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> est <see cref="F:System.Text.Json.JsonTokenType.False" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas une valeur booléenne (autrement dit, <see cref="F:System.Text.Json.JsonTokenType.True" /> ou <see cref="F:System.Text.Json.JsonTokenType.False" />).</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public decimal GetDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Decimal GetDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Decimal GetDecimal();" />
      <MemberSignature Language="F#" Value="member this.GetDecimal : unit -&gt; decimal" Usage="utf8JsonReader.GetDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Decimal" />.</summary>
        <returns>Valeur du jeton encodé en UTF-8 analysée pour obtenir une valeur <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Le `GetDecimal` méthode lève une exception si l’entier ne peut pas de valeur du jeton encodé en UTF-8 être analysées dans un <xref:System.Decimal> valeur.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">La valeur du jeton JSON représente un nombre inférieur à <see cref="F:System.Decimal.MinValue" /> ou supérieur à <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public double GetDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDouble" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDouble();" />
      <MemberSignature Language="F#" Value="member this.GetDouble : unit -&gt; double" Usage="utf8JsonReader.GetDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Double" />.</summary>
        <returns>Valeur du jeton encodé en UTF-8 analysée pour obtenir une valeur <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Le `GetDouble` méthode lève une exception si l’entier ne peut pas de valeur du jeton encodé en UTF-8 être analysées dans un <xref:System.Double> valeur.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">La valeur du jeton JSON représente un nombre inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public int GetInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetInt32();" />
      <MemberSignature Language="F#" Value="member this.GetInt32 : unit -&gt; int" Usage="utf8JsonReader.GetInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Int32" />.</summary>
        <returns>Valeur du jeton encodé en UTF-8 analysée pour obtenir une valeur <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Le `GetInt32` méthode lève une exception si l’entier ne peut pas de valeur du jeton encodé en UTF-8 être analysées dans un <xref:System.Int32> valeur.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">La valeur du jeton JSON est dans un format numérique incorrect. Par exemple, si elle contient un nombre décimal ou est écrite en notation scientifique.
            
- ou-

La valeur du jeton JSON représente un nombre inférieur à <see cref="F:System.Int32.MinValue" /> ou supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public long GetInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetInt64();" />
      <MemberSignature Language="F#" Value="member this.GetInt64 : unit -&gt; int64" Usage="utf8JsonReader.GetInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Int64" />.</summary>
        <returns>Valeur du jeton encodé en UTF-8 analysée pour obtenir une valeur <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Le `GetInt64` méthode lève une exception si l’entier ne peut pas de valeur du jeton encodé en UTF-8 être analysées dans un <xref:System.Int64> valeur.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">La valeur du jeton JSON est dans un format numérique incorrect. Par exemple, si elle contient un nombre décimal ou est écrite en notation scientifique.
            
- ou-

La valeur du jeton JSON représente un nombre inférieur à <see cref="F:System.Int64.MinValue" /> ou supérieur à <see cref="F:System.Int64.MaxValue" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetSingle">
      <MemberSignature Language="C#" Value="public float GetSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 GetSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSingle" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float GetSingle();" />
      <MemberSignature Language="F#" Value="member this.GetSingle : unit -&gt; single" Usage="utf8JsonReader.GetSingle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Single" />.</summary>
        <returns>Valeur du jeton encodé en UTF-8 analysée pour obtenir une valeur <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Le `GetSingle` méthode lève une exception si l’entier ne peut pas de valeur du jeton encodé en UTF-8 être analysées dans un <xref:System.Single> valeur.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">La valeur du jeton JSON représente un nombre inférieur à <see cref="F:System.Single.MinValue" /> ou supérieur à <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString();" />
      <MemberSignature Language="F#" Value="member this.GetString : unit -&gt; string" Usage="utf8JsonReader.GetString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source, non échappée et transcodée, comme <see cref="T:System.String" />.</summary>
        <returns>Valeur du jeton analysée pour obtenir une valeur <see cref="T:System.String" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas une chaîne (autrement dit, ni <see cref="F:System.Text.Json.JsonTokenType.String" /> ni <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</exception>

-or-

The JSON string contains invalid UTF-8 bytes or invalid UTF-16 surrogates.
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt32">
      <MemberSignature Language="C#" Value="public uint GetUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 GetUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt32 GetUInt32();" />
      <MemberSignature Language="F#" Value="member this.GetUInt32 : unit -&gt; uint32" Usage="utf8JsonReader.GetUInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.UInt32" />.</summary>
        <returns>Valeur du jeton encodé en UTF-8 analysée pour obtenir une valeur <see cref="T:System.UInt32" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">La valeur du jeton JSON est dans un format numérique incorrect. Par exemple, si elle contient un nombre décimal ou est écrite en notation scientifique.
            
- ou-

La valeur du jeton JSON représente un nombre inférieur à <see cref="F:System.UInt32.MinValue" /> ou supérieur à <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt64">
      <MemberSignature Language="C#" Value="public ulong GetUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 GetUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt64 GetUInt64();" />
      <MemberSignature Language="F#" Value="member this.GetUInt64 : unit -&gt; uint64" Usage="utf8JsonReader.GetUInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.UInt64" />.</summary>
        <returns>Valeur du jeton encodé en UTF-8 analysée pour obtenir une valeur <see cref="T:System.UInt64" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">La valeur du jeton JSON est dans un format numérique incorrect. Par exemple, si elle contient un nombre décimal ou est écrite en notation scientifique.
            
- ou-

La valeur du jeton JSON représente un nombre inférieur à <see cref="F:System.UInt64.MinValue" /> ou supérieur à <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="HasValueSequence">
      <MemberSignature Language="C#" Value="public bool HasValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValueSequence As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValueSequence { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValueSequence : bool" Usage="System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique quelle propriété <c>Value</c> utiliser pour obtenir la valeur du jeton.</summary>
        <value><see langword="true" /> Si <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> doit être utilisé pour obtenir la valeur du jeton. <see langword="false" /> Si <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> doit être utilisé à la place.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Si `HasValueSequence` est `false`, <xref:System.Text.Json.Utf8JsonReader.ValueSequence> est vide. Par conséquent, lire la valeur du jeton à l’aide de la <xref:System.Text.Json.Utf8JsonReader.ValueSpan> propriété.

Pour les données d’entrée au sein d’un `ReadOnlySpan<byte>`, cette retourne toujours `false`. Pour les données d’entrée au sein d’un `ReadOnlySequence<byte>`, cela renvoie uniquement les `true` si la valeur du jeton chevauche plus qu’un seul segment et par conséquent, ne peut pas être représentée comme un intervalle.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public SequencePosition Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.SequencePosition Position" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As SequencePosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property SequencePosition Position { SequencePosition get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : SequencePosition" Usage="System.Text.Json.Utf8JsonReader.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SequencePosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la <see cref="T:System.SequencePosition" /> actuelle dans la ReadOnlySequence&lt;byte&gt; de l’entrée encodée en UTF-8 fournie ou la <see cref="T:System.SequencePosition" /> par défaut si le struct <see cref="T:System.Text.Json.Utf8JsonReader" /> a été construit avec un ReadOnlySpan&lt;byte&gt;.</summary>
        <value>Actuel <see cref="T:System.SequencePosition" /> au sein de la fourni encodé UTF-8 d’entrée ReadOnlySequence&lt;octets&gt; ou une valeur par défaut <see cref="T:System.SequencePosition" /> si le <see cref="T:System.Text.Json.Utf8JsonReader" /> struct a été construit avec un ReadOnlySpan&lt;octets&gt;.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Read();" />
      <MemberSignature Language="F#" Value="member this.Read : unit -&gt; bool" Usage="utf8JsonReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le prochain jeton JSON de la source d’entrée.</summary>
        <returns><see langword="true" /> si le jeton a été correctement lu ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonReaderException">Un jeton JSON non valide a été trouvé.
            
ou

La profondeur actuelle dépasse la limite récursive définie par la profondeur maximale.</exception>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonTokenType TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonTokenType TokenType" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenType As JsonTokenType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonTokenType TokenType { System::Text::Json::JsonTokenType get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : System.Text.Json.JsonTokenType" Usage="System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonTokenType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type du dernier jeton JSON traité dans le texte JSON encodé en UTF-8.</summary>
        <value>Le type du dernier jeton JSON traité.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetDecimal">
      <MemberSignature Language="C#" Value="public bool TryGetDecimal (out decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDecimal([out] valuetype System.Decimal&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDecimal(System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDecimal (ByRef value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDecimal([Runtime::InteropServices::Out] System::Decimal % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDecimal :  -&gt; bool" Usage="utf8JsonReader.TryGetDecimal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Quand cette méthode est retournée, contient la valeur analysée.</param>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Decimal" />.</summary>
        <returns><see langword="true" /> si la valeur du jeton encodé en UTF-8 toute entière peut être analysée correctement pour obtenir une valeur <see cref="T:System.Decimal" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDouble">
      <MemberSignature Language="C#" Value="public bool TryGetDouble (out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDouble([out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDouble(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDouble (ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDouble([Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDouble :  -&gt; bool" Usage="utf8JsonReader.TryGetDouble value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Quand cette méthode est retournée, contient la valeur analysée.</param>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Double" />.</summary>
        <returns><see langword="true" /> si la valeur du jeton encodé en UTF-8 toute entière peut être analysée correctement pour obtenir une valeur <see cref="T:System.Double" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt32">
      <MemberSignature Language="C#" Value="public bool TryGetInt32 (out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt32([out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt32(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt32 (ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt32([Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Quand cette méthode est retournée, contient la valeur analysée.</param>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Int32" />.</summary>
        <returns><see langword="true" /> si la valeur du jeton encodé en UTF-8 toute entière peut être analysée correctement pour obtenir une valeur <see cref="T:System.Int32" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt64">
      <MemberSignature Language="C#" Value="public bool TryGetInt64 (out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt64([out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt64(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt64 (ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt64([Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Quand cette méthode est retournée, contient la valeur analysée.</param>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Int64" />.</summary>
        <returns><see langword="true" /> si la valeur du jeton encodé en UTF-8 toute entière peut être analysée correctement pour obtenir une valeur <see cref="T:System.Int64" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSingle">
      <MemberSignature Language="C#" Value="public bool TryGetSingle (out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSingle([out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSingle(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSingle (ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSingle([Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSingle :  -&gt; bool" Usage="utf8JsonReader.TryGetSingle value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Quand cette méthode est retournée, contient la valeur analysée.</param>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.Single" />.</summary>
        <returns><see langword="true" /> si la valeur du jeton encodé en UTF-8 toute entière peut être analysée correctement pour obtenir une valeur <see cref="T:System.Single" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt32">
      <MemberSignature Language="C#" Value="public bool TryGetUInt32 (out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt32([out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt32(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt32 (ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt32([Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Quand cette méthode est retournée, contient la valeur analysée.</param>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.UInt32" />.</summary>
        <returns><see langword="true" /> si la valeur du jeton encodé en UTF-8 toute entière peut être analysée correctement pour obtenir une valeur <see cref="T:System.UInt32" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt64">
      <MemberSignature Language="C#" Value="public bool TryGetUInt64 (out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt64([out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt64(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt64 (ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt64([Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Quand cette méthode est retournée, contient la valeur analysée.</param>
        <summary>Lit la prochaine valeur du jeton JSON de la source et l’analyse pour obtenir une valeur <see cref="T:System.UInt64" />.</summary>
        <returns><see langword="true" /> si la valeur du jeton encodé en UTF-8 toute entière peut être analysée correctement pour obtenir une valeur <see cref="T:System.UInt64" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La valeur du jeton JSON n’est pas un <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="ValueSequence">
      <MemberSignature Language="C#" Value="public System.Buffers.ReadOnlySequence&lt;byte&gt; ValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; ValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSequence As ReadOnlySequence(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Buffers::ReadOnlySequence&lt;System::Byte&gt; ValueSequence { System::Buffers::ReadOnlySequence&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSequence : System.Buffers.ReadOnlySequence&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ReadOnlySequence&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du dernier jeton traité comme section ReadOnlySpan&lt;byte&gt; de la charge utile de l’entrée. Si le texte JSON est fourni dans une ReadOnlySequence&lt;byte&gt; et que la section qui représente la valeur du jeton rentre dans un seul segment, <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> contient la valeur sectionnée dans la mesure où il peut être représenté comme étendue.
Sinon, la <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> contient la valeur du jeton.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks


Si <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> est `false`, `ValueSequence` est vide. Par conséquent, accéder uniquement aux `ValueSequence` si <xref:System.Text.Json.Utf8JsonReader.HasValueSequence" /> est `true`.
Sinon, la valeur du jeton doit être accessible à partir de <xref:System.Text.Json.Utf8JsonReader.ValueSpan>.

 ]]></format>
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSpan">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;byte&gt; ValueSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ValueSpan" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSpan As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;System::Byte&gt; ValueSpan { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSpan : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du dernier jeton traité comme section ReadOnlySpan&lt;byte&gt; de la charge utile de l’entrée. Si le texte JSON est fourni dans une ReadOnlySequence&lt;byte&gt; et que la section qui représente la valeur du jeton rentre dans un seul segment, <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> contient la valeur sectionnée dans la mesure où il peut être représenté comme étendue.
Sinon, la <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> contient la valeur du jeton.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Si <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> est `true`, <xref:System.Text.Json.Utf8JsonReader.ValueSpan> est vide. Par conséquent, accéder uniquement aux `ValueSpan` si <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> est `false`.
Sinon, la valeur du jeton doit être accessible à partir de <xref:System.Text.Json.Utf8JsonReader.ValueSequence>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
