<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="65f1181f97cd95b9b282cdd9ccd9a950ae451cd1" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46656166" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Définit des méthodes pour gérer des scripts clients dans des applications Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager> classe est utilisée pour gérer des scripts clients et les ajouter aux applications Web. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> classe à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la <xref:System.Web.UI.Page> objet.  
  
 Vous pouvez ajouter de manière déclarative un script client à une page Web en incluant le script dans le balisage HTML de la page. Toutefois, il existe des situations lors de l’ajout dynamique de script client est nécessaire. Pour ajouter dynamiquement un script, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> (méthode), le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> (méthode), le <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (méthode), ou le <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> (méthode), en fonction de quand et comment vous souhaitez ajouter le script. Pour plus d’informations, consultez [Comment : ajouter Client Script dynamiquement à ASP.NET Web Pages](http://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 Le <xref:System.Web.UI.ClientScriptManager> classe identifie de façon unique les scripts par une clé <xref:System.String> et un <xref:System.Type>. Scripts avec la même clé et le même type sont considérés comme des doublons. En utilisant le type de script permet d’éviter de confondre des scripts semblables à partir de différents contrôles utilisateur qui peuvent être utilisé dans la page.  
  
 Le <xref:System.Web.UI.ClientScriptManager> classe peut être utilisée pour appeler des rappels de client dans les situations lorsqu’il est recommandé d’exécuter un code serveur à partir du client sans effectuer une publication (postback). Cela est appelé pour effectuer un rappel hors-bande au serveur. Dans un rappel client, une fonction de script client envoie une demande asynchrone à une page Web ASP.NET. La page Web s’exécute une version modifiée de son cycle de vie normal pour traiter le rappel. Utilisez le <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode pour obtenir une référence à une fonction cliente qui, lorsqu’elle est appelée, lance un rappel de client à un événement de serveur. Pour plus d’informations, consultez [implémentant les rappels de Client sans Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Rappels de script ne fonctionnent pas dans les navigateurs plus anciens qui ne prennent pas en charge le modèle DOM (Document Object), et dont ils ont besoin que ECMAScript est activé sur le client. Pour vérifier si le navigateur prend en charge les rappels, utilisez la <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> propriété, qui est accessible via la <xref:System.Web.HttpRequest.Browser%2A> propriété de l’ASP.NET intrinsèque <xref:System.Web.HttpContext.Request%2A> objet.  
  
 Utilisez le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> (méthode) et le <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> méthode pour définir un événement de publication (postback) du client. Ces méthodes permettent aux fonctions de script client, lorsqu’elle est appelée, pour que le serveur de publication sur la page. Un événement de publication (postback) du client est différent à partir d’un rappel de client dans la mesure où la page Web effectue un cycle de vie normal pour traiter l’événement de publication (postback) du client.  
  
> [!NOTE]
>  Si vous utilisez un <xref:System.Web.UI.WebControls.Button> contrôle et le <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propriété est définie sur `false`, vous pouvez ensuite utiliser le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> événement de publication de méthode pour retourner le client le <xref:System.Web.UI.WebControls.Button> contrôle.  
  
 Le <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> propriété de la <xref:System.Web.UI.WebControls.Button> contrôle, <xref:System.Web.UI.WebControls.ImageButton> contrôle, et <xref:System.Web.UI.WebControls.LinkButton> contrôle peut être utilisé pour exécuter le script client.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Deux scripts clients sont définis dans la page : `PopupScript`, qui affiche un message d’alerte lorsque la page est chargée, et `ButtonClickScript`, qui définit un gestionnaire de client pour un bouton HTML `onClick` événement.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="http://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Script client dans les Pages Web ASP.NET</related>
    <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient la référence à une fonction cliente qui, lorsqu'elle est appelée, entraîne un rappel d'un événement serveur par le client.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Serveur <see cref="T:System.Web.UI.Control" /> qui gère le rappel client. Le contrôle doit implémenter l'interface <see cref="T:System.Web.UI.ICallbackEventHandler" /> et fournir une méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argument passé du script client au serveur 
 Méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Nom du gestionnaire d'événements client qui reçoit le résultat de l'événement serveur réussi.</param>
        <param name="context">Le script client qui est évalué sur le client avant l'initialisation du rappel. Le résultat du script est repassé au gestionnaire d'événements client.</param>
        <summary>Obtient la référence à une fonction cliente qui, lorsqu'elle est appelée, entraîne un rappel d'un événement serveur par le client. La fonction cliente de cette méthode surchargée inclut un contrôle, un argument, un script client et un contexte spécifiés.</summary>
        <returns>Nom d'une fonction cliente qui appelle le rappel client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> méthode effectue un rappel hors-bande au serveur qui est une version modifiée du cycle de vie normal d’une page. Pour plus d’informations, consultez [implémentant les rappels de Client sans Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Lorsque le navigateur est Microsoft Internet Explorer (version 5.0 ou version ultérieure), le mécanisme de rappel de script est implémenté via l’objet Microsoft.XmlHttp COM et nécessite que le navigateur soit configuré pour exécuter des contrôles ActiveX. D’autres navigateurs, un XMLHttpRequest à l’aide local modèle DOM du navigateur (Document Object) est utilisé. Pour vérifier si un navigateur prend en charge les rappels de client, utilisez le <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> propriété. Pour vérifier si un navigateur prend en charge XML sur HTTP, utilisez le <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> propriété. Les deux propriétés sont accessibles via le <xref:System.Web.HttpRequest.Browser%2A> propriété de l’ASP.NET intrinsèque <xref:System.Web.HttpContext.Request%2A> objet.  
  
 Le <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> surcharge de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode effectue un rappel de façon synchrone à l’aide de XML sur HTTP. Lors de l’envoi des données de façon synchrone dans un scénario de rappel, les rappels synchrones retournent immédiatement et ne bloquent pas le navigateur. Aucun deux rappels synchrones ne peuvent exécuter simultanément dans le navigateur. Si un deuxième rappel synchrone est déclenché quand un est actuellement en attente, le deuxième annule le premier et retourne uniquement le deuxième rappel.  
  
 Pour envoyer des données en mode asynchrone, utilisez une des surcharges qui acceptent le `useAsync` paramètre, qui est une valeur booléenne valeur contrôler ce comportement. Dans le scénario asynchrone, vous pouvez avoir plusieurs rappels en attente ; Toutefois, l’ordre dans lequel elles retournent n’est pas garanti pour correspondre à l’ordre dans lequel ils ont été lancées.  
  
 En outre, cette surcharge de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode ne spécifie aucune fonction cliente pour gérer le cas d’une condition d’erreur généré par le <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (méthode). Pour spécifier un gestionnaire de rappel d’erreur client, utilisez une des surcharges qui acceptent le `clientErrorCallback` paramètre.  
  
 Le <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> méthode prend une chaîne facultative `argument` paramètre et retourne une chaîne. Pour transmettre ou recevoir plusieurs valeurs, concaténer des valeurs dans l’entrée ou renvoyer de chaîne, respectivement.  
  
> [!NOTE]
>  Évitez d’utiliser l’état d’affichage dans l’implémentation des propriétés de page ou un contrôle qui doivent être mis à jour pendant les opérations de rappel de script. Si les propriétés sont nécessaire pour surmonter les demandes de page, vous pouvez utiliser l’état de session.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser deux surcharges de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode dans un scénario de rappel client qui incrémente des entiers.  
  
 Deux mécanismes de rappel sont affichées ; la différence entre eux est l’utilisation de la `context` paramètre. Un `ReceiveServerData1` fonction de rappel de client est fournie à l’aide de le `context` paramètre. En revanche, le `ReceiveServerData2` fonction de rappel de client est définie dans un `<script>` bloc sur la page. Un <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> méthode est le Gestionnaire de serveur qui incrémente la valeur qui lui est passée et le <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> méthode retourne la valeur incrémentée sous forme de chaîne. Si le <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> méthode retourne une erreur, puis le `ProcessCallBackError` client fonction est appelée.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Web.UI.Control" /> spécifié a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Web.UI.Control" /> spécifié n'implémente pas l'interface <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serveur <see cref="T:System.Web.UI.Control" /> qui gère le rappel client. Le contrôle doit implémenter l'interface <see cref="T:System.Web.UI.ICallbackEventHandler" /> et fournir une méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argument passé du script client au serveur 
 Méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Nom du gestionnaire d'événements client qui reçoit le résultat de l'événement serveur réussi.</param>
        <param name="context">Le script client qui est évalué sur le client avant l'initialisation du rappel. Le résultat du script est repassé au gestionnaire d'événements client.</param>
        <param name="useAsync">
          <see langword="true" /> pour exécuter le rappel de manière asynchrone ; <see langword="false" /> pour l'exécuter de manière synchrone.</param>
        <summary>Obtient la référence à une fonction cliente qui, lorsqu'elle est appelée, entraîne un rappel d'événements serveur par le client. La fonction cliente de cette méthode surchargée inclut un contrôle, un argument, un script client, un contexte et une valeur booléenne spécifiés.</summary>
        <returns>Nom d'une fonction cliente qui appelle le rappel client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode requiert un `useAsync` paramètre, qui vous permet d’effectuer de façon asynchrone le rappel du client en définissant la valeur `true`. Les versions de surcharge de cette méthode qui ne nécessitent pas la `useAsync` paramètre la valeur sur `false` par défaut.  
  
 Pour plus d’informations sur cette méthode, consultez la section Notes pour la surcharge <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Web.UI.Control" /> spécifié a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Web.UI.Control" /> spécifié n'implémente pas l'interface <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Nom d'un <see cref="T:System.Web.UI.Control" /> serveur qui gère le rappel client. Le contrôle doit implémenter l'interface <see cref="T:System.Web.UI.ICallbackEventHandler" /> et fournir une méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argument passé du script client au serveur 
 Méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Nom du gestionnaire d'événements client qui reçoit le résultat de l'événement serveur réussi.</param>
        <param name="context">Le script client qui est évalué sur le client avant l'initialisation du rappel. Le résultat du script est repassé au gestionnaire d'événements client.</param>
        <param name="clientErrorCallback">Nom du gestionnaire d'événements client qui reçoit le résultat lorsqu'une erreur se produit au niveau du gestionnaire d'événements serveur.</param>
        <param name="useAsync">
          <see langword="true" /> pour exécuter le rappel de manière asynchrone ; <see langword="false" /> pour l'exécuter de manière synchrone.</param>
        <summary>Obtient la référence à une fonction cliente qui, lorsqu'elle est appelée, entraîne un rappel d'événements serveur par le client. La fonction cliente de cette méthode surchargée inclut une cible, un argument, un script client, un contexte, un gestionnaire d'erreurs et une valeur booléenne spécifiés.</summary>
        <returns>Nom d'une fonction cliente qui appelle le rappel client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode prend un `target` chaîne de paramètre au lieu d’un <xref:System.Web.UI.Control> paramètre. Utilisez cette surcharge lorsque vous souhaitez que le rappel pour revenir à autre chose qu’une chaîne contenant le <xref:System.Web.UI.Control.UniqueID%2A> du contrôle.  
  
 En outre, cette surcharge de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode requiert un `useAsync` et un `clientErrorCallback` paramètre. Le `useAsync` paramètre vous permet d’effectuer le rappel du client en mode asynchrone en définissant la valeur sur `true`. Les versions de surcharge de cette méthode qui ne nécessitent pas la `useAsync` paramètre la valeur sur `false` par défaut. Le `clientErrorCallback` paramètre vous permet de définir le nom de la fonction cliente qui est appelée si le Gestionnaire de serveur, le <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> méthode, retourne une erreur. Les versions de surcharge de cette méthode qui ne nécessitent pas le `clientErrorCallback` paramètre la valeur sur null.  
  
 Pour plus d’informations sur cette méthode, consultez la section Notes pour la surcharge <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser deux surcharges de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode dans un scénario de rappel client qui incrémente des entiers.  
  
 Deux mécanismes de rappel sont affichées ; la différence entre eux est l’utilisation de la `context` paramètre. Un `ReceiveServerData1` fonction de rappel de client est fournie à l’aide de le `context` paramètre. En revanche, le `ReceiveServerData2` fonction de rappel de client est définie dans un `<script>` bloc sur la page. Un <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> méthode est le Gestionnaire de serveur qui incrémente la valeur qui lui est passée et le <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> méthode retourne la valeur incrémentée sous forme de chaîne. Si le <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> méthode retourne une erreur, puis la fonction cliente `ProcessCallBackError` est appelée.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serveur <see cref="T:System.Web.UI.Control" /> qui gère le rappel client. Le contrôle doit implémenter l'interface <see cref="T:System.Web.UI.ICallbackEventHandler" /> et fournir une méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argument passé du script client à la méthode <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> du serveur.</param>
        <param name="clientCallback">Nom du gestionnaire d'événements client qui reçoit le résultat de l'événement serveur réussi.</param>
        <param name="context">Le script client qui est évalué sur le client avant l'initialisation du rappel. Le résultat du script est repassé au gestionnaire d'événements client.</param>
        <param name="clientErrorCallback">Nom du gestionnaire d'événements client qui reçoit le résultat lorsqu'une erreur se produit au niveau du gestionnaire d'événements serveur.</param>
        <param name="useAsync">
          <see langword="true" /> pour exécuter le rappel de manière asynchrone ; <see langword="false" /> pour l'exécuter de manière synchrone.</param>
        <summary>Obtient la référence à une fonction cliente qui, lorsqu'elle est appelée, entraîne un rappel d'événements serveur par le client. La fonction cliente de cette méthode surchargée inclut un contrôle, un argument, un script client, un contexte, un gestionnaire d'erreurs et une valeur booléenne spécifiés.</summary>
        <returns>Nom d'une fonction cliente qui appelle le rappel client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> méthode requiert un `useAsync` et un `clientErrorCallback` paramètre. Le `useAsync` paramètre vous permet d’effectuer le rappel du client en mode asynchrone en définissant la valeur sur `true`. Les versions de surcharge de cette méthode qui ne nécessitent pas la `useAsync` paramètre la valeur sur `false` par défaut. Le `clientErrorCallback` paramètre vous permet de définir le nom de la fonction cliente qui est appelée si le Gestionnaire de serveur (le <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (méthode)) retourne une erreur. Les versions de surcharge de cette méthode qui ne nécessitent pas le `clientErrorCallback` paramètre la valeur sur null.  
  
 Pour plus d’informations sur cette méthode, consultez la section Notes pour la surcharge <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Web.UI.Control" /> spécifié a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Web.UI.Control" /> spécifié n'implémente pas l'interface <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une référence, avec <see langword="javascript:" /> ajouté en début, pouvant être utilisée dans un événement client pour effectuer une publication sur le serveur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle serveur pour traiter la publication.</param>
        <param name="argument">Paramètre passé au contrôle serveur.</param>
        <summary>Obtient une référence, avec <see langword="javascript:" /> ajouté en début, pouvant être utilisée dans un événement client pour republier sur le serveur pour le contrôle spécifié et avec les arguments d'événement spécifiés.</summary>
        <returns>Chaîne représentant un appel JavaScript à la fonction de publication (postback) qui inclut l'ID du contrôle cible et les arguments d'événement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À l’aide de la <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode requiert le contrôle qui gère la publication (postback) pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface. Pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface pour un <xref:System.Web.UI.Page>, utilisez la directive.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> (méthode). Le contrôle personnalisé, `MyControl`, implémente la <xref:System.Web.UI.IPostBackEventHandler> interface. Un clic sur l’élément d’ancrage HTML sur la page, le <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> méthode du contrôle personnalisé est appelée.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 L’exemple de code suivant a les mêmes fonctionnalités que le précédent, mais au lieu d’un contrôle personnalisé, le <xref:System.Web.UI.Page> la classe implémente le <xref:System.Web.UI.IPostBackEventHandler> interface.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle serveur pour traiter la publication.</param>
        <param name="argument">Paramètre passé au contrôle serveur.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> pour inscrire l'événement de publication en vue de la validation ; <see langword="false" /> pour ne pas inscrire l'événement de publication en vue de la validation.</param>
        <summary>Obtient une référence, avec <see langword="javascript:" /> ajouté en début, pouvant être utilisée dans un événement client pour republier sur le serveur pour le contrôle spécifié avec les arguments d'événement spécifiés et une indication booléenne précisant s'il faut inscrire la publication pour la validation d'événement.</summary>
        <returns>Chaîne représentant un appel JavaScript à la fonction de publication (postback) qui inclut l'ID du contrôle cible et les arguments d'événement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À l’aide de la <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode requiert le contrôle qui gère la publication (postback) pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface. Pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface pour un <xref:System.Web.UI.Page>, utilisez la directive.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une chaîne qui peut être utilisée dans un événement client pour provoquer une publication (postback) sur le serveur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.Web.UI.PostBackOptions" /> qui définit une publication.</param>
        <summary>Retourne une chaîne qui peut être utilisée dans un événement client pour provoquer une publication (postback) sur le serveur. La chaîne de référence est définie par l'instance de <see cref="T:System.Web.UI.PostBackOptions" /> spécifiée.</summary>
        <returns>Chaîne qui, traitée comme un script sur le client, initialise la publication cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface pour un <xref:System.Web.UI.Page>, utilisez la directive.  
  
 Le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode peut être utilisée avec le <xref:System.Web.UI.WebControls.Button> contrôler quand le <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propriété est `false`. Dans ce scénario, le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode retourne la publication cliente événement pour le <xref:System.Web.UI.WebControls.Button> contrôle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <see cref="T:System.Web.UI.PostBackOptions" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> serveur qui traite la publication sur le serveur.</param>
        <param name="argument">Chaîne d'arguments facultative à passer au contrôle qui traite la publication.</param>
        <summary>Retourne une chaîne qui peut être utilisée dans un événement client pour provoquer une publication (postback) sur le serveur. La chaîne de référence est définie par le contrôle spécifié qui gère la publication (postback) et un argument de chaîne d'autres informations d'événement.</summary>
        <returns>Chaîne qui, traitée comme un script sur le client, initialise la publication (postback).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface pour un <xref:System.Web.UI.Page>, utilisez la directive.  
  
 Le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode peut être utilisée avec le <xref:System.Web.UI.WebControls.Button> contrôler quand le <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propriété est `false`. Dans ce scénario, le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode retourne la publication cliente événement pour le <xref:System.Web.UI.WebControls.Button> contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> (méthode). Le contrôle personnalisé, `MyControl`, implémente la <xref:System.Web.UI.IPostBackEventHandler> interface. Lorsque l’utilisateur clique sur le bouton sur la page, le <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> méthode du contrôle personnalisé est appelée.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 L’exemple de code suivant a les mêmes fonctionnalités que le précédent, mais au lieu d’un contrôle personnalisé, le <xref:System.Web.UI.Page> la classe implémente le <xref:System.Web.UI.IPostBackEventHandler> interface.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Web.UI.Control" /> spécifié a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.Web.UI.PostBackOptions" /> qui définit une publication.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> pour inscrire la référence d'événement en vue de la validation ; sinon, <see langword="false" />.</param>
        <summary>Retourne une chaîne qui peut être utilisée dans un événement client pour provoquer une publication (postback) sur le serveur. La chaîne de référence est définie par l'objet <see cref="T:System.Web.UI.PostBackOptions" /> spécifié. Inscrit en option la référence d'événement pour la validation.</summary>
        <returns>Chaîne qui, traitée comme un script sur le client, initialise la publication cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface pour un <xref:System.Web.UI.Page> d’objet, utilisez la directive.  
  
 Le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode peut être utilisée avec le <xref:System.Web.UI.WebControls.Button> contrôler quand le <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propriété est `false`. Dans ce scénario, le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode retourne la publication cliente événement pour le <xref:System.Web.UI.WebControls.Button> contrôle.  
  
 Si `registerForEventValidation` est `true`, le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> les appels de méthode le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> méthode pour inscrire la référence d’événement pour la validation avec un ID de contrôle unique qui représente le contrôle client qui génère l’événement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> serveur qui traite la publication sur le serveur.</param>
        <param name="argument">Chaîne d’arguments facultatifs à passer à <c>control</c>.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> pour inscrire la référence d'événement en vue de la validation ; sinon, <see langword="false" />.</param>
        <summary>Retourne une chaîne à utiliser dans un événement client pour provoquer une publication sur le serveur. La chaîne de référence est définie par le contrôle spécifié qui gère la publication (postback) et un argument de chaîne d'autres informations d'événement. Inscrit en option la référence d'événement pour la validation.</summary>
        <returns>Chaîne qui, traitée comme un script sur le client, initialise la publication (postback).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour implémenter le <xref:System.Web.UI.IPostBackEventHandler> interface pour un <xref:System.Web.UI.Page>, utilisez la directive.  
  
 Le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode peut être utilisée avec le <xref:System.Web.UI.WebControls.Button> contrôler quand le <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> propriété est `false`. Dans ce scénario, le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> méthode retourne la publication cliente événement pour le <xref:System.Web.UI.WebControls.Button> contrôle.  
  
 Si `registerForEventValidation` a la valeur true, le <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> les appels de méthode le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> méthode pour inscrire la référence d’événement pour la validation avec un ID de contrôle unique qui représente le contrôle client qui génère l’événement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Web.UI.Control" /> spécifié a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Rappels de client sans publications (postback) dans les Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Le type de la ressource.</param>
        <param name="resourceName">Nom qualifié complet de la ressource dans l'assembly.</param>
        <summary>Obtient une référence de type URL à une ressource dans un assembly.</summary>
        <returns>Référence de type URL à la ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> méthode retourne une référence URL à une ressource incorporée dans un assembly. La référence retournée n’est pas encodé URL. Ressources peuvent être n’importe quel fichier statique, des images ou des fichiers de script. Vous spécifiez le type en fonction de l’objet qui accédera à la ressource.  
  
 Une ressource Web inscrite avec la page est identifiée par son type et son nom. Qu’une seule ressource avec une paire de nom et un type donné peut être enregistrée avec la page. Tente d’inscrire une ressource qui est déjà inscrit ne crée pas un doublon de la ressource inscrite.  
  
 Le <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> méthode est utilisée conjointement avec la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> méthode pour accéder aux ressources incorporés dans des assemblys. Pour plus d’informations sur l’utilisation des ressources dans les applications, consultez [ASP.NET Web Page Resources Overview](http://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> (méthode). Le *type* dans cet exemple est affectée au type de classe dans l’assembly contenant la ressource. Le `resourceName` paramètre est spécifié avec le chemin d’accès complet à la ressource, qui inclut l’espace de noms par défaut.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 L’exemple de code suivant montre comment appliquer par programmation le <xref:System.Web.UI.WebResourceAttribute> attribut de métadonnées pour marquer l’assembly pour les ressources qui seront traitées. Compilez la classe suivante dans une bibliothèque de classes avec un espace de noms par défaut la valeur `Samples.AspNet.CS.Controls` ou `Samples.AspNet.VB.Controls`, selon le langage que vous utilisez.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Cet exemple nécessite un fichier JavaScript nommé `Script_include.js`. Le fichier .js est une ressource incorporée dans l’assembly qui contient le `ClientScriptResourceLabel` objet. Si vous utilisez Visual Studio], dans la fenêtre Propriétés de projet bibliothèque de classes, définissez **Action de génération** à **ressource incorporée** lorsque le fichier de script est sélectionné. Si vous compilez la bibliothèque en ligne de commande, utilisez le commutateur pour intégrer la ressource.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le nom de la ressource Web est <see langword="null" />.  
  
\- ou - 
La longueur du nom de la ressource Web est de zéro.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="http://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">Vue d’ensemble des ressources de Page Web ASP.NET</related>
        <related type="Article" href="http://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/Resource (incorporer un fichier de ressources dans le fichier de sortie) (Options du compilateur C#)</related>
        <related type="Article" href="http://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le bloc de script client est inscrit avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clé du bloc de script client à rechercher.</param>
        <summary>Détermine si le bloc de script client est inscrit avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide de la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si le bloc de script client est enregistré ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode afin d’éviter l’enregistrement des scripts en double. Cela est particulièrement important si le script nécessite une grande quantité de ressources serveur à créer.  
  
 Un script client est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons.  
  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> méthode appelle la surcharge qui accepte à la fois un `key` et un `type` paramètre avec le type défini comme un <xref:System.Web.UI.Page> objet  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du bloc de script client à rechercher.</param>
        <param name="key">Clé du bloc de script client à rechercher.</param>
        <summary>Détermine si le bloc de script client est inscrit avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'une clé et d'un type.</summary>
        <returns>
          <see langword="true" /> si le bloc de script client est enregistré ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode afin d’éviter l’enregistrement des scripts en double. Cela est particulièrement important si le script nécessite une grande quantité de ressources serveur à créer.  
  
 Un script client est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons. Vous spécifiez le type en fonction de l’objet qui accédera à la ressource. Par exemple, lorsque vous utilisez un `Page` instance pour accéder à la ressource, vous spécifiez le `Page` type.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> (méthode). Notez que, si la logique à vérifier pour le bloc de script client existants ont été supprimée, il ne serait pas deux scripts clients en double dans le code source HTML de la page rendue, car la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode vérifie les doublons. L’avantage de la vérification est de réduire les calculs inutiles.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le type du script client est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le script client Include est inscrit avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clé du script client Include à rechercher.</param>
        <summary>Détermine si le script client Include est inscrit avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide de la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si le script client Include est enregistré ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> méthode afin d’éviter l’enregistrement des scripts en double. Cela est particulièrement important si le script nécessite une grande quantité de ressources serveur à créer.  
  
 Un script client include est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons.  
  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> méthode appelle la surcharge qui accepte à la fois un `key` et un `type` paramètre avec le type défini comme un <xref:System.Web.UI.Page> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du script client Include à rechercher.</param>
        <param name="key">Clé du script client Include à rechercher.</param>
        <summary>Détermine si le script client Include est inscrit avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'une clé et d'un type.</summary>
        <returns>
          <see langword="true" /> si le script client Include est enregistré ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> inclut de la méthode pour éviter d’inscrire le script client en double. Cela est particulièrement important si le script nécessite une grande quantité de ressources serveur à créer.  
  
 Un script client include est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons. Vous spécifiez le type en fonction de l’objet qui accédera à la ressource. Par exemple, lorsque vous utilisez une instance de Page pour accéder à la ressource, vous spécifiez le `Page` type.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> (méthode). Notez que, si la logique à vérifier pour le script client include existant ont été supprimée, il ne serait pas deux scripts clients en double dans le code source HTML de la page rendue, car la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> méthode vérifie les doublons. L’avantage de la vérification est de réduire les calculs inutiles.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Cet exemple nécessite un fichier JavaScript nommé `Script_include.js`, avec le contenu suivant :  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le type du script client Include est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si l'instruction OnSubmit est inscrite avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'instruction OnSubmit à rechercher.</param>
        <summary>Détermine si l'instruction OnSubmit est inscrite avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide de la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si l'instruction OnSubmit est inscrite ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> méthode pour éviter d’inscrire des instructions OnSubmit en double. Cela est particulièrement important si l’instruction nécessite une grande quantité de ressources serveur à créer.  
  
 Une instruction est identifiée par sa clé et son type. Instructions avec la même clé et le même type sont considérés comme des doublons.  
  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> méthode appelle la surcharge qui accepte à la fois un `key` et un `type` paramètre avec le type défini comme un <xref:System.Web.UI.Page> objet  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'instruction OnSubmit à rechercher.</param>
        <param name="key">Clé de l'instruction OnSubmit à rechercher.</param>
        <summary>Détermine si l'instruction OnSubmit est inscrite avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide de la clé et du type spécifiés.</summary>
        <returns>
          <see langword="true" /> si l'instruction OnSubmit est inscrite ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> méthode pour éviter d’inscrire des instructions en double. Cela est particulièrement important si l’instruction nécessite une grande quantité de ressources serveur à créer.  
  
 Une instruction est identifiée par sa clé et son type. Instructions avec la même clé et le même type sont considérés comme des doublons. Vous spécifiez le type en fonction de l’objet qui accédera à la ressource. Par exemple, lorsque vous utilisez un `Page` instance pour accéder à la ressource, vous spécifiez le `Page` type.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> (méthode). Un script nommé `OnSubmitScript` est inscrit avec le <xref:System.Web.UI.Page> afin que lorsque le formulaire de la page est soumis le script est appelé.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le type de l'instruction OnSubmit est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le script de démarrage est inscrit avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clé du script de démarrage à rechercher.</param>
        <summary>Détermine si le script de démarrage est inscrit avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide de la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si le script de démarrage est inscrit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> méthode afin d’éviter l’enregistrement des scripts en double. Cela est particulièrement important si le script nécessite une grande quantité de ressources serveur à créer.  
  
 Un script de démarrage est identifié par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons.  
  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> méthode appelle la surcharge qui accepte les deux une chaîne `key` et un `type` paramètre avec le type défini comme un <xref:System.Web.UI.Page> objet  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du script de démarrage à rechercher.</param>
        <param name="key">Clé du script de démarrage à rechercher.</param>
        <summary>Détermine si le script de démarrage est inscrit avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide de la clé et du type spécifiés.</summary>
        <returns>
          <see langword="true" /> si le script de démarrage est inscrit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler le <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> méthode afin d’éviter l’enregistrement des scripts en double. Cela est particulièrement important si le script nécessite une grande quantité de ressources serveur à créer.  
  
 Un script de démarrage du client est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> (méthode). Notez que, si la logique à vérifier pour le bloc de script de démarrage existantes ont été supprimée, il ne serait pas deux scripts de démarrage en double dans le code source HTML de la page rendue, car la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> méthode vérifie les doublons. L’avantage de la vérification est de réduire les calculs inutiles.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le type du script de démarrage est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nom de tableau à inscrire.</param>
        <param name="arrayValue">Valeur(s) de tableau à inscrire.</param>
        <summary>Inscrit une déclaration de tableau JavaScript avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un nom de tableau et d'une valeur de tableau.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> vérifie l’existence d’un tableau inscrit avec le même nom que le nom spécifié dans le `arrayName` paramètre et, dans l’affirmative, ajoute les valeurs spécifiées dans le `arrayValue` paramètre. Étant donné que le mécanisme de stockage sous-jacent est basé sur un <xref:System.Collections.ArrayList>, les doublons sont autorisés. Si un tableau inscrit avec le même nom que le `arrayName` paramètre n’existe pas, il est créé et les valeurs dans le `arrayValue` paramètre ajouté à ce dernier.  
  
 Si vous souhaitez que les littéraux de chaîne dans le tableau JavaScript résultant, inclure des guillemets simples (') ou des guillemets doubles (\\») dans le `arrayValue` paramètre. La valeur de la `arrayValue` paramètre doit être un seul élément. Si plusieurs valeurs doit être ajouté au tableau, effectuer plusieurs appels à l’aide de la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> et <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> méthodes. L’exemple inscrit un tableau et une valeur masquée et définit le `OnClick` événement d’un `<input>` bouton permettant de calculer la somme des deux valeurs du tableau et la valeur masquée.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> est <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit le script client avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du script client à inscrire.</param>
        <param name="key">Clé du script client à inscrire.</param>
        <param name="script">Littéral du script client à inscrire.</param>
        <summary>Inscrit le script client avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un type, d'une clé et d'un littéral de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script client est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons. Qu’un seul script avec un type donné et une paire de clés peut être inscrit avec la page. Tente d’inscrire un script qui est déjà inscrit ne crée pas un doublon du script.  
  
 Appelez le <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> méthode pour déterminer si un script client avec une paire de clé et le type donné est déjà inscrit et d’éviter toute tentative d’ajouter le script.  
  
 Dans cette surcharge de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> (méthode), vous devez vous assurer que le script fourni dans le `script` paramètre est encapsulé dans un `<script>` bloc d’élément.  
  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode ajoute un bloc de script en haut de la page rendue. Les blocs de script ne sont pas garanti que la sortie dans l’ordre, qu'ils sont inscrits. Si l’ordre des blocs de script est important, utilisez un <xref:System.Text.StringBuilder> pour rassembler les scripts dans une chaîne unique de l’objet et ensuite tous les enregistrer dans un bloc de script client unique.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> (méthode).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Type du script client à inscrire.</param>
        <param name="key">Clé du script client à inscrire.</param>
        <param name="script">Littéral du script client à inscrire.</param>
        <param name="addScriptTags">Valeur Boolean qui indique s'il faut ajouter des balises de script.</param>
        <summary>Inscrit le script client avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un type, d'une clé, d'un littéral de script et d'une valeur Boolean indiquant s'il faut ajouter des balises de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script client est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons. Qu’un seul script avec un type donné et une paire de clés peut être inscrit avec la page. Tente d’inscrire un script qui est déjà inscrit ne crée pas un doublon du script.  
  
 Appelez le <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> méthode pour déterminer si un script client avec une paire de clé et le type donné est déjà inscrit. Cela vous permet d’éviter toute tentative d’ajouter le script.  
  
 Dans cette surcharge de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> (méthode), vous pouvez indiquer si le script fourni dans le `script` paramètre est encapsulé avec un `<script>` bloc d’élément à l’aide de le `addScriptTags` paramètre. Paramètre `addScriptTags` à `true` indique que les balises de script sont ajoutés automatiquement.  
  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode ajoute un bloc de script en haut de la page rendue. Les blocs de script ne sont pas garanti que la sortie dans l’ordre, qu'ils sont inscrits. Si l’ordre des blocs de script est important, utilisez un <xref:System.Text.StringBuilder> pour rassembler les scripts dans une chaîne unique de l’objet et ensuite tous les enregistrer dans un bloc de script client unique.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> (méthode). Notez que le `addScriptTags` paramètre est défini sur `true` le début et la fermeture des balises de script sont donc pas inclus dans le `script` paramètre.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le type du bloc de script client est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit le script client Include avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Clé du script client Include à inscrire.</param>
        <param name="url">URL du script client Include à inscrire.</param>
        <summary>Enregistre le script client avec l'objet <see cref="T:System.Web.UI.Page" />, à l'aide d'une clé et d'une URL, qui active le script à appeler à partir du client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script client include est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons. Qu’un seul script avec un type donné et une paire de clés peut être inscrit avec la page. Tente d’inscrire un script qui est déjà inscrit ne crée pas un doublon du script.  
  
 Appelez le <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> méthode pour déterminer si un script client include avec une clé donnée et paire de type est déjà inscrit et éviter toute tentative d’ajouter le script.  
  
> [!NOTE]
>  Pour résoudre l’URL de client, utilisez le <xref:System.Web.UI.Control.ResolveClientUrl%2A> (méthode). Cette méthode utilise le contexte de l’URL sur laquelle elle est appelée pour résoudre le chemin d’accès.  
  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> méthode appelle la surcharge qui accepte un `key`, un `URL`et un `type` paramètre.  
  
 La méthode ajoute un bloc de script en haut de la page rendue.  
  
   
  
## Examples  
 Pour plus d’informations, notamment la syntaxe, l’utilisation et un exemple, consultez <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du script client Include à inscrire.</param>
        <param name="key">Clé du script client Include à inscrire.</param>
        <param name="url">URL du script client Include à inscrire.</param>
        <summary>Inscrit le script client Include avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un type, d'une clé et d'une URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> méthode prend *clé* et *url* paramètres pour identifier le script, ainsi qu’un `type` inclure de paramètre pour spécifier l’identification du script client. Vous spécifiez le type en fonction de l’objet qui accédera à la ressource. Par exemple, lorsque vous utilisez un `Page` instance pour accéder à la ressource, vous spécifiez le `Page` type.  
  
> [!NOTE]
>  Pour résoudre l’URL de client, utilisez le <xref:System.Web.UI.Control.ResolveClientUrl%2A> (méthode). Cette méthode utilise le contexte de l’URL sur laquelle elle est appelée pour résoudre le chemin d’accès.  
  
 Cette méthode ajoute un bloc de script en haut de la page rendue.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> (méthode). Notez que si la logique à vérifier pour le script client include existant ont été supprimée, il est toujours pas les scripts clients en double dans la page rendue, car la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> méthode vérifie les doublons. L’avantage de la vérification est de réduire les calculs inutiles.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Cet exemple nécessite un fichier JavaScript nommé Script_include.js avec le contenu suivant :  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le type du script client Include est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'URL est <see langword="null" />.  
  
\- ou - 
L'URL est vide.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type de la ressource de script client à inscrire.</param>
        <param name="resourceName">Nom de la ressource de script client à inscrire.</param>
        <summary>Inscrit la ressource de script client avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un type et d'un nom de ressource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> méthode est utilisée lorsque l’accès à des ressources compilées en provenant d’assemblys par le gestionnaire HTTP WebResource.axd. Le <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> méthode inscrit le script avec le <xref:System.Web.UI.Page> de l’objet et empêche les scripts en double. Cette méthode encapsule le contenu de l’URL de ressource avec un `<script>` bloc d’élément.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> (méthode).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 L’exemple de code suivant montre comment appliquer par programmation le <xref:System.Web.UI.WebResourceAttribute> attribut de métadonnées pour marquer l’assembly pour les ressources qui seront traitées.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Cet exemple nécessite un fichier JavaScript nommé `Script_include.js`, avec le contenu suivant :  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Compilez le `Script_include.js` fichier en tant que ressource dans le `Samples.AspNet.CS.Controls` assembly qui contient le `ClientScriptResourceLabel` classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le nom de la ressource cliente est <see langword="null" />.  
  
\- ou - 
La longueur du nom de la ressource cliente est de zéro.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit une paire nom/valeur en tant qu'attribut personnalisé (expando) du contrôle spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">
          <see cref="T:System.Web.UI.Control" /> sur la page qui contient l'attribut personnalisé.</param>
        <param name="attributeName">Nom de l'attribut personnalisé à inscrire.</param>
        <param name="attributeValue">Valeur de l'attribut personnalisé.</param>
        <summary>Inscrit une paire nom/valeur en tant qu'attribut personnalisé (expando) du contrôle spécifié en fonction d'un ID de contrôle, d'un nom d'attribut et d'une valeur d'attribut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> méthode inscrit une paire nom/valeur en tant qu’un attribut personnalisé (expando) spécifié <xref:System.Web.UI.Control>. L’attribut expando est défini dynamiquement à partir de JavaScript pour préserver la compatibilité XHTML pour le balisage du rendu du contrôle. Guillemets et des barres obliques inverses dans les valeurs de l’attribut personnalisé (expando) sont échappés. Si vous ne souhaitez pas échapper les guillemets et les barres obliques inverses, appelez le <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> surcharge de méthode et définissez la `encode` paramètre `false`.  
  
 Si l’attribut expando est introuvable ou le contrôle auquel ajouter l’attribut expando est introuvable, le script client est toujours émis, mais cela n’affectera pas le contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">
          <see cref="T:System.Web.UI.Control" /> sur la page qui contient l'attribut personnalisé.</param>
        <param name="attributeName">Nom de l'attribut personnalisé à inscrire.</param>
        <param name="attributeValue">Valeur de l'attribut personnalisé.</param>
        <param name="encode">Valeur Boolean qui indique s'il faut ou non encoder l'attribut personnalisé à inscrire.</param>
        <summary>Inscrit une paire nom/valeur en tant qu'attribut personnalisé (expando) du contrôle spécifié selon un ID de contrôle, un nom d'attribut, une valeur d'attribut et une valeur Boolean qui indique s'il faut ou non encoder la valeur d'attribut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> méthode inscrit une paire nom/valeur en tant qu’un attribut personnalisé (expando) spécifié <xref:System.Web.UI.Control>. L’attribut expando est défini dynamiquement à partir de JavaScript pour préserver la compatibilité XHTML pour le balisage du rendu du contrôle. Définir le `encode` paramètre `true` si vous devez échapper des guillemets et des barres obliques inverses dans la valeur de votre attribut expando.  
  
 Si l’attribut expando est introuvable ou le contrôle auquel ajouter l’attribut expando est introuvable, le script client est toujours émis, mais cela n’affectera pas le contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Le script client dans la page rendue définit le `title` attribut d’un `<span>` élément.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit une référence d'événement pour la validation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID unique représentant le contrôle client qui génère l'événement.</param>
        <summary>Inscrit une référence d'événement pour la validation avec un ID de contrôle unique qui représente le contrôle client qui génère l'événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations et des exemples, consultez le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> (méthode) et le <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> méthode pour inscrire un rappel pour la validation et comment valider que le rappel provenait de la page.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Objet <see cref="T:System.Web.UI.PostBackOptions" /> qui spécifie la façon dont le code JavaScript client est généré pour initier un événement de publication.</param>
        <summary>Inscrit une référence d'événement pour la validation avec <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations et des exemples, consultez le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID unique représentant le contrôle client qui génère l'événement.</param>
        <param name="argument">Les arguments d'événement sont passés avec l'événement client.</param>
        <summary>Inscrit une référence d'événement pour la validation avec un ID de contrôle unique et des arguments d'événement représentant le contrôle client qui génère l'événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> (méthode) et le <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> méthode pour inscrire un rappel pour la validation et de valider que le rappel provenait de la page. Pour améliorer la validation illustrée dans l’exemple, vous pouvez modifier la validation `argument` paramètre contiennent des informations spécifiques à l’utilisateur comme une identité ou un rôle  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> méthode pour inscrire un rappel pour la validation.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode est appelée avant la méthode <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="http://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Rappel de client avec l’exemple d’implémentation de Validation</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nom du champ masqué à inscrire</param>
        <param name="hiddenFieldInitialValue">Valeur initiale du champ à inscrire.</param>
        <summary>Inscrit une valeur masquée avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> méthode crée une zone masquée `<input>` élément sur la page HTML rendue.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> et <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> méthodes. L’exemple inscrit un tableau et une valeur masquée et définit le `OnClick` événement d’un `<input>` bouton permettant de calculer la somme des deux valeurs du tableau et la valeur masquée.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'instruction OnSubmit à inscrire.</param>
        <param name="key">Clé de l'instruction OnSubmit à inscrire.</param>
        <param name="script">Littéral de script de l'instruction OnSubmit à inscrire.</param>
        <summary>Inscrit une instruction OnSubmit avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un type, d'une clé et d'un littéral de script. L'instruction s'exécute lorsque le <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> est envoyé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instruction OnSubmit est identifiée par sa clé et son type. Instructions avec la même clé et le même type sont considérés comme des doublons. Une seule instruction avec un type donné et une paire de clés peut être inscrits avec la page. Tentative d’inscription d’une instruction qui est déjà inscrit ne crée pas un doublon de l’instruction.  
  
 Appelez le <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> méthode pour déterminer si une instruction OnSubmit est déjà inscrite avec une paire de clé et le type donnée et d’éviter toute tentative d’ajouter le script.  
  
 Le `script` paramètre de la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> méthode peut contenir plusieurs commandes de script tant qu’ils sont correctement délimitées par un point-virgule ( ;).  
  
 Le <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> ajoute un script qui est exécuté avant que la page est envoyée et vous donne la possibilité d’annuler la soumission.  
  
 Pour plus d’informations sur les formulaires HTML et le `OnSubmit` d’attribut, consultez le [site Web du World Wide Web Consortium (W3C)](http://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> (méthode).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit le script de démarrage avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type du script de démarrage à inscrire.</param>
        <param name="key">Clé du script de démarrage à inscrire.</param>
        <param name="script">Littéral du script de démarrage à inscrire.</param>
        <summary>Inscrit le script de démarrage avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un type, d'une clé et d'un littéral de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script client est identifié de manière unique par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons. Qu’un seul script avec un type donné et une paire de clés peut être inscrit avec la page. Tente d’inscrire un script qui est déjà inscrit ne crée pas un doublon du script.  
  
 Appelez le <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> méthode pour déterminer si un script de démarrage avec une paire de clé et le type donné est déjà inscrit et d’éviter toute tentative d’ajouter le script.  
  
 Dans cette surcharge de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (méthode), vous devez vous assurer que le script fourni dans le `script` paramètre est encapsulé avec un `<script>` bloc d’élément.  
  
 Le bloc de script ajouté par le <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> méthode s’exécute lors de la fin du chargement de la page, mais avant de la page <xref:System.Web.UI.Control.OnLoad%2A> événement est déclenché. Les blocs de script ne sont pas garanti que la sortie dans l’ordre, qu'ils sont inscrits. Si l’ordre des blocs de script est important, utilisez un <xref:System.Text.StringBuilder> pour rassembler les scripts dans une chaîne unique de l’objet et ensuite tous les enregistrer dans un bloc de script client unique.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (méthode). Notez que le début et la fermeture des balises de script sont inclus dans le `script` paramètre. Pour que le script d’ajout de balises en fonction d’un paramètre supplémentaire, consultez le <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (méthode).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Type du script de démarrage à inscrire.</param>
        <param name="key">Clé du script de démarrage à inscrire.</param>
        <param name="script">Littéral du script de démarrage à inscrire.</param>
        <param name="addScriptTags">Valeur Boolean qui indique s'il faut ajouter des balises de script.</param>
        <summary>Inscrit le script de démarrage avec l'objet <see cref="T:System.Web.UI.Page" /> à l'aide d'un type, d'une clé, d'un littéral de script et d'une valeur Boolean indiquant s'il faut ajouter des balises de script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script de démarrage est identifié par sa clé et son type. Scripts avec la même clé et le même type sont considérés comme des doublons. Qu’un seul script avec un type donné et une paire de clés peut être inscrit avec la page. Tente d’inscrire un script qui est déjà inscrit ne crée pas un doublon du script.  
  
 Appelez le <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> méthode pour déterminer si un script de démarrage avec une paire de clé et le type donné est déjà inscrit et d’éviter toute tentative d’ajouter le script.  
  
 Dans cette surcharge de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (méthode), vous pouvez indiquer si le script fourni dans le `script` paramètre est encapsulé avec un `<script>` bloc d’élément à l’aide de le `addScriptTags` paramètre. Paramètre `addScriptTags` à `true` indique que les balises de script sont ajoutés automatiquement.  
  
 Le bloc de script ajouté par le <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> méthode s’exécute lors de la fin du chargement de la page, mais avant de la page <xref:System.Web.UI.Control.OnLoad%2A> événement est déclenché. Les blocs de script ne sont pas garanti que la sortie dans l’ordre, qu'ils sont inscrits. Si l’ordre des blocs de script est important, utilisez un <xref:System.Text.StringBuilder> pour rassembler les scripts dans une chaîne unique de l’objet et ensuite tous les enregistrer dans un bloc de script client unique.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (méthode). Notez que le `addScriptTags` paramètre est défini sur `false` par conséquent, le début et la fermeture des balises de script sont inclus avec le `script` paramètre.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Valide un événement client.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID unique représentant le contrôle client qui génère l'événement.</param>
        <summary>Valide un événement client qui a été inscrit pour la validation d'événement à l'aide de la méthode <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID unique représentant le contrôle client qui génère l'événement.</param>
        <param name="argument">Les arguments d'événement passés avec l'événement client.</param>
        <summary>Valide un événement client qui a été inscrit pour la validation d'événement à l'aide de la méthode <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> (méthode) et le <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> méthode pour inscrire un rappel pour la validation et de valider que le rappel provenait de la page. Pour améliorer la validation illustrée ici, vous pouvez modifier la validation `argument` paramètre contiennent des informations spécifiques à l’utilisateur comme une identité ou un rôle  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> ou <see langword="null" /> est une chaîne vide ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>