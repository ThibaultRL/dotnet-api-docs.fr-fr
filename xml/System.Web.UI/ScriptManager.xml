<Type Name="ScriptManager" FullName="System.Web.UI.ScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8b1534efa09fa19430aaa1c97410a4b6882b73ec" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008188" /></Metadata><TypeSignature Language="C#" Value="public class ScriptManager : System.Web.UI.Control, System.Web.UI.IPostBackDataHandler, System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScriptManager extends System.Web.UI.Control implements class System.Web.UI.IPostBackDataHandler, class System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ScriptManager&#xA;Inherits Control&#xA;Implements IPostBackDataHandler, IPostBackEventHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScriptManager : System::Web::UI::Control, System::Web::UI::IPostBackDataHandler, System::Web::UI::IPostBackEventHandler" />
  <TypeSignature Language="F#" Value="type ScriptManager = class&#xA;    inherit Control&#xA;    interface IPostBackDataHandler&#xA;    interface IPostBackEventHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackDataHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackEventHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Scripts")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(EmbeddedResourceFinder), "System.Web.Resources.ScriptManager.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gère des fichiers de script et des bibliothèques de scripts ASP.NET Ajax, le rendu de page partiel et la génération de classe du proxy client pour les services Web et d'application.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette rubrique :  
  
-   [Introduction](#introduction)  
  
-   [Rendu de Page partielle](#partial_page_rendering)  
  
-   [À l’aide du contrôle ScriptManager avec des Pages maîtres, les contrôles utilisateur et les autres composants de l’enfant](#using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components)  
  
-   [L’inscription et la gestion des scripts](#script_management_and_registration)  
  
-   [Références de Service Web](#web_service_references)  
  
-   [Localisation](#localization)  
  
-   [Gestion des erreurs](#error_handling)  
  
-   [Syntaxe déclarative](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>Introduction  
 Le <xref:System.Web.UI.ScriptManager> contrôle est essentiel aux fonctionnalités Ajax dans ASP.NET. Le contrôle gère toutes les ressources ASP.NET Ajax sur une page. Cela inclut le téléchargement des scripts de Microsoft Ajax Library dans le navigateur et de coordonner les mises à jour de page partielle sont activées à l’aide de <xref:System.Web.UI.UpdatePanel> contrôles. En outre, le <xref:System.Web.UI.ScriptManager> contrôle vous permet d’effectuer les opérations suivantes :  
  
-   Enregistrer le script qui est compatible avec les mises à jour de page partielle. Pour gérer les dépendances entre votre script et la bibliothèque principale, tout script inscrit est chargé après le script Microsoft Ajax Library.  
  
-   Spécifiez si la mise en production ou de scripts de débogage sont envoyés au navigateur.  
  
-   Fournir un accès aux méthodes de service Web à partir du script en inscrivant les services Web avec le <xref:System.Web.UI.ScriptManager> contrôle.  
  
-   Fournir un accès à l’authentification ASP.NET, de rôle et de profil des services d’application à partir du script client en inscrivant ces services avec le <xref:System.Web.UI.ScriptManager> contrôle.  
  
-   Activer l’affichage spécifique à la culture d’ECMAScript (JavaScript), et [chaîne](https://msdn.microsoft.com/library/517a1992-3295-484e-9b9c-07ebfd8fe4db) fonctions dans le navigateur.  
  
-   Accéder aux ressources de localisation pour les fichiers de script incorporés ou pour les fichiers de script autonome en utilisant le <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> propriété de la <xref:System.Web.UI.ScriptReference> contrôle.  
  
-   Inscrire des contrôles serveur qui implémentent le <xref:System.Web.UI.IExtenderControl> ou <xref:System.Web.UI.IScriptControl> interagit avec le <xref:System.Web.UI.ScriptManager> contrôler afin que le script requis par les composants clients et les comportements de rendu.  
  
<a name="partial_page_rendering"></a>   
## <a name="partial-page-rendering"></a>Rendu de Page partielle  
 La possibilité d’une page ASP.NET pour prendre en charge le rendu de page partiel est contrôlée par les facteurs suivants :  
  
-   Le <xref:System.Web.UI.ScriptManager> du contrôle <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriété doit être `true` (la valeur par défaut).  
  
-   Il doit y avoir au moins un <xref:System.Web.UI.UpdatePanel> contrôle sur la page.  
  
-   Le <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriété doit être `true` (la valeur par défaut). Si le <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriété n’est pas définie explicitement, sa valeur est basée sur les fonctionnalités du navigateur.  
  
 Vous pouvez remplacer la valeur de la <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriété au moment de l’exécution pendant ou avant de la page <xref:System.Web.UI.Control.Init> événement. Si vous essayez de modifier cette propriété après la page <xref:System.Web.UI.Control.Init> d’événement, un <xref:System.InvalidOperationException> exception est levée.  
  
 Lorsque le rendu de page partielle est prise en charge, le <xref:System.Web.UI.ScriptManager> contrôle restitue le script pour activer des publications asynchrones et des mises à jour de page partielle. Les régions de la page mettre à jour sont désignées à l’aide <xref:System.Web.UI.UpdatePanel> contrôles. Le <xref:System.Web.UI.ScriptManager> contrôle gère les publications (postback) asynchrone et actualise uniquement les zones de la page qui doivent être mis à jour. Pour plus d’informations sur le rendu de page partielle, consultez [vue d’ensemble du rendu de Page partielle](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49). Pour plus d’informations sur les conditions qui entraînent une mise à jour, consultez [vue d’ensemble du contrôle UpdatePanel](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a).  
  
<a name="using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components"></a>   
## <a name="using-the-scriptmanager-control-with-master-pages-user-controls-and-other-child-components"></a>À l’aide du contrôle ScriptManager avec des Pages maîtres, les contrôles utilisateur et les autres composants de l’enfant  
 Une page peut contenir un seul <xref:System.Web.UI.ScriptManager> contrôle dans sa hiérarchie. Pour inscrire des services et des scripts de pages imbriquées, des contrôles utilisateur ou des composants lorsque la page parente a déjà un <xref:System.Web.UI.ScriptManager> contrôler, utilisez le <xref:System.Web.UI.ScriptManagerProxy> contrôle. Pour plus d’informations, consultez [à l’aide du contrôle UpdatePanel avec des Pages maîtres](https://msdn.microsoft.com/library/b1c974d5-a6b2-4bb3-a3cc-61dd9dc0e1d6)  
  
<a name="script_management_and_registration"></a>   
## <a name="script-management-and-registration"></a>L’inscription et la gestion des scripts  
 Le <xref:System.Web.UI.ScriptManager> contrôle vous permet d’inscrire un script qui est ensuite rendu dans le cadre de la page. Le <xref:System.Web.UI.ScriptManager> contrôle les méthodes d’inscription peuvent être divisés en trois catégories suivantes :  
  
-   Méthodes d’inscription qui garantissent que les dépendances de script de Microsoft Ajax Library sont conservées.  
  
-   Les méthodes d’inscription qui ne sont pas dépendantes de Microsoft Ajax Library, mais qui sont compatibles avec <xref:System.Web.UI.UpdatePanel> contrôles.  
  
-   Les méthodes d’inscription qui prennent en charge fonctionne avec <xref:System.Web.UI.UpdatePanel> contrôles.  
  
 Pour plus d’informations sur comment créer et utiliser un script Ajax dans ASP.NET, consultez [création de Script Client personnalisé à l’aide de Microsoft Ajax Library](https://msdn.microsoft.com/library/285e3a65-b42e-42c5-952d-baf184057899).  
  
### <a name="registering-script-that-is-dependent-on-the-microsoft-ajax-library"></a>Inscrire un Script qui dépend de la bibliothèque Microsoft Ajax  
 Vous pouvez utiliser les méthodes suivantes pour inscrire des fichiers de script d’une façon qui garantit que toutes les dépendances de Microsoft Ajax Library sont conservées.  
  
|Méthode|Définition|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>|Inscrit un contrôle serveur qui implémente le <xref:System.Web.UI.IScriptControl> interface qui permet de définir un [Sys.Component](https://msdn.microsoft.com/library/6fba3595-e425-4e48-b4e9-fc16a0272381) objet client. Le <xref:System.Web.UI.ScriptManager> contrôle restitue le script qui prend en charge l’objet client.|  
|<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>|Inscrit un contrôle serveur qui implémente le <xref:System.Web.UI.IExtenderControl> interface qui permet de définir un [Sys.Component](https://msdn.microsoft.com/library/6fba3595-e425-4e48-b4e9-fc16a0272381) objet client. Le <xref:System.Web.UI.ScriptManager> contrôle restitue le script qui prend en charge l’objet client.|  
  
### <a name="registering-partial-page-update-compatible-scripts"></a>L’inscription de Scripts compatibles avec la mise à jour de Page partielle  
 Vous pouvez utiliser les méthodes suivantes pour inscrire des fichiers de script qui ne sont pas dépendantes de Microsoft Ajax Library, mais qui sont compatibles avec <xref:System.Web.UI.UpdatePanel> contrôles. Ces méthodes correspondent aux méthodes semblables, de la <xref:System.Web.UI.ClientScriptManager> contrôle. Si vous êtes le script de rendu pour une utilisation à l’intérieur d’un <xref:System.Web.UI.UpdatePanel> contrôler, assurez-vous que vous appelez les méthodes de la <xref:System.Web.UI.ScriptManager> contrôle.  
  
|Méthode|Définition|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>|Ajoute une valeur à un tableau JavaScript. Si le tableau n’existe pas, il est créé.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>|Restitue un `script` élément après l’ouverture de la page `<form>` balise. Le script est spécifié comme un paramètre de chaîne.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>|Restitue un `script` élément après l’ouverture de la page `<form>` balise. Le contenu du script est spécifié en définissant le `src` attribut à une URL qui pointe vers un fichier de script.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>|Restitue un `script` élément après l’ouverture de la page `<form>` balise. Le contenu du script est spécifié avec un nom de ressource dans un assembly. Le `src` attribut est automatiquement rempli avec une URL par un appel à un gestionnaire HTTP qui Récupère le script nommé de l’assembly.|  
|<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>|Restitue une paire nom/valeur personnalisée (un expando) dans le balisage pour un contrôle spécifié.|  
|<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>|Restitue un champ masqué.|  
|<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>|Inscrit un script qui est exécuté en réponse à la `form` l’élément `submit` événement. Le `onSubmit` attribut fait référence le script spécifié.|  
|<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>|Restitue un bloc de script de démarrage juste avant la fermeture de la page `</form>` balise. Le script à afficher est spécifié comme un paramètre de chaîne.|  
  
 Lorsque vous inscrivez des méthodes, vous spécifiez une paire clé/type de ce script. Si un script avec la même paire clé/type est déjà inscrit, un nouveau script n’est pas inscrit. De même, si vous vous inscrivez un script avec une paire de nom de type/ressource qui déjà existe, le `script` élément qui référence la ressource n’est plus ajouté. Lorsque vous inscrivez l’attribut expando d’un attribut précédemment inscrit, une exception est levée. Inscription en double des valeurs du tableau est autorisée.  
  
 Lorsque vous appelez le <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> ou <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> (méthode), évitez d’inscrire un script qui exécute des fonctions inline. Au lieu de cela, inscrire un script qui contient les définitions de fonction telles que des gestionnaires d’événements ou des définitions de classe personnalisée pour votre application.  
  
### <a name="registration-methods-for-updatepanel-controls"></a>Méthodes d’inscription pour les contrôles UpdatePanel  
 Vous pouvez utiliser les méthodes suivantes pour personnaliser les mises à jour de page partielle lorsque vous utilisez <xref:System.Web.UI.UpdatePanel> contrôles.  
  
|Méthode|Définition|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>|Inscrit un contrôle comme déclencheur pour les publications (postback) asynchrones.|  
|<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>|Envoie des données personnalisées aux contrôles pendant le rendu de page partiel.|  
|<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>|Inscrit un script dispose d’un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle. Le script est exécuté lorsque le contrôle <xref:System.Web.UI.UpdatePanel> est mis à jour ou supprimé. La méthode dispose est utilisée pour les composants clients qui font partie de Microsoft Ajax Library et qui ont libérer des ressources lorsqu’un composant n’est plus utilisé.|  
|<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>|Inscrit un contrôle comme déclencheur pour une publication automatique complète. Cette méthode est utilisée pour les contrôles à l’intérieur d’un <xref:System.Web.UI.UpdatePanel> contrôle qui, sinon, exécuterait des publications (postback) asynchrone.|  
  
<a name="web_service_references"></a>   
## <a name="web-service-references"></a>Références de Service Web  
 Vous pouvez inscrire un service Web à appeler à partir du script client en créant un <xref:System.Web.UI.ServiceReference> objet et en l’ajoutant à la <xref:System.Web.UI.ScriptManager.Services%2A> collection de la <xref:System.Web.UI.ScriptManager> contrôle. ASP.NET génère un objet proxy client pour chaque <xref:System.Web.UI.ServiceReference> de l’objet dans le <xref:System.Web.UI.ScriptManager.Services%2A> collection. Vous pouvez ajouter par programmation <xref:System.Web.UI.ServiceReference> des objets sur le <xref:System.Web.UI.ScriptManager.Services%2A> collection à inscrire des services Web en cours d’exécution.  
  
 Pour plus d’informations sur comment accéder aux services Web dans le script, consultez [exposition de Services Web pour le Script Client dans ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8) et [appel des Services Web à partir du Script Client dans ASP.NET AJAX](https://msdn.microsoft.com/library/fc06c224-f01a-45be-94af-bd71afbc07b0).  
  
<a name="localization"></a>   
## <a name="localization"></a>Localisation  
 Le <xref:System.Web.UI.ScriptManager> contrôle génère des références dans la page rendue qui pointent vers les fichiers de script localisés appropriés, qui sont soit des fichiers de script incorporés dans les assemblys ou les fichiers de script autonome.  
  
 Lorsque le <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> propriété est définie sur `true`, le <xref:System.Web.UI.ScriptManager> contrôle récupère les ressources localisées (tels que des chaînes localisées) pour la culture actuelle, s’ils existent. Le <xref:System.Web.UI.ScriptManager> contrôle offre les fonctionnalités suivantes pour l’utilisation des ressources localisées :  
  
-   **Les fichiers qui sont incorporés dans un assembly de script**. Le <xref:System.Web.UI.ScriptManager> contrôle détermine le fichier de script spécifiques à la culture ou de la culture de secours à envoyer au navigateur. Pour ce faire à l’aide de la culture spécifique <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut d’assembly, les ressources fournies avec l’assembly et la culture d’interface utilisateur du navigateur (le cas échéant).  
  
-   **Fichiers de script autonome**. Le <xref:System.Web.UI.ScriptManager> contrôle définit la liste des cultures d’interface utilisateur qui sont pris en charge à l’aide de la <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> propriété de la <xref:System.Web.UI.ScriptReference> objet.  
  
-   **En mode débogage**. Le <xref:System.Web.UI.ScriptManager> contrôle tente d’afficher un fichier de script spécifique à la culture qui contient les informations de débogage. Par exemple, si la page est en mode débogage et la culture actuelle est définie en-MX, le contrôle restitue un fichier de script qui a un nom tel que `scriptname`.en-MX.Debug.js, si le fichier existe. Si le fichier n’existe pas, le fichier de débogage pour la culture de secours appropriée est restitué.  
  
 Pour plus d’informations sur la localisation des ressources, consultez [ressources de localisation pour une vue d’ensemble de bibliothèques de composant](https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb).  
  
<a name="error_handling"></a>   
## <a name="error-handling"></a>Gestion des erreurs  
 Lorsqu’une erreur de page se produit pendant les publications asynchrones, le <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement est déclenché. Le mode dans lequel les erreurs sur le serveur sont envoyées au client dépend du <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriété, le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété et la section d’erreurs personnalisées du fichier Web.config. Pour plus d’informations, consultez [personnalisation de gestion des erreurs pour les contrôles UpdatePanel](https://msdn.microsoft.com/library/e15e7ffb-e4b2-4a89-b99e-16624a5861d0).  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>Syntaxe déclarative  
  
```  
<asp:ScriptManager  
    AllowCustomErrorsRedirect="True|False"  
    AsyncPostBackErrorMessage="string"  
    AsyncPostBackTimeout="integer"  
    AuthenticationService-Path="uri"  
    EnablePageMethods="True|False"  
    EnablePartialRendering="True|False"  
    EnableScriptGlobalization="True|False"  
    EnableScriptLocalization="True|False"  
    EnableTheming="True|False"  
    EnableViewState="True|False"  
    ID="string"  
    LoadScriptsBeforeUI="True|False"  
    OnAsyncPostBackError="AsyncPostBackError event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnResolveScriptReference="ResolveScriptReference event handler"  
    OnUnload="Unload event handler"  
    ProfileService-LoadProperties="string"  
    ProfileService-Path="uri"  
    RoleService-LoadRoles="True|False"  
    RoleService-Path="uri"  
    runat="server"  
    ScriptMode="Auto|Inherit|Debug|Release"  
    ScriptPath="string"  
    SkinID="string"  
    SupportsPartialRendering="True|False"  
    Visible="True|False"  
>  
        <AuthenticationService  
            Path="uri"  
        />  
        <ProfileService  
            LoadProperties="string"  
            Path="uri"  
        />  
        <RoleService  
            LoadRoles="True|False"  
            Path="uri"  
        />  
        <Scripts>  
            <asp:ScriptReference  
                Assembly="string"  
                IgnoreScriptPath="True|False"  
                Name="string"  
                NotifyScriptLoaded="True|False"  
                Path="string"  
                ResourceUICultures="string"  
                ScriptMode="Auto|Debug|Inherit|Release"  
            />  
        </Scripts>  
        <Services>  
            <asp:ServiceReference  
                InlineScript="True|False"  
                Path="string"  
            />  
        </Services>  
</asp:ScriptManager>  
```  
  
   
  
## Examples  
 Les exemples suivants montrent différents scénarios d’utilisation le <xref:System.Web.UI.ScriptManager> contrôle.  
  
 **L’activation des mises à jour de Page partielle**  
  
 L’exemple suivant montre comment utiliser le <xref:System.Web.UI.ScriptManager> contrôle pour activer les mises à jour de page partielle. Dans cet exemple, un <xref:System.Web.UI.WebControls.Calendar> et un <xref:System.Web.UI.WebControls.DropDownList> contrôle sont à l’intérieur d’un <xref:System.Web.UI.UpdatePanel> contrôle. Par défaut, la valeur de la <xref:System.Web.UI.UpdatePanel.UpdateMode%2A> propriété est <xref:System.Web.UI.UpdatePanelUpdateMode.Always>et la valeur de la <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> propriété est `true`. Par conséquent, les contrôles enfants du Panneau de provoquent une publication (postback) asynchrone.  
  
 [!code-aspx-csharp[System.Web.UI.UpdatePanel#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/CS/UpdatePanelExample1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.UpdatePanel#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/VB/UpdatePanelExample1VB.aspx#1)]  
  
 **Gestion des erreurs de mise à jour de Page partielle et inscription de Script**  
  
 L’exemple suivant montre comment fournir personnalisé gestion des erreurs pendant les mises à jour de page partielle. Par défaut, lorsqu’une erreur se produit pendant les mises à jour de page partielle, une boîte de message JavaScript s’affiche. Cet exemple montre comment utiliser personnalisé gestion des erreurs en fournissant un gestionnaire pour le <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement et en définissant le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété dans le Gestionnaire d’événements. Vous pouvez également définir le <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriété pour spécifier comment la section d’erreurs personnalisées du fichier Web.config est utilisée lorsqu’une erreur se produit pendant les mises à jour de page partielle. Dans cet exemple, la valeur par défaut de la <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriété est utilisée. Cela signifie que si le fichier Web.config fichier contient un [customErrors](https://msdn.microsoft.com/library/6c3b53ec-00df-4967-b0fb-351c02867650) élément, cet élément détermine comment les erreurs sont affichées. Pour plus d’informations, consultez [customErrors, élément (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/288c32e2-df1f-4548-abda-de6b4cb989a6).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/VB/default.aspx#1)]  
  
 **Globalisation de la Date et l’heure qui s’affichent dans le navigateur**  
  
 L’exemple suivant montre comment définir le <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> propriété afin que ce script client puisse afficher une date spécifique à la culture et une heure dans le navigateur. Dans l’exemple, le `Culture` attribut de la [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) directive a pour valeur `auto`. Par conséquent, la première langue spécifiée dans les paramètres du navigateur détermine la culture et la culture d’interface utilisateur pour la page. Pour plus d'informations, voir [Procédure : Définir la Culture et la Culture d’interface utilisateur pour la globalisation des pages Web ASP.NET](https://msdn.microsoft.com/library/76091f86-f967-4687-a40f-de87bd8cc9a0).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/VB/default.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.ScriptManagerProxy" />
    <altmember cref="T:System.Web.UI.UpdatePanel" />
    <altmember cref="T:System.Web.UI.ClientScriptManager" />
    <altmember cref="T:System.Web.UI.ScriptMode" />
    <altmember cref="T:System.Web.UI.ScriptReference" />
    <altmember cref="T:System.Web.UI.ServiceReference" />
    <related type="Article" href="https://msdn.microsoft.com/library/fceeb3c5-c59f-46a9-af4f-b0d7155a1efc">Classe Sys.WebForms.PageRequestManager</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScriptManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScriptManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise les champs internes utilisés par le <xref:System.Web.UI.ScriptManager> contrôle pour effectuer le suivi de la page, le contrôle et les informations de déploiement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHistoryPoint">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un point d'historique et l'ajoute à la pile d'historique du navigateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces surcharges de méthode permettent de définir l’état du serveur et éventuellement le titre de l’entrée de l’historique dans le navigateur. Lorsque vous créez un point d’historique, les données sérialisées et chiffrées sont ajoutées à l’URL de la page Web et une entrée est incluse dans la pile d’historique du navigateur. Vous pouvez utiliser les données d’état pour recréer la page lorsque n’importe quel événement de navigation suivants du serveur est déclenché. Pour plus d’informations, consultez [la gestion de l’historique à l’aide de Server contrôles du navigateur](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (System.Collections.Specialized.NameValueCollection state, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(class System.Collections.Specialized.NameValueCollection state, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (state As NameValueCollection, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::Collections::Specialized::NameValueCollection ^ state, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : System.Collections.Specialized.NameValueCollection * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (state, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="state">Collection de paires clé/valeur qui contiennent les données pour l’état.</param>
        <param name="title">Texte qui sera ajouté à la pile d'historique du navigateur en tant que titre pour cet état.</param>
        <summary>Crée un point d’historique et l’ajoute à la pile d’historique du navigateur, à l’aide de la collection de données d’état et du titre d’état spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un point d’historique lorsque vous souhaitez enregistrer plusieurs paires clé/valeur pour les données d’état. Lorsque vous créez un point d’historique, les données sérialisées et chiffrées sont ajoutées à l’URL de la page Web et une entrée est incluse dans la pile d’historique du navigateur. Si le `title` paramètre est `null`, le titre de la page Web est utilisé comme titre de l’entrée d’état dans la pile d’historique.  
  
 Vous pouvez utiliser les données d’état pour recréer la page lorsque n’importe quel événement de navigation suivants du serveur est déclenché. Pour plus d’informations, consultez [la gestion de l’historique à l’aide de Server contrôles du navigateur](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Partie clé de la paire clé/valeur qui identifie l'état de la page Web.</param>
        <param name="value">Partie valeur de la paire clé/valeur qui identifie l'état de la page Web.</param>
        <summary>Crée un point d'historique et l'ajoute à la pile d'historique du navigateur, à l'aide de la clé d'état et de la valeur d'état spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un point d’historique lorsque vous souhaitez uniquement enregistrer une valeur pour identifier l’état. Lorsque vous créez un point d’historique, les données sérialisées et chiffrées sont ajoutées à l’URL de la page Web et une entrée est incluse dans la pile d’historique du navigateur. Le titre de la page Web est utilisé comme titre de l’entrée d’état dans la pile d’historique.  
  
 Vous pouvez utiliser les données d’état pour recréer la page lorsque n’importe quel événement de navigation suivants du serveur est déclenché. Pour plus d’informations, consultez [la gestion de l’historique à l’aide de Server contrôles du navigateur](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Partie clé de la paire clé/valeur qui identifie l'état de la page Web.</param>
        <param name="value">Partie valeur de la paire clé/valeur qui identifie l'état de la page Web.</param>
        <param name="title">Texte qui sera ajouté à la pile d'historique du navigateur en tant que titre pour cet état.</param>
        <summary>Crée un point d'historique et l'ajoute à la pile d'historique du navigateur, à l'aide de la clé d'état, de la valeur d'état et du titre d'état spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer un point d’historique lorsque vous souhaitez enregistrer une valeur pour identifier l’état et un titre pour l’état. Lorsque vous créez un point d’historique, les données sérialisées et chiffrées sont ajoutées à l’URL de la page Web et une entrée est incluse dans la pile d’historique du navigateur. Si le `title` paramètre est `null`, le titre de la page Web est utilisé comme titre de l’entrée d’état dans la pile d’historique.  
  
 Vous pouvez utiliser les données d’état pour recréer la page lorsque n’importe quel événement de navigation suivants du serveur est déclenché. Pour plus d’informations, consultez [la gestion de l’historique à l’aide de Server contrôles du navigateur](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly AjaxFrameworkAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly AjaxFrameworkAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AjaxFrameworkAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ AjaxFrameworkAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkAssembly : System.Reflection.Assembly" Usage="System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'assembly Framework Ajax utilisé par les composants sur la page.</summary>
        <value>Assembly d'infrastructure Ajax.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AjaxFrameworkMode As AjaxFrameworkMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AjaxFrameworkMode AjaxFrameworkMode { System::Web::UI::AjaxFrameworkMode get(); void set(System::Web::UI::AjaxFrameworkMode value); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkMode : System.Web.UI.AjaxFrameworkMode with get, set" Usage="System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AjaxFrameworkMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui définit la façon dont les scripts clients de la bibliothèque cliente Microsoft Ajax doivent être inclus dans le client.</summary>
        <value>Valeur d'énumération de <see cref="T:System.Web.UI.AjaxFrameworkMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> propriété pour activer tous les fichiers de script Microsoft Ajax, pour désactiver tous les fichiers de script Microsoft Ajax, ou inclure explicitement les fichiers de script individuels.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> propriété `Explicit` afin d’indiquer que les scripts peuvent être spécifiés explicitement.  
  
```  
<asp:ScriptManager ID="sm1" AjaxFrameworkMode="Explicit" runat="server">   
<Scripts>   
    <asp:ScriptReference Name="MicrosoftAjaxCore.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxComponentModel.js" />    
    <asp:ScriptReference Name="MicrosoftAjaxSerialization.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxNetwork.js" />       
</Scripts>   
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.AjaxFrameworkMode" />
      </Docs>
    </Member>
    <Member MemberName="AllowCustomErrorsRedirect">
      <MemberSignature Language="C#" Value="public bool AllowCustomErrorsRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomErrorsRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomErrorsRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomErrorsRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCustomErrorsRedirect : bool with get, set" Usage="System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui détermine si la section d'erreurs personnalisées du fichier Web.config est utilisée lors d'une erreur dans une publication (postback) asynchrone.</summary>
        <value><see langword="true" /> si le paramètre d'erreurs personnalisées dans le fichier Web.config est utilisé pour déterminer le comportement d'erreur pendant des publications (postback) asynchrones ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement est déclenché quand il existe une erreur de page pendant les publications asynchrones. Comment les erreurs sur le serveur sont envoyées au client dépend de la <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriété, le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété et la section d’erreurs personnalisées du fichier Web.config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AsyncPostBackError As EventHandler(Of AsyncPostBackErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::AsyncPostBackErrorEventArgs ^&gt; ^ AsyncPostBackError;" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackError : EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " Usage="member this.AsyncPostBackError : System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit en cas d'erreur de page pendant une publication (postback) asynchrone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement est déclenché quand il existe une erreur de page pendant les publications asynchrones. Comment les erreurs sur le serveur sont envoyées au client dépend de la <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriété, le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété et la section d’erreurs personnalisées du fichier Web.config.  
  
   
  
## Examples  
 L’exemple suivant montre comment gérer les <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement pour définir le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété (qui est envoyée au client) pour le message d’erreur exception serveur.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackErrorMessage">
      <MemberSignature Language="C#" Value="public string AsyncPostBackErrorMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackErrorMessage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackErrorMessage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackErrorMessage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackErrorMessage : string with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le message d'erreur envoyé au client quand une exception de serveur non gérée se produit pendant une publication (postback) asynchrone.</summary>
        <value>Message d'erreur. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement est déclenché quand il existe une erreur de page pendant les publications asynchrones. Comment les erreurs sur le serveur sont envoyées au client dépend de la <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriété, le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété et la section d’erreurs personnalisées du fichier Web.config.  
  
   
  
## Examples  
 L’exemple suivant montre comment gérer les <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement pour définir le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété (qui est envoyée au client) pour le message d’erreur exception serveur.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackSourceElementID">
      <MemberSignature Language="C#" Value="public string AsyncPostBackSourceElementID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackSourceElementID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncPostBackSourceElementID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackSourceElementID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackSourceElementID : string" Usage="System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.AsyncPostBackSourceElementID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'ID unique du contrôle qui a provoqué la publication (postback) asynchrone.</summary>
        <value>L'ID unique d'un contrôle, si le contrôle a un ID ; sinon, une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID%2A> propriété contient la valeur de l’ID de contrôle qui a provoqué la publication (postback) asynchrone, qui peut prendre l’une des opérations suivantes :  
  
-   Une publication (postback) à partir d’un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle dont <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> propriété est définie sur `true` (la valeur par défaut).  
  
-   Une publication (postback) à partir d’un contrôle qui est un déclencheur pour une <xref:System.Web.UI.UpdatePanel> contrôle.  
  
-   Une publication (postback) à partir d’un contrôle qui est inscrit en appelant le <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> méthode de la <xref:System.Web.UI.ScriptManager> contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackTimeout">
      <MemberSignature Language="C#" Value="public int AsyncPostBackTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AsyncPostBackTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AsyncPostBackTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackTimeout : int with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(90)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique la durée, en secondes, avant l'expiration des publications (postback) asynchrones si aucune réponse n'est reçue.</summary>
        <value>Entier qui représente le délai d'expiration en secondes. La valeur par défaut est 90 secondes.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationService">
      <MemberSignature Language="C#" Value="public System.Web.UI.AuthenticationServiceManager AuthenticationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.AuthenticationServiceManager AuthenticationService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationService As AuthenticationServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AuthenticationServiceManager ^ AuthenticationService { System::Web::UI::AuthenticationServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationService : System.Web.UI.AuthenticationServiceManager" Usage="System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AuthenticationServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.UI.AuthenticationServiceManager" /> associé à l'instance <see cref="T:System.Web.UI.ScriptManager" /> actuelle.</summary>
        <value>Objet <see cref="T:System.Web.UI.AuthenticationServiceManager" /> pour l'instance <see cref="T:System.Web.UI.ScriptManager" /> actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.AuthenticationServiceManager> objet qui est retourné par cette propriété représente le service d’authentification qui est enregistré avec la page. Le service d’authentification peut être défini dans le <xref:System.Web.UI.ScriptManager> contrôle ou un associé <xref:System.Web.UI.ScriptManagerProxy> contrôle.  
  
 Vous pouvez utiliser le service d’authentification ASP.NET ou utiliser un service d’authentification personnalisé. Vous pouvez ajouter le service personnalisé dans le balisage en incluant un `AuthenticationService` élément à l’intérieur du `asp:ScriptManager` élément sur la page, comme indiqué dans l’exemple suivant.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <AuthenticationService Path="MyAuthenticationService.asmx" />  
</asp:ScriptManager>  
```  
  
 Vous pouvez également configurer par programme le <xref:System.Web.UI.AuthenticationServiceManager> objet. Les services sont enregistrés avec le <xref:System.Web.UI.ScriptManager> contrôle lors de la page <xref:System.Web.UI.Control.PreRender> phase du cycle de vie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientNavigateHandler">
      <MemberSignature Language="C#" Value="public string ClientNavigateHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientNavigateHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientNavigateHandler As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientNavigateHandler { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientNavigateHandler : string with get, set" Usage="System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de la méthode qui gère l’événement <see href="https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93">Sys.Application.navigate</see> sur le client.</summary>
        <value>Le nom de la méthode qui gère la [Sys.Application.navigate](https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93) événement sur le client.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.CompositeScriptReference CompositeScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.CompositeScriptReference CompositeScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.CompositeScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositeScript As CompositeScriptReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::CompositeScriptReference ^ CompositeScript { System::Web::UI::CompositeScriptReference ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositeScript : System.Web.UI.CompositeScriptReference" Usage="System.Web.UI.ScriptManager.CompositeScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.CompositeScriptReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au script composite qui prend en charge la page web.</summary>
        <value>Référence au script composite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [combinant des Scripts clients dans un Script Composite](https://msdn.microsoft.com/library/d0f608d0-b4c8-4795-990b-ede68c1239b3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyPageUrl">
      <MemberSignature Language="C#" Value="public virtual string EmptyPageUrl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EmptyPageUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EmptyPageUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EmptyPageUrl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EmptyPageUrl : string with get, set" Usage="System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor(typeof(System.Web.UI.Design.UrlEditor), typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.UrlProperty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une URL vers une page Web vierge.</summary>
        <value>URL à utiliser si la page Web cible est vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.EmptyPageUrl%2A> propriété prend en charge l’historique du navigateur Ajax.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdn">
      <MemberSignature Language="C#" Value="public bool EnableCdn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdn" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdn" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdn : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si la page active charge des références de script client à partir de chemins d'accès CDN (Content Delivery Network).</summary>
        <value><see langword="true" /> si des références de script client sont chargées à partir de chemins d'accès CDN ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ne définissez pas cette propriété sur `true` si vous définissez <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> à `true` déjà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdnFallback">
      <MemberSignature Language="C#" Value="public bool EnableCdnFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdnFallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdnFallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdnFallback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdnFallback : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Permet la copie locale d'un script dans le cas où le CDN (Content Delivery Network) n'est pas disponible.</summary>
        <value><see langword="true" /> si la valeur de réseau de diffusion de contenu de secours est activée ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHistory">
      <MemberSignature Language="C#" Value="public bool EnableHistory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHistory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableHistory" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHistory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHistory { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHistory : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableHistory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la page Web prend en charge la gestion des points d'historique.</summary>
        <value><see langword="true" /> si la page Web prend en charge l'ajout de points d'historique à la pile d'historique du navigateur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.ScriptManager.EnableHistory%2A> propriété pour activer la gestion de l’historique dans une page Web.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePageMethods">
      <MemberSignature Language="C#" Value="public bool EnablePageMethods { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePageMethods" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePageMethods As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePageMethods { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePageMethods : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les méthodes de page statiques publiques d'une page ASP.NET peuvent être appelées par le script client.</summary>
        <value><see langword="true" /> si les méthodes de page statiques d'une page ASP.NET peuvent être appelées par le script client comme méthodes Web ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez ajouter des méthodes de page statiques à une page ASP.NET et les marquer en tant que méthodes Web. Vous pouvez ensuite appeler ces méthodes à partir du script comme si elles faisaient partie d’un service Web, mais sans création d’un fichier .asmx distinct. Pour créer des méthodes Web sur une page, importez le <xref:System.Web.Services> espace de noms et ajoutez un <xref:System.Web.Services.WebMethodAttribute> attribut à chaque méthode statique que vous souhaitez exposer. Les méthodes doivent être marquées comme publiques.  
  
 Pour plus d’informations, consultez [exposition de Services Web pour le Script Client dans ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePartialRendering">
      <MemberSignature Language="C#" Value="public bool EnablePartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui active le rendu partiel d'une page qui, à son tour, vous permet de mettre à jour des zones de la page individuellement à l'aide de contrôles <see cref="T:System.Web.UI.UpdatePanel" />.</summary>
        <value><see langword="true" /> si le rendu partiel est activé et si les mises à jour pleine page sont supprimées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Même si le <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriété est `true`, rendu de page partielle ne peut pas se produire. Le navigateur ne prenne pas en charge le rendu de page partielle, ou le <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriété est définie sur `false`.  
  
 Vous pouvez remplacer la valeur de la <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriété au moment de l’exécution pendant ou avant de la page <xref:System.Web.UI.Control.Init> événement. Si vous essayez de modifier cette propriété après la page <xref:System.Web.UI.Control.Init> d’événement, un <xref:System.InvalidOperationException> exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> est définie une fois que l'événement <see cref="E:System.Web.UI.Control.Init" /> de la page s'est produit.</exception>
        <altmember cref="T:System.Web.UI.UpdatePanel" />
        <altmember cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="EnableScriptGlobalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptGlobalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptGlobalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptGlobalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptGlobalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptGlobalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le contrôle <see cref="T:System.Web.UI.ScriptManager" /> restitue le script qui prend en charge l'analyse et la mise en forme des informations spécifiques à la culture.</summary>
        <value><see langword="true" /> si les informations spécifiques à la culture peuvent être affichées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> propriété est définie sur `true`, les globalisées ECMAScript (JavaScript) fonctions telles que le `Date.localeFormat` afficher des informations de culture spécifique (méthode). La culture peut être définie dans le navigateur, dans le code serveur ou dans le fichier de configuration du site Web.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/69b34e6d-d590-4d03-a763-b7ae54b47d74">Localisation d’une Date à l’aide du Script Client</related>
      </Docs>
    </Member>
    <Member MemberName="EnableScriptLocalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptLocalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptLocalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptLocalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptLocalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptLocalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le contrôle <see cref="T:System.Web.UI.ScriptManager" /> restitue des versions localisées des fichiers de script.</summary>
        <value><see langword="true" /> si les fichiers de script localisés sont restitués ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> propriété est définie sur `true`, le <xref:System.Web.UI.ScriptManager> objet récupère les fichiers de script pour la culture actuelle si elles existent. Par exemple, une page peut spécifier un fichier de script nommé CustomScript.js. Si la culture est définie sur fr-CA, le <xref:System.Web.UI.ScriptManager> objet tente de récupérer un fichier de script nommé CustomScript.fr-CA.js.  
  
> [!NOTE]
>  Pour empêcher le rendu deux fois, un fichier de script le <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> propriété ne doit pas être modifiée pendant une publication (postback) asynchrone.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb">Localisation des ressources pour une vue d’ensemble de bibliothèques de composant</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSecureHistoryState">
      <MemberSignature Language="C#" Value="public bool EnableSecureHistoryState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSecureHistoryState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSecureHistoryState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSecureHistoryState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSecureHistoryState : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique s'il faut chiffrer la chaîne d'état de l'historique.</summary>
        <value><see langword="true" /> si la chaîne d'état de l'historique doit être chiffrée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Cette propriété doit ***jamais*** avoir la valeur `false` sur un site web de production.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptManager GetCurrent (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ScriptManager GetCurrent(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetCurrent(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ScriptManager ^ GetCurrent(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : System.Web.UI.Page -&gt; System.Web.UI.ScriptManager" Usage="System.Web.UI.ScriptManager.GetCurrent page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">Instance de page à partir de laquelle récupérer le <see cref="T:System.Web.UI.ScriptManager" />.</param>
        <summary>Obtient l'instance <see cref="T:System.Web.UI.ScriptManager" /> pour un objet <see cref="T:System.Web.UI.Page" /> donné.</summary>
        <returns>Instance <see cref="T:System.Web.UI.ScriptManager" /> en cours pour l'objet <see cref="T:System.Web.UI.Page" /> sélectionné, ou <see langword="null" /> si aucune instance n'est définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode statique pour déterminer si un <xref:System.Web.UI.ScriptManager> contrôle est sur une page, ou pour accéder aux propriétés et méthodes d’un <xref:System.Web.UI.ScriptManager> contrôler lorsque vous ne connaissez pas son ID.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredArrayDeclarations">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredArrayDeclarations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredArrayDeclarations () As ReadOnlyCollection(Of RegisteredArrayDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredArrayDeclaration ^&gt; ^ GetRegisteredArrayDeclarations();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredArrayDeclarations : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;" Usage="scriptManager.GetRegisteredArrayDeclarations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection en lecture seule de déclarations de tableau ECMAScript (JavaScript) précédemment inscrites avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Collection générique qui contient les déclarations de tableau.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterArrayDeclaration" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredClientScriptBlocks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredClientScriptBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredClientScriptBlocks () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredClientScriptBlocks();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredClientScriptBlocks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredClientScriptBlocks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection en lecture seule de blocs de script client précédemment inscrits avec le contrôle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <returns>Collection générique qui contient les blocs de script client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blocs de script client sont inscrits avec le <xref:System.Web.UI.ScriptManager> contrôle pour une utilisation avec un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredDisposeScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredDisposeScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredDisposeScripts () As ReadOnlyCollection(Of RegisteredDisposeScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredDisposeScript ^&gt; ^ GetRegisteredDisposeScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredDisposeScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;" Usage="scriptManager.GetRegisteredDisposeScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection en lecture seule de scripts <see langword="dispose" /> précédemment inscrits avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Collection générique qui contient les scripts <see langword="dispose" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un `dispose` script s’exécute lorsque le <xref:System.Web.UI.UpdatePanel> contrôle est mis à jour ou supprimé.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredExpandoAttributes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredExpandoAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredExpandoAttributes () As ReadOnlyCollection(Of RegisteredExpandoAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredExpandoAttribute ^&gt; ^ GetRegisteredExpandoAttributes();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredExpandoAttributes : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;" Usage="scriptManager.GetRegisteredExpandoAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection en lecture seule d'attributs personnalisés (expando) précédemment inscrits avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Collection générique qui contient les attributs personnalisés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un attribut personnalisé est une paire nom/valeur qui peut être lu et définie par le script client.  
  
   
  
## Examples  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.RegisteredExpandoAttribute>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredHiddenFields">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredHiddenFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredHiddenFields () As ReadOnlyCollection(Of RegisteredHiddenField)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredHiddenField ^&gt; ^ GetRegisteredHiddenFields();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredHiddenFields : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;" Usage="scriptManager.GetRegisteredHiddenFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection en lecture seule de champs masqués précédemment inscrits avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Collection générique qui contient les champs masqués.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.UI.RegisteredHiddenField" />
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterHiddenField" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredOnSubmitStatements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredOnSubmitStatements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredOnSubmitStatements () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredOnSubmitStatements();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredOnSubmitStatements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredOnSubmitStatements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection en lecture seule d'instructions <see langword="onsubmit" /> précédemment inscrites avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Collection générique qui contient les instructions <see langword="onsubmit" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un `onsubmit` instruction est ECMAScript (JavaScript) qui est exécuté lorsque le formulaire est envoyé.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredStartupScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredStartupScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredStartupScripts () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredStartupScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredStartupScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredStartupScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection en lecture seule de scripts de démarrage précédemment inscrits avec l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Collection générique qui contient les scripts de démarrage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un script de démarrage est un script client qui est associé à un contrôle qui s’exécute lorsque le contrôle est démarré.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ScriptManager.GetRegisteredStartupScripts%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStateString">
      <MemberSignature Language="C#" Value="public string GetStateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetStateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetStateString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetStateString();" />
      <MemberSignature Language="F#" Value="member this.GetStateString : unit -&gt; string" Usage="scriptManager.GetStateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une chaîne qui contient des paires clé/valeur qui représentent l'état de la page Web.</summary>
        <returns>Chaîne contenant les paires clé/valeur qui représentent l'état de la page Web.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsDebuggingEnabled</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les versions debug de bibliothèques de scripts clients seront restituées.</summary>
        <value><see langword="true" /> si la requête en cours s'exécute en mode débogage ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> retourne de la propriété `false` lorsque l’une des conditions suivantes est vraie :  
  
-   Dans le [déploiement](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) élément du fichier de configuration, le `retail` attribut a la valeur `true`. Cela remplace tous les autres paramètres.  
  
-   Le <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriété est définie sur `Auto` ou `Inherit`, et le débogage n’est pas activé dans la `compilation` section du fichier Web.config racine de l’application.  
  
-   La propriété <xref:System.Web.UI.ScriptManager.ScriptMode%2A> a la valeur `Release`.  
  
    > [!NOTE]
    >  Le `debug` attribut de la [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) directive n’affecte pas les applications ASP.NET compatibles Ajax. Le <xref:System.Web.UI.ScriptManager> contrôle utilise uniquement les paramètres dans le fichier Web.config et dans ses <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> et <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriétés pour déterminer s’il faut restituer des scripts de débogage.  
  
 Pour plus d’informations, consultez [débogage et le suivi de la vue d’ensemble des Applications Ajax](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.IsDebuggingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsInAsyncPostBack">
      <MemberSignature Language="C#" Value="public bool IsInAsyncPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInAsyncPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInAsyncPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInAsyncPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInAsyncPostBack : bool" Usage="System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsInAsyncPostBack</InterfaceMember>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.IsInAsyncPostBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la publication (postback) en cours est exécutée en mode de rendu partiel.</summary>
        <value><see langword="true" /> si la publication (postback) en cours s'exécute en mode de rendu partiel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> propriété en combinaison avec le <xref:System.Web.UI.Page.IsPostBack%2A> propriété pour faire la distinction entre le chargement de page initial, une mise à jour de page partielle et une mise à jour pleine page <xref:System.Web.UI.Control.Load>, <xref:System.Web.UI.Page.InitComplete>, ou <xref:System.Web.UI.Control.PreRender> événements.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="IsNavigating">
      <MemberSignature Language="C#" Value="public bool IsNavigating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNavigating" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsNavigating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNavigating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNavigating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNavigating : bool" Usage="System.Web.UI.ScriptManager.IsNavigating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si un événement <see cref="E:System.Web.UI.ScriptManager.Navigate" /> est actuellement géré.</summary>
        <value><see langword="true" /> si <see cref="E:System.Web.UI.ScriptManager.Navigate" /> est actuellement géré ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.ScriptManager.IsNavigating%2A> propriété afin de déterminer si le <xref:System.Web.UI.ScriptManager.Navigate> événement a été déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPostData">
      <MemberSignature Language="C#" Value="protected virtual bool LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection);" />
      <MemberSignature Language="F#" Value="abstract member LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool&#xA;override this.LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool" Usage="scriptManager.LoadPostData (postDataKey, postCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">Identificateur de clé pour le contrôle.</param>
        <param name="postCollection">Collection de toutes les données de publication (postback) entrantes.</param>
        <summary>Lit les données de formulaire publiées à partir du navigateur sur le serveur et détermine la source de la publication (postback) asynchrone.</summary>
        <returns><see langword="true" /> si l'état du contrôle <see cref="T:System.Web.UI.ScriptManager" /> a été modifié à la suite d'une publication (postback) ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.LoadPostData%2A> méthode est principalement utilisée par les développeurs de contrôles pour étendre les fonctionnalités de la <xref:System.Web.UI.ScriptManager> contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="LoadScriptsBeforeUI">
      <MemberSignature Language="C#" Value="public bool LoadScriptsBeforeUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadScriptsBeforeUI" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadScriptsBeforeUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadScriptsBeforeUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadScriptsBeforeUI : bool with get, set" Usage="System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les scripts sont chargés avant ou après le chargement du balisage pour l'interface utilisateur de la page.</summary>
        <value><see langword="true" /> si les scripts sont chargés avant le chargement du balisage pour l'interface utilisateur ; <see langword="false" /> si les scripts sont chargés après le chargement du balisage pour l'interface utilisateur. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> propriété détermine comment les scripts dans le <xref:System.Web.UI.ScriptManager.Scripts%2A> collection sont chargés par rapport à la balise de la page de l’interface utilisateur.  
  
 Lorsque le <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> propriété est `true`, un `script` élément est rendu avant le chargement du balisage de l’interface utilisateur de la page. Dans ce scénario, si les éléments d’interface utilisateur sont définis dans les scripts, l’interface utilisateur sera entièrement fonctionnel lors du chargement. Toutefois, si le script accède à des éléments d’interface utilisateur dans le balisage pour lequel instances n’ont pas encore été créées, une erreur peut se produire. Pour vous assurer que les éléments d’interface utilisateur sont chargés avant d’y accéder, gérer la `load` événements de la `Sys.Application` classe.  
  
 Lorsque le <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> propriété est `false`, un `script` élément est rendu après que le balisage de l’interface utilisateur de la page est affiché. Dans ce scénario, l’interface utilisateur se charge plus rapidement, mais il peut être entièrement fonctionnelle si les scripts qui définissent des éléments d’interface utilisateur supplémentaires ne sont pas terminé le chargement.  
  
 Ne définissez pas cette propriété sur `true` si vous définissez <xref:System.Web.UI.ScriptManager.EnableCdn%2A> à `true` déjà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.Scripts" />
        <altmember cref="T:System.Web.UI.ScriptReference" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.HistoryEventArgs&gt; Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As EventHandler(Of HistoryEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::HistoryEventArgs ^&gt; ^ Navigate;" />
      <MemberSignature Language="F#" Value="member this.Navigate : EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " Usage="member this.Navigate : System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l’utilisateur clique sur le bouton **Précédent** ou **Suivant** du navigateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur clique sur le navigateur **retour** bouton, le navigateur parcourt les URL précédemment consultées, ce qui peuvent inclure des URL qui contiennent des données d’état de point d’historique. Si le code client dans la page Web détecte que l’URL contient des données d’état de l’historique, elle envoie une demande à la page du serveur. Il agit comme un événement de publication (postback) et le <xref:System.Web.UI.ScriptManagerProxy> contrôle serveur déclenche la `Navigate` événement. Vous pouvez gérer cet événement et recréer la page selon les besoins de l’application Web en utilisant les données d’état qui sont passées à l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAsyncPostBackError">
      <MemberSignature Language="C#" Value="protected internal virtual void OnAsyncPostBackError (System.Web.UI.AsyncPostBackErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAsyncPostBackError(class System.Web.UI.AsyncPostBackErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnAsyncPostBackError (e As AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnAsyncPostBackError(System::Web::UI::AsyncPostBackErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit&#xA;override this.OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit" Usage="scriptManager.OnAsyncPostBackError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.AsyncPostBackErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement de l'erreur.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement est déclenché quand il existe une erreur de page pendant les publications asynchrones. Comment les erreurs sur le serveur sont envoyées au client dépend de la <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriété, le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété et la section d’erreurs personnalisées du fichier Web.config.  
  
   
  
## Examples  
 L’exemple suivant montre comment gérer les <xref:System.Web.UI.ScriptManager.AsyncPostBackError> événement pour définir le <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriété (qui est envoyée au client) pour le message d’erreur exception serveur.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="scriptManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Init" /> et s'assure qu'un seul contrôle <see cref="T:System.Web.UI.ScriptManager" /> existe sur la page.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Il existe plusieurs instances de <see cref="T:System.Web.UI.ScriptManager" /> sur la page.</exception>
        <block subset="none" type="overrides"><para>Lorsque vous substituez cette méthode, appelez la base <see cref="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" /> méthode afin que les fichiers de script soient correctement gérés pour le rendu de page partielle.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Vue d’ensemble du Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="scriptManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.PreRender" /> et inscrit des fichiers de script et des services pour les mises à jour de pages partielles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur le modèle DOM, consultez le [Document objet Model (DOM) Level 1 Specification](https://go.microsoft.com/fwlink/?LinkId=73305) sur le site Web de World Wide Web Consortium (W3C).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le navigateur qui a fait la demande de page partielle ne prend pas en charge au moins DOM niveau 1.0.</exception>
        <block subset="none" type="overrides"><para>Lorsque vous substituez cette méthode, appelez la base <see cref="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" /> méthode afin que les services et les blocs de script soient correctement gérés pour le rendu de page partielle.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Vue d’ensemble du Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveCompositeScriptReference (System.Web.UI.CompositeScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveCompositeScriptReference(class System.Web.UI.CompositeScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveCompositeScriptReference (e As CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveCompositeScriptReference(System::Web::UI::CompositeScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveCompositeScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.CompositeScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet qui représente la référence de script composite.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveScriptReference (System.Web.UI.ScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveScriptReference(class System.Web.UI.ScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveScriptReference(System.Web.UI.ScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveScriptReference (e As ScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveScriptReference(System::Web::UI::ScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.ScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet qui représente le script en cours.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.ScriptManager.ResolveScriptReference" /> pour chaque référence de script gérée par le contrôle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Web.UI.ScriptManager.OnPreRender%2A> Gestionnaire d’événements, une fois pour chaque <xref:System.Web.UI.ScriptReference> dans le <xref:System.Web.UI.ScriptManager.Scripts%2A> collection.  
  
 Le <xref:System.Web.UI.ScriptManager.ResolveScriptReference> événement est déclenché une fois que les entrées du script en double ont été résolues.  
  
 Substituez cette méthode pour affecter le comportement des blocs de script individuels lors de la publication ou au cours des mises à jour de page partielle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProfileService">
      <MemberSignature Language="C#" Value="public System.Web.UI.ProfileServiceManager ProfileService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ProfileServiceManager ProfileService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ProfileService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProfileService As ProfileServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ProfileServiceManager ^ ProfileService { System::Web::UI::ProfileServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProfileService : System.Web.UI.ProfileServiceManager" Usage="System.Web.UI.ScriptManager.ProfileService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ProfileServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.UI.ProfileServiceManager" /> associé à l'instance <see cref="T:System.Web.UI.ScriptManager" /> actuelle.</summary>
        <value>Objet <see cref="T:System.Web.UI.ProfileServiceManager" /> pour l'instance <see cref="T:System.Web.UI.ScriptManager" /> actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ProfileServiceManager> objet qui est retourné par cette propriété représente le service de profil est enregistré avec la page. Le service de profil peut être défini dans le <xref:System.Web.UI.ScriptManager> contrôle ou un associé <xref:System.Web.UI.ScriptManagerProxy> contrôle.  
  
 Vous pouvez utiliser le service de profil ASP.NET ou utiliser un service de profil personnalisé. Vous pouvez ajouter le service personnalisé dans le balisage en incluant un `ProfileService` élément à l’intérieur du `asp:ScriptManager` élément sur la page, comme indiqué dans l’exemple suivant.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <ProfileService LoadProperties="propertyA,propertyB"  
    Path="MyProfileService.asmx" />  
</asp:ScriptManager>  
```  
  
 Vous pouvez également configurer par programme le <xref:System.Web.UI.ProfileServiceManager> objet. Les services sont enregistrés avec le <xref:System.Web.UI.ScriptManager> contrôle lors de la page <xref:System.Web.UI.Control.PreRender> phase du cycle de vie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : string -&gt; unit&#xA;override this.RaisePostBackEvent : string -&gt; unit" Usage="scriptManager.RaisePostBackEvent eventArgument" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Chaîne de paires clé/valeur qui représentent l'état de l'historique de la page Web.</param>
        <summary>Traite un événement de publication (postback) déclenché par le contrôle <see cref="T:System.Web.UI.ScriptManager" /> et charge l'état de l'historique de la page Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostDataChangedEvent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostDataChangedEvent();" />
      <MemberSignature Language="F#" Value="abstract member RaisePostDataChangedEvent : unit -&gt; unit&#xA;override this.RaisePostDataChangedEvent : unit -&gt; unit" Usage="scriptManager.RaisePostDataChangedEvent " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclenche des événements pour le contrôle <see cref="T:System.Web.UI.ScriptManager" /> lors de la publication sur le serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.RaisePostDataChangedEvent%2A> méthode est principalement utilisée par les développeurs de contrôles pour étendre les fonctionnalités de la <xref:System.Web.UI.ScriptManager> contrôle. Pour l’implémentation par défaut de la <xref:System.Web.UI.ScriptManager> contrôle, aucun événement est déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterArrayDeclaration">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit une déclaration de tableau ECMAScript (JavaScript) avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" /> et ajoute le tableau à la page.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (control, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit le tableau.</param>
        <param name="arrayName">Nom du tableau à inscrire.</param>
        <param name="arrayValue">Valeur(s) de tableau à inscrire.</param>
        <summary>Inscrit une déclaration de tableau ECMAScript (JavaScript) avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" /> et ajoute le tableau à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> méthode pour inscrire un tableau de script client qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Cette méthode inscrit le tableau lorsque `control` représente un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle qui est en cours de mise à jour. Pour inscrire un tableau chaque fois qu’une publication (postback) asynchrone se produit, utilisez le <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un tableau sans se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le tableau qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> méthode détermine si un tableau portant le nom spécifié dans le `arrayName` paramètre est déjà inscrit. Si, par conséquent, la méthode ajoute les valeurs spécifiées dans `arrayValue`. Étant donné que le tableau à inscrire est basé sur le <xref:System.Collections.ArrayList> (classe), les doublons sont autorisés. Si un tableau inscrit avec le nom dans `arrayName` n’existe pas, le tableau est créé et les valeurs `arrayValue` sont ajoutés à ce dernier.  
  
 Pour inclure des littéraux de chaîne dans le tableau, utilisez des guillemets simples (') ou d’échappement des guillemets doubles (\\») dans `arrayValue`.  
  
 Notez que JavaScript traite une virgule (,) comme délimiteur dans un tableau. Vous pouvez spécifier plusieurs valeurs de tableau en passant une chaîne délimitée par des virgules dans `arrayValue`. Séparer deux éléments par une virgule dans `arrayValue` équivaut à appeler le <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> méthode deux fois, une fois pour chaque élément.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Page page, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Page page, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Page ^ page, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (page, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit le tableau.</param>
        <param name="arrayName">Nom du tableau à inscrire.</param>
        <param name="arrayValue">Valeur(s) de tableau à inscrire.</param>
        <summary>Inscrit une déclaration de tableau ECMAScript (JavaScript) avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" /> et ajoute le tableau à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> méthode pour inscrire un tableau de script client qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Cette méthode inscrit le tableau chaque fois qu’une publication (postback) asynchrone se produit. Pour inscrire un tableau pour un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôler afin que le tableau est enregistré uniquement lorsque le panneau est mis à jour, utilisez le <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un tableau sans se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le tableau qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterAsyncPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAsyncPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAsyncPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterAsyncPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterAsyncPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle à inscrire pour les publications (postback) asynchrones.</param>
        <summary>Inscrit un contrôle comme déclencheur pour les publications (postback) asynchrones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> méthode vous permet d’inscrire des contrôles serveur Web en tant que déclencheurs afin qu’ils effectuent une publication (postback) asynchrone au lieu d’une publication (postback) synchrone. Lorsque le <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> propriété d’un <xref:System.Web.UI.UpdatePanel> contrôle est défini sur `true` (qui est la valeur par défaut), contrôles à l’intérieur de publication (postback) le <xref:System.Web.UI.UpdatePanel> contrôle sont automatiquement enregistrés en tant que contrôles de publication (postback) asynchrones.  
  
 Utilisez le <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> méthode pour inscrire des contrôles à l’extérieur un <xref:System.Web.UI.UpdatePanel> contrôle en tant que déclencheurs pour les publications asynchrones et éventuellement mettre à jour le contenu d’un panneau de mise à jour. Pour mettre à jour un <xref:System.Web.UI.UpdatePanel> contrôler par programme, appelez le <xref:System.Web.UI.UpdatePanel.Update%2A> (méthode).  
  
 Vous pouvez ajouter le déclencheur de façon déclarative à l’aide de la `Triggers` élément de la <xref:System.Web.UI.UpdatePanel> contrôle. Dans Visual Studio, utilisez le concepteur **éditeur de collections UpdatePanelTrigger** boîte de dialogue.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> méthode pour inscrire un <xref:System.Web.UI.WebControls.Button> contrôle afin qu’il provoque une mise à jour d’un <xref:System.Web.UI.UpdatePanel> contenu du contrôle. Le <xref:System.Web.UI.WebControls.Button> contrôle n’est pas à l’intérieur du <xref:System.Web.UI.UpdatePanel> contrôle. Deux boutons sont affichés : `Button1` et `Button2`. `Button1` Actualise le contenu du panneau, et `Button2` actualise la page entière.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager1VB.aspx#1)]  
  
 L’exemple suivant montre comment appeler le <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> méthode pour inscrire un utilisateur contrôle afin qu’il provoque une mise à jour d’un <xref:System.Web.UI.UpdatePanel> contenu du contrôle. Le premier exemple montre une page en utilisant le contrôle utilisateur. Le deuxième exemple montre le contrôle utilisateur.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager2CS.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager2VB.aspx#2)]  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La page est inscrite comme un contrôle de publication (postback) asynchrone.
ou

Le contrôle inscrit n'implémente pas les interfaces <see cref="T:System.Web.UI.INamingContainer" />, <see cref="T:System.Web.UI.IPostBackDataHandler" /> ou <see cref="T:System.Web.UI.IPostBackEventHandler" />.</exception>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
        <altmember cref="M:System.Web.UI.UpdatePanel.Update" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un bloc de script client avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />, puis ajoute le bloc de script à la page.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit le bloc de script client.</param>
        <param name="type">Type du bloc de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur <see langword="typeof" /> (C#) ou l'opérateur <see langword="GetType" /> (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour le bloc de script.</param>
        <param name="script">Script.</param>
        <param name="addScriptTags"><see langword="true" /> pour mettre le bloc de script entre des balises <see langword="&lt;script&gt;" /> et <see langword="&lt;/script&gt;" /> ; sinon, <see langword="false" />.</param>
        <summary>Inscrit un bloc de script client avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />, puis ajoute le bloc de script à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> méthode pour inscrire un bloc de script client qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Les blocs de script client qui sont inscrits à l’aide de cette méthode sont envoyés à la page uniquement lorsque `control` représente un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle qui est en cours de mise à jour. Pour inscrire un bloc de script chaque fois qu’une publication (postback) asynchrone se produit, utilisez le <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un bloc de script qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le bloc de script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 Si `addScriptTags` est `true`, le <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> ajoute de la méthode `<script>` balises autour du bloc de script. Passer `false` si vous souhaitez créer `<script>` balises vous-même, comme lorsque vous souhaitez définir les attributs de spécifiques `<script>` balises. Si `addScriptTags` est `false` et `script` paramètre contient plusieurs blocs de script, une exception est levée.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> méthode ajoute un bloc de script à la page après l’ouverture `<form>` balise. Les blocs de script ne sont pas garanti que la sortie dans le même ordre que celui dans lequel ils sont inscrits. Si l’ordre des blocs de script est important, concaténez vos blocs de script dans une chaîne unique (par exemple, en utilisant le <xref:System.Text.StringBuilder> objet), puis les inscrit comme un bloc de script client unique.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/CS/ScriptManager_RegisterClientScriptBlockCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/vb/ScriptManager_RegisterClientScriptBlockVB.aspx#1)]  
  
 [!code-xml[System.Web.UI.ScriptManager.RegisterClientScriptBlock#2](~/samples/snippets/common/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/Common/App_Data/Contacts.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le bloc de script client <paramref name="type" /> est <see langword="null" />.  
  
ou 
Le contrôle qui inscrit le bloc de script est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le contrôle qui inscrit le bloc de script n'est pas dans l'arborescence du contrôle de la page.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit le bloc de script client.</param>
        <param name="type">Type du bloc de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur <see langword="typeof" /> (C#) ou l'opérateur <see langword="GetType" /> (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour le bloc de script.</param>
        <param name="script">Le script à inscrire.</param>
        <param name="addScriptTags"><see langword="true" /> pour mettre le bloc de script entre des balises <see langword="&lt;script&gt;" /> et <see langword="&lt;/script&gt;" /> ; sinon, <see langword="false" />.</param>
        <summary>Inscrit un bloc de script client avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />, puis ajoute le bloc de script à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous inscrivez un bloc de script à l’aide de cette méthode, le script est restitué chaque fois qu’une publication (postback) asynchrone se produit. Pour inscrire un bloc de script pour un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôler afin que le script est enregistré uniquement lorsque le <xref:System.Web.UI.UpdatePanel> contrôle est mis à jour, utilisez le <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un bloc de script qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le bloc de script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le bloc de script <paramref name="type" /> est <see langword="null" />.  
  
ou 
La page qui inscrit le bloc de script est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un fichier de script client avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />, puis ajoute une référence de fichier de script à la page.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (control, type, key, url)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit le fichier de script client.</param>
        <param name="type">Type du fichier de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour le fichier de script.</param>
        <param name="url">URL du fichier de script.</param>
        <summary>Inscrit un fichier de script client avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />, puis ajoute une référence de fichier de script à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> méthode pour inscrire un fichier de script client pour une page ou une partie d’une page qui participe dans mises à jour de page partielle. Les fichiers de script client qui sont inscrits à l’aide de cette méthode sont envoyés à la page uniquement lorsque le `control` représente un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle qui est en cours de mise à jour. Pour inscrire un fichier de script chaque fois qu’une publication (postback) asynchrone se produit, utilisez le <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un bloc de script qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le bloc de script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> méthode inscrit un fichier de script client dans la page en rendant un `script` élément dont la balise ouvrante contient un `src` attribut. Le `url` paramètre est utilisé pour définir le `src` attribut. Pour résoudre des URL, utilisez le <xref:System.Web.UI.Control.ResolveClientUrl%2A> (méthode). Cette méthode utilise le contexte de l’URL, il est appelé pour résoudre le chemin d’accès.  
  
 À la fois le <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> et <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> méthodes restituer des fichiers de script dans le navigateur. Si un script avec le même type et clé (pour un fichier de script) ou le même type et nom de ressource (pour une ressource incorporée) est déjà rendu, le script n’est pas rendu à nouveau.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptInclude#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/ScriptManager_RegisterClientScriptIncludeCS.aspx#1)]  
  
 [!code-javascript[System.Web.UI.ScriptManager.RegisterClientScriptInclude#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/scripts/script_alertdiv.js#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le fichier de script client <paramref name="type" /> est <see langword="null" />.  
  
ou 
Le contrôle qui inscrit le fichier de script est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le contrôle qui inscrit le fichier de script n'est pas dans l'arborescence du contrôle de la page.  
  
ou 
 <paramref name="url" /> est <see langword="null" />.  
  
ou 
 <paramref name="url" /> est vide.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Page page, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Page page, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (page, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit le fichier de script client.</param>
        <param name="type">Type du fichier de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour le fichier de script.</param>
        <param name="url">URL du fichier de script.</param>
        <summary>Inscrit le script client avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> chaque fois qu'une publication (postback) asynchrone a lieu, puis ajoute une référence de fichier de script à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous inscrivez un fichier de script avec cette méthode, le script est restitué chaque fois qu’une publication (postback) asynchrone se produit. Pour inscrire un fichier de script pour un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôler afin que le script est enregistré uniquement lorsque le <xref:System.Web.UI.UpdatePanel> contrôle est mis à jour, utilisez le <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un bloc de script qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le bloc de script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le fichier de script client <paramref name="type" /> est <see langword="null" />.  
  
ou 
La page qui inscrit le fichier de script est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> est <see langword="null" />.  
  
ou 
 <paramref name="url" /> est vide.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit le script client incorporé dans un assembly avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle qui participe au rendu de page partiel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Control * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (control, type, resourceName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit le script.</param>
        <param name="type">Type du script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="resourceName">Identificateur pour la ressource.</param>
        <summary>Inscrit le script client incorporé dans un assembly avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle qui participe au rendu de page partiel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> méthode pour inscrire un script qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Ressources de script qui sont inscrits à l’aide de cette méthode sont enregistrés uniquement lorsque `control` représente un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle est mis à jour. Pour inscrire un script chaque fois qu’une publication (postback) asynchrone se produit, utilisez le <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un bloc de script qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le bloc de script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> méthode est utilisée lorsque les ressources à partir des assemblys sont accessibles via un gestionnaire HTTP. Cette méthode inclut le contenu de l’URL de ressource dans un `script` élément.  
  
 À la fois le <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> et <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> méthode charger script des fichiers dans le navigateur. Si un script avec le même type et clé (pour un fichier de script) ou le même type et nom de ressource (pour une ressource incorporée) est déjà chargé, le script n’est pas rechargé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La ressource cliente <paramref name="type" /> est <see langword="null" />.  
  
ou 
Le contrôle qui inscrit le script est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le contrôle qui inscrit le script n'est pas dans l'arborescence du contrôle de la page.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Page page, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Page page, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Page ^ page, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Page * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (page, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit le script.</param>
        <param name="type">Type du script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="resourceName">Identificateur pour la ressource.</param>
        <summary>Inscrit un fichier de script client incorporé dans un assembly avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> chaque fois qu'une publication (postback) a lieu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous inscrivez un fichier de script avec cette méthode, le script est restitué chaque fois qu’une publication (postback) asynchrone se produit. Pour inscrire un script pour un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôler afin que le script est enregistré uniquement lorsque le <xref:System.Web.UI.UpdatePanel> contrôle est mis à jour, utilisez le <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un bloc de script qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le bloc de script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La ressource cliente <paramref name="type" /> est <see langword="null" />.  
  
ou 
La page qui inscrit le script est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterDataItem">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie des données personnalisées aux contrôles pendant le rendu de page partiel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui reçoit les données.</param>
        <param name="dataItem">Données envoyées au contrôle.</param>
        <summary>Envoie des données personnalisées à un contrôle pendant le rendu de page partiel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode pour envoyer des données à partir du serveur au client pendant les publications asynchrones, indépendamment de si le contrôle qui reçoit les données se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode peut être appelée uniquement pendant une publication (postback) asynchrone. Pour déterminer si une publication (postback) est asynchrone, utilisez la <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> propriété. Cette méthode appelle la surcharge qui accepte un paramètre nommé `isJsonSerialized` dont la valeur est `false`. Lorsque le `isJsonSerialized` paramètre est défini sur `false`, la chaîne n’est pas sérialisée au format JavaScript Objet Notation (JSON). Pour plus d’informations sur le format JSON, consultez le [présentation de JSON](https://go.microsoft.com/fwlink/?LinkId=77297) site Web.  
  
 Les éléments de données qui sont inscrits avec le <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode sont accessibles dans le script client lors de la `pageLoading`, `pageLoaded`, et `endRequest` événements de la `PageRequestManager` objet. Lorsque vous gérez ces événements, les données personnalisées sont passées dans un objet argument d’événement. Par exemple, si vous fournissez un gestionnaire pour le `pageLoading` événement, les données personnalisées sont passées dans le `PageLoadingEventArgs` (classe), qui expose une propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment envoyer des données à deux <xref:System.Web.UI.WebControls.Label> contrôles sur une page pendant une publication (postback) asynchrone. Le <xref:System.Web.UI.WebControls.Label> contrôles ne sont pas à l’intérieur un <xref:System.Web.UI.UpdatePanel> contrôle.  
  
> [!NOTE]
>  Les données sont envoyées dans cet exemple sont à titre d’illustration uniquement. Dans une application réelle, vous utiliseriez le <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode pour envoyer des données personnalisées à partir du serveur.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> est appelée lors d'une publication (postback).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" /> est déjà inscrit pour <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem, bool isJsonSerialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string * bool -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem, isJsonSerialized)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
        <Parameter Name="isJsonSerialized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle de page qui reçoit les données.</param>
        <param name="dataItem">Données envoyées au contrôle.</param>
        <param name="isJsonSerialized"><see langword="true" /> pour indiquer que <paramref name="dataItem" /> est sérialisé au format JSON ; sinon, <see langword="false" />.</param>
        <summary>Envoie des données personnalisées à un contrôle pendant le rendu de page partiel et indique si les données sont au format JSON (JavaScript Object Notation).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez le <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode pour envoyer des données à partir du serveur au client pendant les publications asynchrones, indépendamment de si le contrôle qui reçoit les données se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle.  
  
 Si le `dataItem` paramètre que vous inscrivez pour `control` n’est pas sérialisé au format JSON, définissez le `isJsonSerialized` paramètre `false`. Cela évite d’avoir à utiliser le `eval` (fonction) pour chaque chaîne envoyée au client. Pour plus d’informations sur le format JSON, consultez le [présentation de JSON](https://go.microsoft.com/fwlink/?LinkId=77297) site Web.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode peut être appelée uniquement pendant une publication (postback) asynchrone. Pour déterminer si une publication (postback) est asynchrone, utilisez la <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> propriété.  
  
 Les éléments de données qui sont inscrits à l’aide de la <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode sont accessibles dans le script client lors de la `pageLoading`, `pageLoaded`, et `endRequest` événements de la `PageRequestManager` objet. Lorsque vous gérez ces événements, les données personnalisées sont passées dans un objet argument d’événement. Par exemple, si vous fournissez un gestionnaire pour le `pageLoading` événement, les données personnalisées sont passées dans le `PageLoadingEventArgs` (classe), qui expose une propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment envoyer des données à deux <xref:System.Web.UI.WebControls.Label> contrôles sur une page pendant une publication (postback) asynchrone. Le <xref:System.Web.UI.WebControls.Label> contrôles ne sont pas à l’intérieur un <xref:System.Web.UI.UpdatePanel> contrôle. Cet exemple présente la surcharge qui n’accepte pas les `isJsonSerialized` paramètre. Sinon, la procédure de récupération le `dataItems` propriété de la `PageLoadingEventArgs` objet est le même que si vous n’utilisez pas cette surcharge.  
  
> [!NOTE]
>  Les données sont envoyées dans cet exemple sont à titre d’illustration uniquement. Dans une application réelle, vous utiliseriez le <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> méthode pour envoyer des données personnalisées à partir du serveur. Par exemple, vous pouvez utiliser l’élément de données pour envoyer des informations sur la nécessité masquer ou afficher des éléments qui ne sont pas à l’intérieur de client un <xref:System.Web.UI.UpdatePanel> contrôle.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> est appelée lors d'une publication (postback).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" /> est déjà inscrit pour <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDispose">
      <MemberSignature Language="C#" Value="public void RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript);" />
      <MemberSignature Language="F#" Value="member this.RegisterDispose : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDispose (control, disposeScript)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle auquel est destiné le script <see langword="dispose" />.</param>
        <param name="disposeScript">Script <see langword="dispose" />.</param>
        <summary>Inscrit un script <see langword="dispose" /> pour un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />. Le script est exécuté lorsque le contrôle <see cref="T:System.Web.UI.UpdatePanel" /> est mis à jour ou supprimé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> méthode enregistriez `dispose` scripts pour les contrôles qui se trouvent dans un <xref:System.Web.UI.UpdatePanel> contrôle. Pendant les publications asynchrones, <xref:System.Web.UI.UpdatePanel> contrôles peuvent être mis à jour, supprimées ou créés. Lorsqu’un panneau est mis à jour ou supprimé, tous `dispose` scripts qui sont inscrits pour les contrôles qui se trouvent dans le <xref:System.Web.UI.UpdatePanel> sont appelées. Dans les scénarios de développement de page typique, vous n’avez pas à appeler le <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> (méthode).  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> méthode est conçue pour une utilisation par les développeurs de contrôles pour enregistrer le script ou créer des contrôles qui héritent de la <xref:System.Web.UI.IScriptControl> interface. Par exemple, vous pouvez utiliser un `dispose` si vous développez un contrôle client en utilisant la composition de script. Dans votre contrôle, vous implémentez <xref:System.Web.UI.IScriptControl> et restituer les contrôles individuels. Vous inscrivez le `dispose` méthode de tout élément qui ne correspond pas à un composant client défini tel que `Sys.TextBox`. Si votre contrôle personnalisé compose des éléments qui correspondent aux composants clients de Microsoft Ajax Library, vous n’êtes pas obligé de s’inscrire un `dispose` de script, étant donné que `dispose` est appelé automatiquement. Par conséquent, utilisez le <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> méthode pour les composants clients qui font partie de Microsoft Ajax Library et qui ont libérer des ressources lorsqu’un composant n’est plus utilisé.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> méthode peut être appelée plusieurs fois pour un contrôle. Plusieurs scripts sont agrégés. L’ordre de suppression des scripts correspond à l’ordre dans lequel les scripts ont été enregistrés.  
  
 Si vous vous inscrivez un `dispose` script pour un contrôle qui n’est pas un <xref:System.Web.UI.UpdatePanel> contrôle, une exception est levée. Le `dispose` script est appelé entre le `pageLoading` et `pageLoaded` événements de la `PageRequestManager` classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="disposeScript" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />est introuvable sur la page.  
  
ou 
 <paramref name="control" /> n'est pas à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />.</exception>
        <altmember cref="T:System.Web.UI.IScriptControl" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public static void RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="static member RegisterExpandoAttribute : System.Web.UI.Control * string * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterExpandoAttribute (control, controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit l'attribut expando.</param>
        <param name="controlId">Contrôle qui contient l'attribut personnalisé sur la page.</param>
        <param name="attributeName">Nom de l'attribut personnalisé à inscrire.</param>
        <param name="attributeValue">Valeur de l'attribut personnalisé.</param>
        <param name="encode"><see langword="true" /> pour encoder l'attribut personnalisé inscrit ; sinon, <see langword="false" />.</param>
        <summary>Inscrit une paire nom/valeur avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> en tant qu'attribut personnalisé (expando) d'un contrôle spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> méthode pour inscrire une propriété personnalisé (expando) pour un contrôle qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> méthode inscrit une paire nom/valeur comme un attribut personnalisé pour le contrôle spécifié. La propriété est définie dynamiquement à partir d’ECMAScript (JavaScript) pour préserver la compatibilité XHTML pour le balisage du rendu du contrôle. Définissez `encode` à `true` si vous devez échapper des caractères dans la valeur de la propriété dynamique.  
  
 Si le contrôle auquel la propriété dynamique sera ajoutée est introuvable, une erreur de script se produit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> n'est pas dans l'arborescence du contrôle de la page.  
  
ou 
 <paramref name="controlId" /> est <see langword="null" />.  
  
ou 
 <paramref name="controlId" /> est vide.  
  
ou 
 <paramref name="attributeName" /> est <see langword="null" />.  
  
ou 
 <paramref name="attributeName" /> est vide.  
  
ou 
 <paramref name="attributeName" /> est déjà inscrit.</exception>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExtenderControl&lt;TExtenderControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterExtenderControl&lt;TExtenderControl&gt; (TExtenderControl extenderControl, System.Web.UI.Control targetControl) where TExtenderControl : System.Web.UI.Control, System.Web.UI.IExtenderControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterExtenderControl&lt;(class System.Web.UI.Control, class System.Web.UI.IExtenderControl) TExtenderControl&gt;(!!TExtenderControl extenderControl, class System.Web.UI.Control targetControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExtenderControl(Of TExtenderControl As {Control, IExtenderControl}) (extenderControl As TExtenderControl, targetControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TExtenderControl&gt;&#xA; where TExtenderControl : System::Web::UI::Control, System::Web::UI::IExtenderControl virtual void RegisterExtenderControl(TExtenderControl extenderControl, System::Web::UI::Control ^ targetControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)&#xA;override this.RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)" Usage="scriptManager.RegisterExtenderControl (extenderControl, targetControl)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterExtenderControl``1(``0,System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TExtenderControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IExtenderControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="extenderControl" Type="TExtenderControl" />
        <Parameter Name="targetControl" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <typeparam name="TExtenderControl">Contrôle qui implémente l'interface <see cref="T:System.Web.UI.IExtenderControl" />.</typeparam>
        <param name="extenderControl">Contrôle d'extendeur à inscrire.</param>
        <param name="targetControl">Contrôle de script que le contrôle d'extendeur étend.</param>
        <summary>Inscrit un contrôle d'extendeur avec l'instance <see cref="T:System.Web.UI.ScriptManager" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est principalement destiné aux développeurs de contrôles. Appelez le <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> méthode à partir d’un contrôle d’extendeur ASP.NET Ajax personnalisé pendant son `onInit` Gestionnaire d’événements pour inscrire ce contrôle avec la page. Un contrôle d’extendeur ASP.NET Ajax doit être inscrit pour participer au rendu de page partiel.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> méthode ajoute le contrôle d’extendeur spécifié à une liste interne de contrôles d’extendeur et les contrôles de script cibles qu’ils étendent. Cette liste est traitée pendant la <xref:System.Web.UI.Control.PreRender> événement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extenderControl" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="targetControl" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterHiddenField">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un champ masqué.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (control, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit le champ masqué.</param>
        <param name="hiddenFieldName">Nom du champ masqué à inscrire</param>
        <param name="hiddenFieldInitialValue">Valeur initiale du champ masqué.</param>
        <summary>Inscrit un champ masqué avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour un contrôle situé à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> méthode pour inscrire un champ masqué qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Cette méthode inscrit le champ masqué lorsque le contrôle qui inscrit le champ se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle qui est en cours de mise à jour. Pour inscrire un champ masqué chaque fois qu’une publication (postback) asynchrone se produit, utilisez le <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un champ masqué qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le champ masqué qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> méthode crée une zone masquée `input` élément sur la page HTML rendue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="hiddenFieldName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> n'est pas dans l'arborescence du contrôle de la page.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Page ^ page, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (page, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit le champ masqué.</param>
        <param name="hiddenFieldName">Nom du champ masqué à inscrire</param>
        <param name="hiddenFieldInitialValue">Valeur initiale du champ masqué.</param>
        <summary>Inscrit un champ masqué avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pendant chaque publication (postback) asynchrone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> méthode pour inscrire un champ masqué qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Cette méthode inscrit le champ masqué chaque fois qu’une publication (postback) asynchrone se produit. Pour inscrire un champ masqué pour un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôler afin que le champ soit inscrit uniquement lorsque le panneau est mis à jour, utilisez le <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire un champ masqué qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez inscrire le champ masqué qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="hiddenFieldName" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterNamedClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit le script client par nom de ressource, incorporé dans un assembly avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle qui participe au rendu de page partiel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Control control, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Control control, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Control ^ control, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Control * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (control, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit le script.</param>
        <param name="resourceName">Identificateur pour la ressource.</param>
        <summary>Inscrit le script client par nom de ressource, incorporé dans un assembly avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle qui participe au rendu de page partiel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Page page, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Page page, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Page,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Page ^ page, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Page * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (page, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit le script.</param>
        <param name="resourceName">Identificateur pour la ressource.</param>
        <summary>Inscrit le script client par nom de ressource, incorporé dans un assembly avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour une utilisation avec un contrôle qui participe au rendu de page partiel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterOnSubmitStatement">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit le code ECMAScript (JavaScript) exécuté lorsque le formulaire est envoyé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (control, type, key, script)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit l'instruction <see langword="onsubmit" />.</param>
        <param name="type">Type de l'instruction de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour l'instruction de script.</param>
        <param name="script">Le script à inscrire.</param>
        <summary>Inscrit le code ECMAScript (JavaScript) avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour un contrôle utilisé avec un contrôle <see cref="T:System.Web.UI.UpdatePanel" /> exécuté lorsque le formulaire est envoyé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> ajoute un script qui est exécuté avant que le formulaire est envoyé, qui vous permet de modifier l’envoi ou de l’annuler.  
  
 Vous utilisez le <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> méthode pour restituer un `onsubmit` instruction qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Le code JavaScript qui est inscrit à l’aide de cette méthode est envoyé à la page uniquement lorsque le contrôle qui inscrit l’instruction se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôle qui est en cours de mise à jour. Pour inscrire le code avec chaque publication (postback) asynchrone, utilisez la <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire du code JavaScript qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez enregistrer le code qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 Le *script* paramètre de la <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> méthode peut contenir plusieurs commandes de script qui sont délimitées par des points-virgules ( ;).  
  
 Pour plus d’informations sur les formulaires HTML et le `onsubmit` événement, consultez le [site Web du World Wide Web Consortium (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> n'est pas dans l'arborescence du contrôle de la page.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Page page, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Page page, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (page, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit l'instruction <see langword="onsubmit" />.</param>
        <param name="type">Type de l'instruction de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour l'instruction de script.</param>
        <param name="script">Le script à inscrire.</param>
        <summary>Inscrit le code ECMAScript (JavaScript) avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> pour un contrôle utilisé avec un contrôle <see cref="T:System.Web.UI.UpdatePanel" /> exécuté lorsque le formulaire est envoyé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’inscription du code JavaScript avec cette méthode provoque le script à inclure chaque fois qu’une publication (postback) asynchrone se produit.  
  
> [!NOTE]
>  Code à partir de n’importe quel publications (postback) asynchrones antérieures n’est pas supprimé. Nouvelles publications asynchrones ajoutent le code à tout code existant pour le `onsubmit` instruction.  
  
 Pour inscrire du code pour un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôler afin que le code est inscrit uniquement lorsque le <xref:System.Web.UI.UpdatePanel> contrôle est mis à jour, utilisez le <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> surcharge de cette méthode.  
  
 Si vous souhaitez inscrire du code JavaScript qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez enregistrer le code qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="type" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle à inscrire pour la publication (postback).</param>
        <summary>Inscrit un contrôle comme déclencheur pour une publication (postback). Cette méthode est utilisée pour configurer des contrôles de publication (postback)à l'intérieur d'un contrôle <see cref="T:System.Web.UI.UpdatePanel" /> qui, sinon, exécuterait des publications (postback) asynchrones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A> méthode pour inscrire des contrôles de publication (postback) à l’intérieur d’un <xref:System.Web.UI.UpdatePanel> contrôle en tant que déclencheurs. Les contrôles qui sont inscrits à l’aide de cette méthode mettent à jour une page entière au lieu de la mise à jour uniquement la <xref:System.Web.UI.UpdatePanel> contenu du contrôle. L’inscription d’un contrôle de publication (postback) avec cette méthode à l’extérieur un <xref:System.Web.UI.UpdatePanel> contrôle n’a aucun effet, car par défaut, ces contrôles n’exécutent pas de publications (postback) asynchrone.  
  
 Vous pouvez ajouter le déclencheur de façon déclarative à l’aide de la `Triggers` élément de la <xref:System.Web.UI.UpdatePanel> contrôle. Dans Visual Studio, utilisez le concepteur **éditeur de collections UpdatePanelTrigger** boîte de dialogue.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptControl&lt;TScriptControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterScriptControl&lt;TScriptControl&gt; (TScriptControl scriptControl) where TScriptControl : System.Web.UI.Control, System.Web.UI.IScriptControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptControl&lt;(class System.Web.UI.Control, class System.Web.UI.IScriptControl) TScriptControl&gt;(!!TScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptControl(Of TScriptControl As {Control, IScriptControl}) (scriptControl As TScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TScriptControl&gt;&#xA; where TScriptControl : System::Web::UI::Control, System::Web::UI::IScriptControl virtual void RegisterScriptControl(TScriptControl scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)&#xA;override this.RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)" Usage="scriptManager.RegisterScriptControl scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptControl``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TScriptControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IScriptControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="scriptControl" Type="TScriptControl" />
      </Parameters>
      <Docs>
        <typeparam name="TScriptControl">Contrôle qui implémente l'interface <see cref="T:System.Web.UI.IScriptControl" />.</typeparam>
        <param name="scriptControl">Contrôle de script à inscrire.</param>
        <summary>Inscrit un contrôle de script avec l'instance <see cref="T:System.Web.UI.ScriptManager" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est principalement destiné aux développeurs de contrôles. Appelez le <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> méthode à partir d’un contrôle de script ASP.NET Ajax personnalisé pendant son `onInit` Gestionnaire d’événements pour inscrire ce contrôle avec la page. Un contrôle de script ASP.NET Ajax doit être inscrit pour participer au rendu de page partiel.  
  
 Le <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> méthode ajoute le contrôle d’extendeur spécifié à une liste interne de contrôles de script qui est traité pendant la <xref:System.Web.UI.Control.PreRender> événement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scriptControl" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterScriptDescriptors">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Demande au contrôle <see cref="T:System.Web.UI.ScriptManager" /> de rappeler les classes <see cref="T:System.Web.UI.ScriptControl" /> ou <see cref="T:System.Web.UI.ExtenderControl" /> pour retourner les scripts qui prennent en charge l’objet client représentant un contrôle client, un composant ou un comportement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IExtenderControl extenderControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IExtenderControl extenderControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (extenderControl As IExtenderControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IExtenderControl ^ extenderControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors extenderControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extenderControl" Type="System.Web.UI.IExtenderControl" />
      </Parameters>
      <Docs>
        <param name="extenderControl">Contrôle d'extendeur pour lequel des descripteurs de script seront inscrits.</param>
        <summary>Rappelle une classe <see cref="T:System.Web.UI.ExtenderControl" /> pour retourner des scripts d'instance qui doivent être restitués pour prendre en charge l'objet client représentant un contrôle client, un composant ou un comportement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ExtenderControl> classe appelle le <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> méthode dans son <xref:System.Web.UI.Control.Render%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous dérivez de la <see cref="T:System.Web.UI.ExtenderControl" /> classe et substituer les <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> (méthode), mais vous n’appelez pas la méthode de classe de base, vous devez appeler la <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" /> (méthode). Cela permet la <see cref="T:System.Web.UI.ScriptManager" /> contrôle à rendre les scripts d’instance qui prennent en charge l’objet client qui représente le contrôle.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IScriptControl scriptControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (scriptControl As IScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IScriptControl ^ scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IScriptControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptControl" Type="System.Web.UI.IScriptControl" />
      </Parameters>
      <Docs>
        <param name="scriptControl">Contrôle de script pour lequel des descripteurs de script seront inscrits.</param>
        <summary>Appelle une classe <see cref="T:System.Web.UI.ScriptControl" /> pour retourner des scripts d'instance qui doivent être restitués pour prendre en charge l'objet client représentant un contrôle client, un composant ou un comportement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptControl> classe appelle le <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> méthode pendant son <xref:System.Web.UI.Control.Render%2A> événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous dérivez de la <see cref="T:System.Web.UI.ScriptControl" /> classe et substituer les <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> (méthode), mais vous n’appelez pas la méthode de classe de base, vous devez appeler la <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" /> (méthode). Cela permet la <see cref="T:System.Web.UI.ScriptManager" /> contrôle à rendre les scripts d’instance qui prennent en charge l’objet client qui représente le contrôle.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un bloc de script de démarrage avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> et ajoute le bloc de script à la page.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui inscrit le bloc de script client.</param>
        <param name="type">Type du bloc de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour le bloc de script.</param>
        <param name="script">Le script à inscrire.</param>
        <param name="addScriptTags"><see langword="true" /> pour mettre le bloc de script entre des balises <see langword="&lt;script&gt;" /> et <see langword="&lt;/script&gt;" /> ; sinon, <see langword="false" />.</param>
        <summary>Inscrit un bloc de script de démarrage pour un contrôle situé à l'intérieur d'un <see cref="T:System.Web.UI.UpdatePanel" /> en utilisant le contrôle <see cref="T:System.Web.UI.ScriptManager" />, et ajoute le bloc de script à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez la <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> méthode pour inscrire un bloc de script de démarrage pour une page qui est compatible avec le rendu de page partiel et qui n’a aucune dépendance de Microsoft Ajax Library. Les blocs de script de démarrage qui sont inscrits à l’aide de cette méthode sont envoyés à la page uniquement lorsque le contrôle qui inscrit le bloc est à l’intérieur d’un <xref:System.Web.UI.UpdatePanel> contrôle qui est en cours de mise à jour. Pour inscrire un bloc de script de démarrage à chaque fois qu’une publication (postback) asynchrone se produit, utilisez le <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de cette méthode.  
  
 Si vous souhaitez enregistrer un script de démarrage qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez enregistrer le script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 Le bloc de script qui est restitué par le <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> méthode s’exécute lors de la fin du chargement de la page, mais avant les clients de la page `onload` événement est déclenché. Blocs de script de démarrage se trouvent en bas de la page ASP.NET rendue juste avant le `</form>` balise.  
  
 Les blocs de script de démarrage qui sont inscrits à l’aide de <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> n’est pas garanti pour être généré dans le même ordre que celui dans lequel ils sont inscrits. Si l’ordre des blocs de script de démarrage est important, utilisez un <xref:System.Text.StringBuilder> objet pour rassembler les blocs de script dans une chaîne unique, puis inscrivez-les tous sous un script de démarrage unique.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> n'est pas dans l'arborescence du contrôle de la page.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">Objet page qui inscrit le bloc de script client.</param>
        <param name="type">Type du bloc de script client. Ce paramètre est généralement spécifié en utilisant l'opérateur typeof (C#) ou l'opérateur GetType (Visual Basic) pour récupérer le type du contrôle qui inscrit le script.</param>
        <param name="key">Identificateur unique pour le bloc de script.</param>
        <param name="script">Le script à inscrire.</param>
        <param name="addScriptTags"><see langword="true" /> pour mettre le bloc de script entre des balises <see langword="&lt;script&gt;" /> et <see langword="&lt;/script&gt;" /> ; sinon, <see langword="false" />.</param>
        <summary>Inscrit un bloc de script de démarrage pour chaque publication (postback) asynchrone avec le contrôle <see cref="T:System.Web.UI.ScriptManager" /> et ajoute le bloc de script à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez cette méthode pour inscrire un bloc de script de démarrage qui est inclus chaque fois qu’une publication (postback) asynchrone se produit. Pour inscrire un bloc de script pour un contrôle qui se trouve dans un <xref:System.Web.UI.UpdatePanel> contrôler afin que le bloc de script est enregistré uniquement lorsque le <xref:System.Web.UI.UpdatePanel> contrôle est mis à jour, utilisez le <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de cette méthode.  
  
 Si vous souhaitez enregistrer un script de démarrage qui ne pas se rapportent aux mises à jour de page partielle et si vous souhaitez enregistrer le script qu’une seule fois pendant le rendu de page initial, utilisez la <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> méthode de la <xref:System.Web.UI.ClientScriptManager> classe. Vous pouvez obtenir une référence à la <xref:System.Web.UI.ClientScriptManager> de l’objet à partir de la <xref:System.Web.UI.Page.ClientScript%2A> propriété de la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="scriptManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet qui reçoit le contenu du contrôle à écrire sur la page.</param>
        <summary>Restitue le contenu du contrôle <see cref="T:System.Web.UI.ScriptManager" /> dans le navigateur à l'aide de l'objet <see cref="T:System.Web.UI.HtmlTextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée par les développeurs de contrôles pour étendre le <xref:System.Web.UI.ScriptManager> contrôle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous substituez cette méthode, appelez la base de <see cref="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" /> méthode afin que le script client qui définit la `Sys.WebForms.PageRequestManager` classe est rendue sur la page.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveCompositeScriptReference As EventHandler(Of CompositeScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::CompositeScriptReferenceEventArgs ^&gt; ^ ResolveCompositeScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveCompositeScriptReference : EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " Usage="member this.ResolveCompositeScriptReference : System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un script composite est inscrit auprès du contrôle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveScriptReference As EventHandler(Of ScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::ScriptReferenceEventArgs ^&gt; ^ ResolveScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveScriptReference : EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " Usage="member this.ResolveScriptReference : System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un membre de la collection <see cref="P:System.Web.UI.ScriptManager.Scripts" /> est inscrit avec le contrôle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché une fois pour chaque membre de la <xref:System.Web.UI.ScriptManager.Scripts%2A> collection lors de la page <xref:System.Web.UI.Control.PreRender> événement. Utilisez cet événement pour effectuer des mises à jour avant que le script est rendu à la page.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleService">
      <MemberSignature Language="C#" Value="public System.Web.UI.RoleServiceManager RoleService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.RoleServiceManager RoleService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.RoleService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RoleService As RoleServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::RoleServiceManager ^ RoleService { System::Web::UI::RoleServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RoleService : System.Web.UI.RoleServiceManager" Usage="System.Web.UI.ScriptManager.RoleService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.RoleServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.UI.RoleServiceManager" /> associé à l'instance <see cref="T:System.Web.UI.ScriptManager" /> actuelle.</summary>
        <value>Objet <see cref="T:System.Web.UI.RoleServiceManager" /> pour l'instance <see cref="T:System.Web.UI.ScriptManager" /> actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.RoleServiceManager> objet qui est retourné par cette propriété représente le service de rôle qui est enregistré avec la page. Le service de rôle peut être défini dans le <xref:System.Web.UI.ScriptManager> contrôle ou un associé <xref:System.Web.UI.ScriptManagerProxy> contrôle. Vous pouvez utiliser le service de rôle ASP.NET ou un service de rôle personnalisé. Vous pouvez ajouter le service personnalisé dans le balisage en incluant un `RoleService` élément à l’intérieur du `asp:ScriptManager` élément sur la page, comme indiqué dans l’exemple suivant :  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <RoleService Path="MyRoleService.asmx" LoadRoles="True" />  
</asp:ScriptManager>  
```  
  
 Vous pouvez également configurer par programme le <xref:System.Web.UI.RoleServiceManager> objet. Les services sont enregistrés avec le <xref:System.Web.UI.ScriptManager> contrôle lors de la page <xref:System.Web.UI.Control.PreRender> phase du cycle de vie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptMode ScriptMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ScriptMode ScriptMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptMode As ScriptMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptMode ScriptMode { System::Web::UI::ScriptMode get(); void set(System::Web::UI::ScriptMode value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptMode : System.Web.UI.ScriptMode with get, set" Usage="System.Web.UI.ScriptManager.ScriptMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si les versions Debug ou Release des bibliothèques de scripts clients sont restituées.</summary>
        <value>Valeur d'énumération qui indique le mode en cours. La valeur par défaut est <see cref="F:System.Web.UI.ScriptMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriété spécifie si le <xref:System.Web.UI.ScriptManager> contrôle doit rendre le débogage ou publier des versions de bibliothèques de scripts clients. Cette valeur peut être remplacée par les valeurs qui sont définies dans le fichier de configuration et dans la directive de page.  
  
 Le tableau suivant répertorie les valeurs valides pour cette propriété.  
  
|Value|Définition|  
|-----------|----------------|  
|<xref:System.Web.UI.ScriptMode.Auto>|Versions de débogage des scripts clients bibliothèques sont utilisées dans la page Web lorsque le `retail` attribut de la [déploiement](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) élément de configuration est définie sur `false`. Sinon, les versions release des bibliothèques de scripts clients sont utilisées.|  
|<xref:System.Web.UI.ScriptMode.Inherit>|Lorsqu’il est appliqué à la <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriété de la <xref:System.Web.UI.ScriptManager> de l’objet, cette valeur est identique à <xref:System.Web.UI.ScriptMode.Auto>.|  
|<xref:System.Web.UI.ScriptMode.Debug>|Versions de débogage des scripts clients bibliothèques sont utilisées dans la page Web, sauf si le `retail` attribut de la [déploiement](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) élément de configuration est définie sur `true`.|  
|<xref:System.Web.UI.ScriptMode.Release>|Versions Release des bibliothèques de scripts clients sont utilisées dans la page Web, sauf si le `retail` attribut de la [déploiement](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) élément de configuration est définie sur `false`.|  
  
> [!NOTE]
>  Le `debug` attribut de la [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) directive n’affecte pas les applications ASP.NET compatibles Ajax. Le <xref:System.Web.UI.ScriptManager> contrôle utilise uniquement les paramètres dans le fichier Web.config et dans ses <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> et <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriétés pour déterminer s’il faut restituer des scripts de débogage.  
  
 Pour plus d’informations, consultez [débogage et le suivi de la vue d’ensemble des Applications Ajax](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La propriété <see cref="P:System.Web.UI.ScriptManager.ScriptMode" /> ne fait pas partie des valeurs <see cref="T:System.Web.UI.ScriptMode" />.</exception>
        <altmember cref="T:System.Web.UI.ScriptMode" />
      </Docs>
    </Member>
    <Member MemberName="ScriptPath">
      <MemberSignature Language="C#" Value="public string ScriptPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScriptPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptPath" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ScriptPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptPath : string with get, set" Usage="System.Web.UI.ScriptManager.ScriptPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. Set the Path property on each individual ScriptReference instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le chemin d'accès racine de l'emplacement utilisé pour générer les chemins d'accès aux fichiers de script personnalisés et ASP.NET Ajax.</summary>
        <value>Emplacement où les fichiers de script sont stockés. La valeur par défaut est une chaîne vide (""), interprétée comme un chemin d'accès relatif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.ScriptPath%2A> propriété vous permet de spécifier un absolu, relatif, ou d’URL relatif à l’application script tous les blocs sur la page. Cela inclut les blocs de script personnalisés et tiers inscrits avec actuel <xref:System.Web.UI.ScriptManager> instance. Le <xref:System.Web.UI.ScriptManager.ScriptPath%2A> propriété est généralement définie de manière déclarative en tant qu’attribut d’un `ScriptManager` élément sur la page, mais il peut être définie dans le code.  
  
 Si le `path` attribut ou le <xref:System.Web.UI.ScriptReferenceBase.Path%2A> propriété est définie pour un <xref:System.Web.UI.ScriptReference> de l’objet dans le <xref:System.Web.UI.ScriptManager.Scripts%2A> collection, la valeur de chemin d’accès remplace le <xref:System.Web.UI.ScriptManager.ScriptPath%2A> valeur pour ce <xref:System.Web.UI.ScriptReference> instance.  
  
 Si aucun <xref:System.Web.UI.ScriptReferenceBase.Path%2A> valeur est spécifiée, le <xref:System.Web.UI.ScriptManager> contrôle de recherche dans le répertoire qui est défini par le <xref:System.Web.UI.ScriptManager.ScriptPath%2A> références de script de propriété et le résout par leurs <xref:System.Web.UI.ScriptReference.Name%2A> ou <xref:System.Web.UI.ScriptReference.Assembly%2A> propriétés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptResourceMapping">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptResourceMapping ScriptResourceMapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.UI.ScriptResourceMapping ScriptResourceMapping" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScriptResourceMapping As ScriptResourceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::UI::ScriptResourceMapping ^ ScriptResourceMapping { System::Web::UI::ScriptResourceMapping ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScriptResourceMapping : System.Web.UI.ScriptResourceMapping" Usage="System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptResourceMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Web.UI.ScriptResourceMapping" />.</summary>
        <value>Objet <see cref="T:System.Web.UI.ScriptResourceMapping" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode statique <xref:System.Web.UI.ScriptManager.ScriptResourceMapping%2A> propriété retourne un <xref:System.Web.UI.ScriptResourceMapping> objet qui peut contenir une collection de mappages représentant l’emplacement de la ressource de script (redirection de script). Cette collection de mappages peut être mappée à des noms ou les paires nom / d’assembly, et il peut pointer vers un <xref:System.Web.UI.ScriptResourceDefinition> objet.  
  
   
  
## Examples  
 Les exemples suivants montrent comment ajouter un <xref:System.Web.UI.ScriptResourceDefinition> objet qui peut être référencé par un <xref:System.Web.UI.ScriptManager> objet. Ajoutez le code suivant au fichier Global.asax dans le `Application_Start` événement.  
  
```csharp  
ScriptResourceDefinition myScriptResDef = new ScriptResourceDefinition();  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js";  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js";  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js";  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js";  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", null, myScriptResDef);  
```  
  
```vb  
Dim myScriptResDef As New ScriptResourceDefinition()  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js"  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js"  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js"  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js"  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", Nothing, myScriptResDef)  
```  
  
 Dans le balisage d’une page Web Forms ASP.NET (fichier .aspx), ajoutez le balisage suivant à l’intérieur du `form` élément et avant les éléments ou d’un code qui utilise un script de jQuery.  
  
```  
<asp:ScriptManager ID="sm1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="jquery"/>  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scripts">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptReferenceCollection Scripts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ScriptReferenceCollection Scripts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Scripts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scripts As ScriptReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptReferenceCollection ^ Scripts { System::Web::UI::ScriptReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scripts : System.Web.UI.ScriptReferenceCollection" Usage="System.Web.UI.ScriptManager.Scripts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Web.UI.ScriptReferenceCollection" /> qui contient les objets <see cref="T:System.Web.UI.ScriptReference" />, chacun représentant un fichier de script restitué au client.</summary>
        <value>Objet <see cref="T:System.Web.UI.ScriptReferenceCollection" /> de l'instance <see cref="T:System.Web.UI.ScriptManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptReferenceCollection> objet qui est retourné par cette propriété est une collection de <xref:System.Web.UI.ScriptReference> objets, chacun d’eux représente un fichier de script. La collection inclut des références à tous les fichiers de script ASP.NET a besoin pour les fonctionnalités Ajax et aux fichiers de script personnalisé. Fichiers de script personnalisé pour effectuer le rendu peuvent être définis dans le <xref:System.Web.UI.ScriptManager> contrôle ou un associé <xref:System.Web.UI.ScriptManagerProxy> contrôle.  
  
 Vous pouvez ajouter des fichiers de script à la collection dans le balisage en ajoutant `asp:ScriptReference` éléments à un `Scripts` nœud à l’intérieur du `asp:ScriptManager` élément sur la page, comme indiqué dans l’exemple suivant.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="Script.js" />  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 Vous pouvez également ajouter un <xref:System.Web.UI.ScriptReference> de l’objet à la <xref:System.Web.UI.ScriptManager.Scripts%2A> collection par programmation à l’aide la <xref:System.Collections.ObjectModel.Collection%601.Add%2A> méthode de la <xref:System.Web.UI.ScriptReferenceCollection> classe.  
  
 Le <xref:System.Web.UI.ScriptManager> contrôle enregistre les fichiers de script lors du contrôle <xref:System.Web.UI.Control.PreRender> événement.  
  
 Le <xref:System.Web.UI.ScriptManager.Scripts%2A> collection ne contient pas les scripts de Microsoft Ajax Library core. Les scripts dans la bibliothèque principale sont restitués automatiquement ; ils n’ont pas à inscrire avec le <xref:System.Web.UI.ScriptManager> contrôle. Toutefois, si vous souhaitez remplacer un script principal ou un script de contrôle et la remplacer par une autre version du script, vous pouvez ajouter votre version à la <xref:System.Web.UI.ScriptManager.Scripts%2A> collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public System.Web.UI.ServiceReferenceCollection Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ServiceReferenceCollection Services" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Services" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Services As ServiceReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ServiceReferenceCollection ^ Services { System::Web::UI::ServiceReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Services : System.Web.UI.ServiceReferenceCollection" Usage="System.Web.UI.ScriptManager.Services" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.ServiceReferenceCollectionEditor, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ServiceReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Web.UI.ServiceReferenceCollection" /> qui contient un objet <see cref="T:System.Web.UI.ServiceReference" /> pour chaque service Web qu'ASP.NET expose sur le client pour les fonctionnalités Ajax.</summary>
        <value>Objet <see cref="T:System.Web.UI.ServiceReferenceCollection" /> pour l'instance <see cref="T:System.Web.UI.ScriptManager" /> actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ServiceReferenceCollection> objet qui est retourné par cette propriété est une collection de <xref:System.Web.UI.ServiceReference> objets, chacun d’eux représente un service Web qui est inscrit avec le <xref:System.Web.UI.ScriptManager> contrôle. Vous pouvez définir des services dans le <xref:System.Web.UI.ScriptManager> contrôle ou un associé <xref:System.Web.UI.ScriptManagerProxy> contrôle.  
  
 Vous pouvez ajouter des services à la collection dans le balisage en ajoutant un `asp:ServiceReference` élément à un `Services` élément à l’intérieur du `asp:ScriptManager` d’instance sur la page, comme indiqué dans l’exemple suivant.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Services>  
    <asp:ServiceReference Path="Service.asmx" />  
  </Services>  
</asp:ScriptManager>  
```  
  
 Vous pouvez également ajouter par programme un <xref:System.Web.UI.ServiceReference> de l’objet à la <xref:System.Web.UI.ScriptManager.Services%2A> collection à l’aide de la <xref:System.Collections.ObjectModel.Collection%601.Add%2A> méthode de la <xref:System.Web.UI.ServiceReferenceCollection> classe.  
  
 Les services sont enregistrés avec le <xref:System.Web.UI.ScriptManager> lors de la page <xref:System.Web.UI.Control.PreRender> phase du cycle de vie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Affecte au focus du navigateur le contrôle spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="scriptManager.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">ID du contrôle devant recevoir le focus.</param>
        <summary>Affecte au focus du navigateur le contrôle spécifié par ID.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.SetFocus%2A> méthode fonctionne comme le <xref:System.Web.UI.Page.SetFocus%2A> méthode pour la <xref:System.Web.UI.Page> classe. Les deux méthodes rendre le contrôle avec l’ID spécifié le contrôle actif sur la page Web. Le <xref:System.Web.UI.ScriptManager.SetFocus%2A> méthode de la <xref:System.Web.UI.ScriptManager> classe est utilisée pour définir le focus pendant une publication (postback) asynchrone. Pendant les publications et lorsque la page est restituée en premier, le <xref:System.Web.UI.ScriptManager.SetFocus%2A> les appels de méthode le <xref:System.Web.UI.Page.SetFocus%2A> méthode de la <xref:System.Web.UI.Page> classe.  
  
 S’il existe plusieurs appels à la <xref:System.Web.UI.ScriptManager.SetFocus%2A> (méthode), le contrôle dans le dernier appel reçoit le focus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.String)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="scriptManager.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle devant recevoir le focus.</param>
        <summary>Affecte au focus du navigateur le contrôle spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.ScriptManager.SetFocus%2A> méthode fonctionne comme le <xref:System.Web.UI.Page.SetFocus%2A> méthode pour la <xref:System.Web.UI.Page> classe. Les deux méthodes rendre le contrôle spécifié le contrôle actif sur la page Web. Le <xref:System.Web.UI.ScriptManager.SetFocus%2A> méthode de la <xref:System.Web.UI.ScriptManager> classe est utilisée pour définir le focus pendant une publication (postback) asynchrone. Pendant les publications et lorsque la page est restituée en premier, le <xref:System.Web.UI.ScriptManager.SetFocus%2A> les appels de méthode le <xref:System.Web.UI.Page.SetFocus%2A> méthode de la <xref:System.Web.UI.Page> classe.  
  
 S’il existe plusieurs appels à la <xref:System.Web.UI.ScriptManager.SetFocus%2A> (méthode), le contrôle spécifié dans le dernier appel reçoit le focus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SupportsPartialRendering">
      <MemberSignature Language="C#" Value="public bool SupportsPartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property SupportsPartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsPartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SupportsPartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le client prend en charge le rendu de page partiel.</summary>
        <value><see langword="true" /> si le client prend en charge le rendu de page partiel ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriété est définie sur `false`, le <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> retourne de la propriété `false`.  
  
 Retourne la vérification par défaut pour déterminer si le rendu de page partielle est prise en charge `true` lorsque les conditions suivantes sont remplies :  
  
-   Le <xref:System.Web.Configuration.HttpCapabilitiesBase.W3CDomVersion%2A> valeur de propriété doit être supérieur ou égal à 1,0.  
  
-   Le <xref:System.Web.Configuration.HttpCapabilitiesBase.EcmaScriptVersion%2A> valeur de propriété doit être supérieur ou égal à 1,0.  
  
-   Le <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> valeur de propriété doit être définie sur `true`.  
  
 Lorsque le <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> est explicitement définie, ces contrôles ne sont pas utilisés.  
  
 Les développeurs de contrôles doivent utiliser le <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriété afin de déterminer si elles doivent prendre en charge le rendu de page partiel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> est <see langword="false" /> et la propriété <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> avait la valeur <see langword="true" />.  
  
ou 
La propriété <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> a été définie après l'événement <see cref="E:System.Web.UI.Control.Init" />.</exception>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.LoadPostData">
      <MemberSignature Language="C#" Value="bool IPostBackDataHandler.LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IPostBackDataHandler.LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean Implements IPostBackDataHandler.LoadPostData" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IPostBackDataHandler.LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection) = System::Web::UI::IPostBackDataHandler::LoadPostData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">Identificateur de clé pour le contrôle.</param>
        <param name="postCollection">Collection de toutes les données de publication (postback) entrantes.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />.</summary>
        <returns><see langword="true" /> si l'état du contrôle <see cref="T:System.Web.UI.ScriptManager" /> a été modifié à la suite d'une publication (postback) ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.ScriptManager> est castée en interface <xref:System.Web.UI.IPostBackDataHandler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="void IPostBackDataHandler.RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostDataChangedEvent () Implements IPostBackDataHandler.RaisePostDataChangedEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() = System::Web::UI::IPostBackDataHandler::RaisePostDataChangedEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.ScriptManager> est castée en interface <xref:System.Web.UI.IPostBackDataHandler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackEventHandler.RaisePostBackEvent">
      <MemberSignature Language="C#" Value="void IPostBackEventHandler.RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackEventHandler#RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostBackEvent (eventArgument As String) Implements IPostBackEventHandler.RaisePostBackEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System::String ^ eventArgument) = System::Web::UI::IPostBackEventHandler::RaisePostBackEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Chaîne de paires clé/valeur qui représentent l'état de l'historique de la page Web.</param>
        <summary>Permet au contrôle <see cref="T:System.Web.UI.ScriptManager" /> de traiter un événement de publication (postback) et de charger l'état de l'historique de la page Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.IsSecureConnection">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IScriptManager.IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSecureConnection As Boolean Implements IScriptManager.IsSecureConnection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IScriptManager::IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsSecureConnection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue) = System::Web::UI::IScriptManager::RegisterArrayDeclaration;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="arrayName">To be added.</param>
        <param name="arrayValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterClientScriptBlock;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url) = System::Web::UI::IScriptManager::RegisterClientScriptInclude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="url">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName) = System::Web::UI::IScriptManager::RegisterClientScriptResource;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="resourceName">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterDispose">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript) = System::Web::UI::IScriptManager::RegisterDispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="disposeScript">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode) = System::Web::UI::IScriptManager::RegisterExpandoAttribute;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="controlId">To be added.</param>
        <param name="attributeName">To be added.</param>
        <param name="attributeValue">To be added.</param>
        <param name="encode">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterHiddenField">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldValue) = System::Web::UI::IScriptManager::RegisterHiddenField;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="hiddenFieldName">To be added.</param>
        <param name="hiddenFieldValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script) = System::Web::UI::IScriptManager::RegisterOnSubmitStatement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterPostBackControl">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterPostBackControl(System::Web::UI::Control ^ control) = System::Web::UI::IScriptManager::RegisterPostBackControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterStartupScript">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterStartupScript;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.SetFocusInternal">
      <MemberSignature Language="C#" Value="void IScriptManager.SetFocusInternal (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.SetFocusInternal(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#SetFocusInternal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetFocusInternal (clientID As String) Implements IScriptManager.SetFocusInternal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.SetFocusInternal(System::String ^ clientID) = System::Web::UI::IScriptManager::SetFocusInternal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.SetFocusInternal(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.ScriptManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitue la propriété <see cref="P:System.Web.UI.Control.Visible" /> héritée de la classe <see cref="T:System.Web.UI.Control" /> de base pour empêcher la définition de cette valeur.</summary>
        <value><see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.Visible%2A> est substituée dans les <xref:System.Web.UI.ScriptManager> classe pour empêcher la définition de cette valeur. Un <xref:System.NotImplementedException> erreur se produit si une valeur est assignée à cette propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">La valeur est assignée à la propriété <see cref="P:System.Web.UI.ScriptManager.Visible" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>