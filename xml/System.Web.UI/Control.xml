<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7957558cb41b15a9b4654d04fe4d9d12fe89efa5" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66005977" /></Metadata><TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IParserAccessor&#xA;    interface IUrlResolutionService&#xA;    interface IDataBindingsAccessor&#xA;    interface IControlBuilderAccessor&#xA;    interface IControlDesignerAccessor&#xA;    interface IExpressionsAccessor" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Définit les propriétés, les méthodes et les événements qui sont partagés par tous les contrôles serveur ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit de la classe principale que vous dérivez de lorsque vous développez des contrôles serveur ASP.NET personnalisés. <xref:System.Web.UI.Control> n’a pas de fonctionnalités spécifiques à l’interface utilisateur. Si vous créez un contrôle qui ne dispose pas d’une interface utilisateur, ou combine les autres contrôles qui définissent leur propre interface utilisateur, dérivez de <xref:System.Web.UI.Control>. Si vous créez un contrôle qui possède une interface utilisateur, dérivez de <xref:System.Web.UI.WebControls.WebControl> ni aucun contrôle dans le <xref:System.Web.UI.WebControls> point d’espace de noms qui fournit un début approprié pour votre contrôle personnalisé.  
  
 Le <xref:System.Web.UI.Control> classe est la classe de base pour tous les contrôles serveur ASP.NET, y compris les contrôles personnalisés, les contrôles utilisateur et les pages. Les pages ASP.NET sont des instances de la <xref:System.Web.UI.Page> (classe), qui hérite de la <xref:System.Web.UI.Control> classe et qui gèrent les demandes pour les fichiers qui ont une extension .aspx.  
  
 Le <xref:System.Web.UI.Control> classe directement ou indirectement utilisable comme partie de l’interface utilisateur pour votre application Web et en tant que tel devrait être examinée pour rendre que meilleures pratiques pour l’écriture de code sécurisé et la sécurisation des applications sont suivies.  
  
 Pour obtenir des informations générales sur ces sujets, consultez [vue d’ensemble des menaces de sécurité des applications Web](https://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB : Meilleures pratiques de sécurité stratégie](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), et [les Concepts de sécurité clés](~/docs/standard/security/key-security-concepts.md). Pour plus d’informations, consultez [sécurisation des contrôles Standard](https://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [Comment : Afficher les Messages d’erreur sécurisés](https://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [Comment : Protéger contre les attaques de Script dans une Application Web en appliquant l’encodage HTML](https://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), et [Introduction aux contrôles de Validation](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.0/2e4hd649(v=vs.85)).  
  
   
  
## Examples  
 L’exemple suivant illustre un contrôle serveur personnalisé qui dérive de la <xref:System.Web.UI.Control> classe. Le `InnerContent` substitue le <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> (méthode), vérifie si la classe possède des contrôles enfants dans la page et détermine si le premier enfant du contrôle est un contrôle littéral. Si les deux conditions suivantes sont remplies, la méthode substituée écrit la chaîne HTML \<H2 > votre Message :, le contenu du contrôle littéral et une fermeture \</H2 > balise à la page Web Forms.  
  
> [!IMPORTANT]
>  Cet exemple comprend une zone de texte qui accepte une entrée d'utilisateur, ce qui constitue une menace potentielle pour la sécurité. Par défaut, les pages web ASP.NET vérifient que l’entrée d’utilisateur n’inclut pas de script ou d’éléments HTML. Pour plus d’informations, consultez [Vue d’ensemble des attaques de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
    <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Développement de contrôles serveur ASP.NET personnalisés</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Adapter : System.Web.UI.Adapters.ControlAdapter" Usage="System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'adaptateur spécifique au navigateur pour le contrôle.</summary>
        <value><see cref="T:System.Web.UI.Adapters.ControlAdapter" /> de ce contrôle. Si le navigateur cible ne requiert pas d'adaptateur, retourne <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les pages Web ASP.NET sont utilisables à travers une large gamme d’appareils et navigateurs qui peuvent demander des informations à partir du Web. Le <xref:System.Web.UI.Control.Adapter%2A> propriété retourne le <xref:System.Web.UI.Adapters.ControlAdapter> objet qui restitue le contrôle sur l’appareil demandeur ou l’écran de navigateur.  
  
 Pour plus d’informations à propos des adaptateurs, consultez [Architectural Overview of Adaptive Control Behavior](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">Présentation de l’architecture du comportement de contrôle adaptatif</related>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberSignature Language="F#" Value="abstract member AddedControl : System.Web.UI.Control * int -&gt; unit&#xA;override this.AddedControl : System.Web.UI.Control * int -&gt; unit" Usage="control.AddedControl (control, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">Le <see cref="T:System.Web.UI.Control" /> qui a été ajouté.</param>
        <param name="index">Index du contrôle dans la collection <see cref="P:System.Web.UI.Control.Controls" />.</param>
        <summary>Méthode appelée après qu’un contrôle enfant est ajouté à la collection <see cref="P:System.Web.UI.Control.Controls" /> de l’objet <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.AddedControl%2A> méthode est appelée immédiatement après un contrôle est ajouté à la <xref:System.Web.UI.Control.Controls%2A> collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" /> est un contrôle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member AddParsedSubObject : obj -&gt; unit&#xA;override this.AddParsedSubObject : obj -&gt; unit" Usage="control.AddParsedSubObject obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Object" /> qui représente l’élément analysé.</param>
        <summary>Notifie au contrôle serveur qu’un élément XML ou HTML a été analysé, et ajoute l’élément à l’objet <see cref="T:System.Web.UI.ControlCollection" /> du contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous substituez pas, cette méthode ajoute automatiquement <xref:System.Web.UI.LiteralControl> objets pour le contrôle serveur <xref:System.Web.UI.ControlCollection> objet. Cette collection est accessible via <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propriété.  
  
   
  
## Examples  
 L’exemple suivant est un contrôle serveur personnalisé qui utilise le <xref:System.Web.UI.Control.AddParsedSubObject%2A> méthode pour déterminer si les éléments déclarés entre les balises d’ouverture et fermeture de ce contrôle sont <xref:System.Web.UI.WebControls.TextBox> contrôles serveur Web. S’ils sont, ils sont ajoutés à un <xref:System.Collections.ArrayList> objet, `items`. Lorsque substituées <xref:System.Web.UI.Control.CreateChildControls%2A> méthode est appelée, elle effectue une itération dans le <xref:System.Collections.ArrayList> et ajoute chaque objet qu’il contient à la <xref:System.Web.UI.ControlCollection> du contrôle serveur personnalisé.  
  
> [!IMPORTANT]
>  Cet exemple comprend une zone de texte qui accepte une entrée d'utilisateur, ce qui constitue une menace potentielle pour la sécurité. Par défaut, les pages web ASP.NET vérifient que l’entrée d’utilisateur n’inclut pas de script ou d’éléments HTML. Pour plus d’informations, consultez [Vue d’ensemble des attaques de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="abstract member ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit&#xA;override this.ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit" Usage="control.ApplyStyleSheetSkin page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page"><see cref="T:System.Web.UI.Page" /> contenant le contrôle.</param>
        <summary>Applique les propriétés de style définies dans la feuille de style de la page au contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> méthode définit les propriétés de style sur le contrôle en fonction des propriétés d’apparence définies dans un répertoire de thème. L’apparence appliquée est l’apparence de valeur par défaut pour le contrôle ou l’apparence spécifiée dans le <xref:System.Web.UI.Control.SkinID%2A> propriété. Le <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> méthode est appelée par ASP.NET pour les contrôles déclaratifs placés sur une page. Vous devez appeler la <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> méthode sur tout contrôle créé par programme au moment de l’exécution pour le style apparences de la feuille à appliquer au contrôle. Les apparences de thème sont appliquées automatiquement. Pour plus d’informations sur la différence entre les thèmes et les feuilles de style en cascade, consultez [thèmes ASP.NET et des apparences](https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La feuille de style est déjà appliquée.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeTemplateSourceDirectory : string with get, set" Usage="System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le répertoire virtuel relatif à l'application de l'objet <see cref="T:System.Web.UI.Page" /> ou <see cref="T:System.Web.UI.UserControl" /> qui contient ce contrôle.</summary>
        <value>Répertoire virtuel relatif à l'application de la page ou du contrôle utilisateur qui contient ce contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriété contient le chemin d’accès relatif à l’application au contrôle utilisateur ou de la page qui contient le contrôle actuel. Par exemple, si la page Web réside à http://www.contoso.com/application/subdirectory, le <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriété retourne « ~ / sous-répertoire ».  
  
 Pour retourner le chemin d’accès virtuel (« application/sous-répertoire »), utilisez le <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.BeginRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.BeginRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">Objet qui écrit les données de trace.</param>
        <param name="traceObject">Objet de trace.</param>
        <summary>Commence le traçage au moment du design des données de rendu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le contrôle qui contient la liaison de données de ce contrôle.</summary>
        <value><see cref="T:System.Web.UI.Control" /> qui contient la liaison de données de ce contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.BindingContainer%2A> propriété contient une référence à la <xref:System.Web.UI.Control> objet qui contient les informations de liaison de données pour le contrôle actuel.  
  
 Le <xref:System.Web.UI.Control.BindingContainer%2A> propriété est le même que le <xref:System.Web.UI.Control.NamingContainer%2A> propriété, sauf lorsque le contrôle fait partie d’un modèle. Dans ce cas, le <xref:System.Web.UI.Control.BindingContainer%2A> propriété est définie sur le <xref:System.Web.UI.Control> qui définit le modèle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberSignature Language="F#" Value="member this.BuildProfileTree : string * bool -&gt; unit" Usage="control.BuildProfileTree (parentId, calcViewState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">Identificateur du parent du contrôle.</param>
        <param name="calcViewState">Boolean qui indique si la taille de l'état d'affichage est calculée.</param>
        <summary>Collecte des informations sur le contrôle serveur et les livre à la propriété <see cref="P:System.Web.UI.Page.Trace" /> à afficher lorsque le traçage est activé pour la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété collecte les informations nécessaires sur la hiérarchie de l’interface utilisateur d’une page et le passe à la page [ &lt;trace&gt; ](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md) propriété. Lorsque vous activez le traçage, pour une page ou pour votre application, ces informations sont affichées dans la `Control Tree` section de la sortie de trace. Sortie de trace pour une page est ajoutée à la fin de la page. alors que la sortie de trace pour une application peut être affichée à partir de la visionneuse de trace (fichier trace.axd) qui est stockée dans le répertoire racine de l’application. Pour plus d’informations sur le suivi, consultez [vue d’ensemble du traçage ASP.NET](https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChildControlsCreated : bool with get, set" Usage="System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si des contrôles enfants du contrôle serveur ont été créés.</summary>
        <value><see langword="true" /> si des contrôles enfants ont été créés ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une substitution de la <xref:System.Web.UI.Control.OnDataBinding%2A> méthode de personnalisé <xref:System.Web.UI.WebControls.Repeater> contrôle. Pour vous assurer que les contrôles enfants ne sont pas créés jusqu'à ce que la liaison de données se produit à nouveau, le <xref:System.Web.UI.Control.ChildControlsCreated%2A> propriété est définie sur `true` après le <xref:System.Web.UI.WebControls.RepeaterItem> objets sont créés et ajoutés au contrôle <xref:System.Web.UI.ControlCollection> objet.  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 L’exemple suivant montre comment utiliser le contrôle repeater personnalisé dans une page Web.  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberSignature Language="F#" Value="member this.ClearCachedClientID : unit -&gt; unit" Usage="control.ClearCachedClientID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Affecte à la valeur <see cref="P:System.Web.UI.Control.ClientID" /> mise en cache la valeur <see langword="null" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildControlState : unit -&gt; unit" Usage="control.ClearChildControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime les informations sur l'état du contrôle des contrôles enfants du contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.ClearChildControlState%2A> méthode est utilisée lorsque les informations d’état du contrôle enfant écrites à l’état de contrôle du contrôle parent sont remplacées comme contrôles enfants sont créés, par exemple lorsque des contrôles enfants de liaison de données dans un contrôle basé sur un modèle lié aux données serveur. Appel de la <xref:System.Web.UI.Control.ClearChildControlState%2A> méthode pour vider les contrôles enfants avant d’appeler le <xref:System.Web.UI.Control.SaveControlState%2A> méthode réduit la taille des informations d’état de contrôle qui doivent être stockées ou transmises.  
  
 Lorsque vous recréez les contrôles enfants d’un <xref:System.Web.UI.Control> de l’objet, utilisez le <xref:System.Web.UI.Control.ClearChildControlState%2A> méthode pour effacer l’état du contrôle enfant afin qu’il ne soit pas appliqué par inadvertance aux nouveaux contrôles.  
  
 Pour effacer l’état du contrôle enfant et l’état d’affichage, utilisez le <xref:System.Web.UI.Control.ClearChildState%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildState : unit -&gt; unit" Usage="control.ClearChildState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime les informations sur l'état d'affichage et sur l'état du contrôle de tous les contrôles enfants du contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.ClearChildState%2A> méthode efface toutes les informations d’état du contrôle et d’état d’affichage pour les contrôles enfants. Il est équivalent à l’appel à la fois le <xref:System.Web.UI.Control.ClearChildViewState%2A> (méthode) et le <xref:System.Web.UI.Control.ClearChildControlState%2A> (méthode).  
  
 Lorsque vous recréez les contrôles enfants d’un <xref:System.Web.UI.Control> de l’objet, utilisez le <xref:System.Web.UI.Control.ClearChildState%2A> méthode pour effacer l’état enfant afin qu’il ne soit pas appliqué par inadvertance aux nouveaux contrôles.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Web.UI.Control.OnDataBinding%2A> méthode pour un contrôle lié aux données basé sur un modèle. Si la source de données que le contrôle se lie est renseignée, le contrôle <xref:System.Web.UI.ControlCollection> collection est vidée à l’aide la <xref:System.Web.UI.ControlCollection.Clear%2A> (méthode) et le <xref:System.Web.UI.Control.ClearChildState%2A> méthode est utilisée pour supprimer les informations d’état qui avaient été enregistrées pour les contrôles enfants.  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildViewState : unit -&gt; unit" Usage="control.ClearChildViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime les informations d'état d'affichage de tous les contrôles enfants du contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est couramment utilisée lorsque vous substituez la <xref:System.Web.UI.Control.DataBind%2A> méthode lors du développement de contrôles basés sur un modèle lié aux données serveur. Si vous n’appelez pas cette méthode, informations d’état d’affichage de contrôle d’enfant peuvent être écrites à un contrôle serveur parent, seulement pour être substituées lorsque les données sont liées.  
  
 Lorsque vous recréez les contrôles enfants d’un <xref:System.Web.UI.Control>, utilisez le <xref:System.Web.UI.Control.ClearChildViewState%2A> méthode pour effacer l’état d’affichage enfant afin qu’il ne soit pas appliqué par inadvertance aux nouveaux contrôles.  
  
 Pour plus d’informations sur l’utilisation de cette méthode, consultez [Comment : Créer des contrôles utilisateur ASP.NET avec modèles](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <related type="Article" href="https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2">Procédure : Créer des contrôles utilisateur basé sur un modèle</related>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberSignature Language="F#" Value="member this.ClearEffectiveClientIDMode : unit -&gt; unit" Usage="control.ClearEffectiveClientIDMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Affecte la valeur <see cref="P:System.Web.UI.Control.ClientIDMode" /> à la propriété <see cref="F:System.Web.UI.ClientIDMode.Inherit" /> de l'instance de contrôle actuelle et de tous contrôles enfants.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientID : string" Usage="System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’ID de contrôle du balisage HTML généré par ASP.NET.</summary>
        <value>ID de contrôle du balisage HTML généré par ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un contrôle serveur Web est restitué dans un élément HTML, le `id` attribut de l’élément HTML est défini sur la valeur de la <xref:System.Web.UI.Control.ClientID%2A> propriété. Le <xref:System.Web.UI.Control.ClientID%2A> valeur est souvent utilisée pour accéder à l’élément HTML dans le script client à l’aide de la `document.getElementById` (méthode). L’ID est également souvent utilisé dans les règles CSS pour spécifier des éléments de style. Par exemple, la règle de style CSS suivante sélectionne tous les `span` éléments possédant le `id` valeur d’attribut `ProductIDLabel` et définit leur `background-color` attribut `white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET fournit plusieurs algorithmes pour savoir comment générer la <xref:System.Web.UI.Control.ClientID%2A> valeur de propriété. Vous sélectionnez l’algorithme à utiliser pour un contrôle en définissant son <xref:System.Web.UI.Control.ClientIDMode%2A> propriété. Les algorithmes sont identifiés par le <xref:System.Web.UI.ClientIDMode> des valeurs d’énumération qui sont répertoriées dans le tableau suivant.  
  
|Value|Description |  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|La valeur de la propriété <xref:System.Web.UI.Control.ClientID%2A> est générée par concaténation des valeurs de la propriété <xref:System.Web.UI.Control.ID%2A> de chaque conteneur d'attribution de noms parent à la valeur de la propriété <xref:System.Web.UI.Control.ID%2A> du contrôle. Dans les scénarios de liaison de données où plusieurs instances d'un contrôle sont restituées, une valeur d'incrémentation est insérée devant la valeur de la propriété <xref:System.Web.UI.Control.ID%2A> du contrôle. Chaque segment est séparé par un trait de soulignement (_). Cet algorithme a été utilisé dans les versions d’ASP.NET antérieures à ASP.NET 4.|  
|<xref:System.Web.UI.ClientIDMode.Static>|La propriété <xref:System.Web.UI.Control.ClientID%2A> a la valeur de la propriété <xref:System.Web.UI.Control.ID%2A>. Si le contrôle est un conteneur d'attribution de noms, il est utilisé comme élément le plus élevé de la hiérarchie des conteneurs d'attribution de noms pour tous les contrôles qu'il contient.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Cet algorithme est utilisé pour les contrôles contenus dans des contrôles liés aux données. La valeur de la propriété <xref:System.Web.UI.Control.ClientID%2A> est générée par concaténation de la valeur de la propriété <xref:System.Web.UI.Control.ClientID%2A> du conteneur d'attribution de noms parent à la valeur de la propriété <xref:System.Web.UI.Control.ID%2A> du contrôle. Si le contrôle est un contrôle lié aux données qui génère plusieurs lignes, la valeur du champ de données spécifiée dans la propriété <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> est ajoutée à la fin. Pour le contrôle <xref:System.Web.UI.WebControls.GridView>, plusieurs champs de données peuvent être spécifiés. Si le <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriété est vide, un numéro séquentiel est ajouté à la fin au lieu d’une valeur de champ de données. Chaque segment est séparé par un trait de soulignement (_).|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|Le contrôle hérite du paramètre de <xref:System.Web.UI.ClientIDMode> de son contrôle <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 La valeur par défaut <xref:System.Web.UI.Control.ClientIDMode%2A> pour une page est <xref:System.Web.UI.ClientIDMode.Predictable>. La valeur par défaut <xref:System.Web.UI.Control.ClientIDMode%2A> pour un contrôle est <xref:System.Web.UI.ClientIDMode.Inherit>. Étant donné que la valeur par défaut pour les contrôles est <xref:System.Web.UI.ClientIDMode.Inherit>, la génération par défaut est le mode <xref:System.Web.UI.ClientIDMode.Predictable>. (Toutefois, si vous utilisez Visual Studio pour convertir un projet Web vers ASP.NET 4 à partir d’une version antérieure, Visual Studio définit automatiquement la valeur par défaut du site <xref:System.Web.UI.ClientIDMode.AutoID> dans le fichier Web.config.)  
  
 Pour plus d’informations, consultez [Identification du contrôle serveur web ASP.NET](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7).  
  
   
  
## Examples  
 Les exemples suivants montrent un contrôle utilisateur Web qui est à l’intérieur d’une page de contenu pour une page maître. Le contrôle utilisateur contient un <xref:System.Web.UI.WebControls.DropDownList> contrôle et un <xref:System.Web.UI.WebControls.Label> contrôle. Le texte qui est affiché dans le <xref:System.Web.UI.WebControls.Label> contrôle est déterminé par la valeur que l’utilisateur sélectionne à partir de la <xref:System.Web.UI.WebControls.DropDownList> contrôle. La valeur de texte est définie via un script client afin que la page Web n’a pas de publication sur le serveur afin de définir cette valeur. Pour obtenir une référence à l’élément HTML restitué pour la <xref:System.Web.UI.WebControls.Label> contrôle dans le script client, vous devez connaître la valeur du contrôle <xref:System.Web.UI.Control.ClientID%2A> propriété. Toutefois, étant donné que le contrôle utilisateur peut être placé n’importe où dans une page Web, il est impossible de savoir à l’avance quels conteneurs d’attribution de noms contiendra les contrôles. Pour vous assurer que le <xref:System.Web.UI.Control.ClientID%2A> valeur doit être le même que le <xref:System.Web.UI.Control.ID%2A> valeur, le code définit le <xref:System.Web.UI.Control.ClientIDMode%2A> valeur <xref:System.Web.UI.WebControls.ValidatorDisplay.Static>.  
  
 L’exemple suivant montre le contrôle utilisateur.  
  
  
  
 L’exemple suivant montre la page de contenu qui contient le contrôle utilisateur.  
  
  
  
 L’exemple suivant montre la page maître qui contient la page de contenu.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">Identification du contrôle d’ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">Procédure : Contrôles d’accès à partir de JavaScript par ID</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">Procédure pas à pas : Simplification des contrôles liés aux données pour l’accès à partir de JavaScript</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">Procédure pas à pas : Rendre des contrôles situés dans les contrôles utilisateur Web plus faciles d’accès à partir de JavaScript</related>
        <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Script client dans les Pages Web ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDMode : System.Web.UI.ClientIDMode with get, set" Usage="System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'algorithme utilisé pour générer la valeur de la propriété <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Valeur qui indique comment la propriété <see cref="P:System.Web.UI.Control.ClientID" /> est générée. La valeur par défaut est <see cref="F:System.Web.UI.ClientIDMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET fournit plusieurs algorithmes pour savoir comment générer la <xref:System.Web.UI.Control.ClientID%2A> valeur de propriété. Vous sélectionnez l’algorithme à utiliser pour un contrôle en définissant son <xref:System.Web.UI.Control.ClientIDMode%2A> propriété. Les algorithmes sont identifiés par le <xref:System.Web.UI.ClientIDMode> des valeurs d’énumération qui sont répertoriées dans le tableau suivant.  
  
|Value|Description |  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|La valeur de la propriété <xref:System.Web.UI.Control.ClientID%2A> est générée par concaténation des valeurs de la propriété <xref:System.Web.UI.Control.ID%2A> de chaque conteneur d'attribution de noms parent à la valeur de la propriété <xref:System.Web.UI.Control.ID%2A> du contrôle. Dans les scénarios de liaison de données où plusieurs instances d'un contrôle sont restituées, une valeur d'incrémentation est insérée devant la valeur de la propriété <xref:System.Web.UI.Control.ID%2A> du contrôle. Chaque segment est séparé par un trait de soulignement (_). Cet algorithme a été utilisé dans les versions d’ASP.NET antérieures à ASP.NET 4.|  
|<xref:System.Web.UI.ClientIDMode.Static>|La propriété <xref:System.Web.UI.Control.ClientID%2A> a la valeur de la propriété <xref:System.Web.UI.Control.ID%2A>. Si le contrôle est un conteneur d'attribution de noms, il est utilisé comme élément le plus élevé de la hiérarchie des conteneurs d'attribution de noms pour tous les contrôles qu'il contient.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Cet algorithme est utilisé pour les contrôles contenus dans des contrôles liés aux données. La valeur de la propriété <xref:System.Web.UI.Control.ClientID%2A> est générée par concaténation de la valeur de la propriété <xref:System.Web.UI.Control.ClientID%2A> du conteneur d'attribution de noms parent à la valeur de la propriété <xref:System.Web.UI.Control.ID%2A> du contrôle. Si le contrôle est un contrôle lié aux données qui génère plusieurs lignes, la valeur du champ de données spécifiée dans la propriété <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> est ajoutée à la fin. Pour le contrôle <xref:System.Web.UI.WebControls.GridView>, plusieurs champs de données peuvent être spécifiés. Si le <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriété est vide, un numéro séquentiel est ajouté à la fin au lieu d’une valeur de champ de données. Ce nombre commence à zéro et est incrémenté de 1 pour chaque ligne. Chaque segment est séparé par un trait de soulignement (_).|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|Le contrôle hérite du paramètre de <xref:System.Web.UI.ClientIDMode> de son contrôle <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 La valeur par défaut <xref:System.Web.UI.Control.ClientIDMode%2A> pour une page est <xref:System.Web.UI.ClientIDMode.Predictable>. La valeur par défaut <xref:System.Web.UI.Control.ClientIDMode%2A> pour un contrôle est <xref:System.Web.UI.ClientIDMode.Inherit>. Étant donné que la valeur par défaut pour les contrôles est <xref:System.Web.UI.ClientIDMode.Inherit>, la génération par défaut est le mode <xref:System.Web.UI.ClientIDMode.Predictable>. (Toutefois, si vous utilisez Visual Studio pour convertir un projet Web vers ASP.NET 4 à partir d’une version antérieure, Visual Studio définit automatiquement la valeur par défaut du site <xref:System.Web.UI.ClientIDMode.AutoID> dans le fichier Web.config.)  
  
 Pour plus d’informations, consultez [Identification du contrôle serveur web ASP.NET](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7).  
  
   
  
## Examples  
 L’exemple suivant <xref:System.Web.UI.WebControls.Label> contrôles contenus dans un <xref:System.Web.UI.WebControls.ListView> contrôle. Sur le <xref:System.Web.UI.WebControls.ListView> contrôle, le <xref:System.Web.UI.Control.ClientIDMode%2A> propriété est définie sur <xref:System.Web.UI.ClientIDMode.Predictable> et <xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> propriété est définie sur `ProductID`. Dans le code HTML affiché, cela crée trois `span` éléments qui correspondent aux trois `ProductIDLabel` contrôles. Lorsque la page s’exécute, le `id` d’attributs pour le `span` éléments sont définis sur les valeurs suivantes :  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">Identification du contrôle d’ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">Procédure : Contrôles d’accès à partir de JavaScript par ID</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">Procédure pas à pas : Simplification des contrôles liés aux données pour l’accès à partir de JavaScript</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">Procédure pas à pas : Rendre des contrôles situés dans les contrôles utilisateur Web plus faciles d’accès à partir de JavaScript</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDSeparator : char" Usage="System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur de caractère représentant le caractère de séparation utilisé dans la propriété <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Retourne toujours le trait de soulignement (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.ClientID%2A> valeur est générée en concaténant la <xref:System.Web.UI.Control.ID%2A> valeur du contrôle et le <xref:System.Web.UI.Control.UniqueID%2A> valeur de son contrôle parent. Chaque partie de l’élément généré <xref:System.Web.UI.Control.ID%2A> propriété est séparée par le <xref:System.Web.UI.Control.ClientIDSeparator%2A> valeur de propriété. La valeur retourne toujours un trait de soulignement (_).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.HttpContext" /> associé au contrôle serveur pour la demande Web en cours.</summary>
        <value>Objet <see cref="T:System.Web.HttpContext" /> spécifié associé à la demande en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet d’accéder à la <xref:System.Web.HttpContext> objet pour la requête Web actuelle. L’objet fournit des propriétés qui accèdent à la <xref:System.Web.HttpContext.Application%2A>, <xref:System.Web.HttpContext.Session%2A>, <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A> et d’autres objets qui contiennent des informations sur la requête HTTP actuelle. Il fournit également des méthodes qui vous permettent d’obtenir des informations de configuration et de définir ou effacer les erreurs pour la demande.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Web.UI.ControlCollection" /> qui représente les contrôles enfants pour un contrôle serveur spécifié dans la hiérarchie de l’interface utilisateur.</summary>
        <value>Collection de contrôles enfants pour le contrôle serveur spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sur une page ASP.NET, lorsque les contrôles sont ajoutés de manière déclarative entre les balises d’ouverture et fermeture d’un contrôle serveur, ASP.NET ajoute automatiquement les contrôles du contrôle serveur contenant <xref:System.Web.UI.ControlCollection>. Les balises HTML ou les chaînes de texte qui ne sont pas traités sur le serveur sont traités comme <xref:System.Web.UI.LiteralControl> objets. Ils sont ajoutés à la collection, comme d’autres contrôles serveur.  
  
 Le <xref:System.Web.UI.Control.Controls%2A> propriété vous permet d’accéder par programmation à l’instance de la <xref:System.Web.UI.ControlCollection> classe pour n’importe quel contrôle serveur. Vous pouvez ajouter des contrôles à la collection, supprimer des contrôles de la collection ou effectuer une itération dans les contrôles serveur dans la collection.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter des contrôles enfants à un contrôle serveur <xref:System.Web.UI.ControlCollection> objet via son <xref:System.Web.UI.Control.Controls%2A> propriété.  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors du remplacement de la <see cref="P:System.Web.UI.Control.Controls" /> propriété, veillez à appeler la <see cref="M:System.Web.UI.Control.EnsureChildControls" /> (méthode). En outre, si vous envisagez d’ajouter par programmation des contrôles à la collection de contrôles, vous pouvez envisager les contrôles dans substitué <see cref="M:System.Web.UI.Control.CreateChildControls" /> (méthode).</para></block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="control.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelée par l’infrastructure de page ASP.NET pour signaler aux contrôles serveur qu’ils doivent utiliser l’implémentation basée sur la composition pour créer les contrôles enfants qu’ils contiennent en vue de la publication ou du rendu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous développez un contrôle serveur composite ou basé sur un modèle, vous devez substituer cette méthode. Contrôle qui substituent les <xref:System.Web.UI.Control.CreateChildControls%2A> méthode doit implémenter le <xref:System.Web.UI.INamingContainer> interface afin d’éviter les conflits de noms.  
  
 Pour plus d’informations, consultez [modèles de contrôles serveur Web](https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae) et [développement de contrôles serveur ASP.NET personnalisés](https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef).  
  
   
  
## Examples  
 L’exemple suivant illustre une version substituée de la <xref:System.Web.UI.Control.CreateChildControls%2A> (méthode). Dans cette implémentation, le contrôle composite affiche un <xref:System.Web.UI.WebControls.TextBox> contrôle placé entre deux contrôles littéraux.  
  
> [!IMPORTANT]
>  Cet exemple comprend une zone de texte qui accepte une entrée d'utilisateur, ce qui constitue une menace potentielle pour la sécurité. Par défaut, les pages web ASP.NET vérifient que l’entrée d’utilisateur n’inclut pas de script ou d’éléments HTML. Pour plus d’informations, consultez [Vue d’ensemble des attaques de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Développement de contrôles serveur ASP.NET personnalisés</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae">Modèles de contrôles serveur Web ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection&#xA;override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="control.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet <see cref="T:System.Web.UI.ControlCollection" /> pour contenir les contrôles enfants (littéraux et serveur) du contrôle serveur.</summary>
        <returns>Objet <see cref="T:System.Web.UI.ControlCollection" /> pour contenir les contrôles serveur enfants du contrôle serveur actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode dans un contrôle serveur personnalisé si vous avez créé un objet de collection qui est dérivé de la <xref:System.Web.UI.ControlCollection> classe. Vous pouvez ensuite instancier cette classe de collection dans la substitution de cette méthode.  
  
   
  
## Examples  
 Suit exemple de code remplace le <xref:System.Web.UI.Control.CreateControlCollection%2A> méthode pour créer une instance d’un `CustomControlCollection` (classe), qui hérite de la <xref:System.Web.UI.ControlCollection> classe.  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 Le code suivant exemple utilise le <xref:System.Web.UI.Control.CreateControlCollection%2A> la substitution de méthode dans un contrôle serveur personnalisé de la <xref:System.Web.UI.Control.CreateChildControls%2A> (méthode). La nouvelle collection est créée et ensuite remplie avec deux contrôles enfants, `firstControl` et `secondControl`.  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lie une source de données au contrôle serveur appelé et à tous ses contrôles enfants.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberSignature Language="F#" Value="abstract member DataBind : unit -&gt; unit&#xA;override this.DataBind : unit -&gt; unit" Usage="control.DataBind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lie une source de données au contrôle serveur appelé et à tous ses contrôles enfants.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lier des données à partir d’une source à un contrôle serveur. Cette méthode est couramment utilisée après la récupération d’un jeu de données via une requête de base de données. La plupart des contrôles effectuer des données de liaison automatiquement, ce qui signifie que généralement inutile d’appeler cette méthode explicitement.  
  
 Cette méthode est couramment substituée lorsque vous créez un contrôle lié aux données basé sur un modèle personnalisé. Pour plus d'informations, voir [Procédure : Créer des contrôles utilisateur ASP.NET avec modèles](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2) et [développement de contrôles de serveur Web lié aux données personnalisé](https://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1). Lorsqu’elle est appelée sur un contrôle serveur, cette méthode résout toutes les expressions de liaison de données dans le contrôle serveur et dans un de ses contrôles enfants.  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.DataBind%2A> méthode dans un contrôle de serveur ASP.NET personnalisé. Il commence par appeler la base de <xref:System.Web.UI.Control.OnDataBinding%2A> (méthode), puis utilise le <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> méthode pour supprimer tous les contrôles enfants et la <xref:System.Web.UI.Control.ClearChildViewState%2A> méthode pour supprimer tout état d’affichage paramètres enregistrés pour ces contrôles enfants. Enfin, le <xref:System.Web.UI.Control.ChildControlsCreated%2A> propriété est définie sur `true` et le contrôle est invité à effectuer le suivi des modifications à l’état d’affichage des contrôles récemment créés avec la <xref:System.Web.UI.Control.TrackViewState%2A> (méthode). Il s’agit d’une technique courante lors de la liaison de données à un contrôle pour garantir que les nouvelles données ne sont pas en conflit avec les données stockées à partir d’une précédente <xref:System.Web.UI.Control.DataBind%2A> appel de méthode.  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Développement de contrôles serveur ASP.NET personnalisés</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Vue d’ensemble du Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberSignature Language="F#" Value="abstract member DataBind : bool -&gt; unit&#xA;override this.DataBind : bool -&gt; unit" Usage="control.DataBind raiseOnDataBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding"><see langword="true" /> si l'événement <see cref="E:System.Web.UI.Control.DataBinding" /> est déclenché ; sinon, <see langword="false" />.</param>
        <summary>Lie une source de données au contrôle serveur appelé et tous ses contrôles enfants avec une option pour déclencher l'événement <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> méthode dans un scénario lorsque votre contrôle personnalisé remplace le <xref:System.Web.UI.Control.DataBind%2A> (méthode) et implémente la <xref:System.Web.UI.IDataItemContainer> interface. Dans ce scénario, le contrôle personnalisé appelle le <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> méthode avec `raiseOnDataBinding` définie sur `false` pour vous assurer que la classe de base <xref:System.Web.UI.Control.DataBind%2A> méthode est appelée.  
  
 Le <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> méthode appelle le <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> méthode avec `raiseOnDataBinding` défini sur `true`.  
  
> [!NOTE]
>  Appelant le <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> méthode avec `raiseOnDataBinding` définie sur `false` , les contrôles être liées à des données de n’importe quel enfant la <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Vue d’ensemble du Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberSignature Language="F#" Value="abstract member DataBindChildren : unit -&gt; unit&#xA;override this.DataBindChildren : unit -&gt; unit" Usage="control.DataBindChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lie une source de données aux contrôles enfants du contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.Control.DataBindChildren%2A> méthode pour lier une source de données aux contrôles enfants d’un contrôle serveur.  
  
> [!NOTE]
>  Lorsqu’elle est appelée sur un contrôle serveur, cette méthode ne lie pas les données au contrôle. Pour lier un contrôle serveur et tous ses contrôles enfants, appelez le <xref:System.Web.UI.Control.DataBind%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Développement de contrôles serveur ASP.NET personnalisés</related>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberSignature Language="F#" Value="member this.DataBinding : EventHandler " Usage="member this.DataBinding : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contrôle serveur se lie à une source de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement avertit le contrôle de serveur pour effectuer toute logique de liaison de données qui a été écrit pour elle.  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataItemContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au conteneur d'attribution de noms si celui-ci implémente <see cref="T:System.Web.UI.IDataItemContainer" />.</summary>
        <value>Conteneur d'attribution de noms. Dans une hiérarchie de conteneurs d'attribution de noms qui implémentent <see cref="T:System.Web.UI.IDataItemContainer" />, cette propriété retourne le conteneur d'attribution de noms situé en haut de la hiérarchie, ou <see langword="null" /> si l'objet <see cref="T:System.Web.UI.Control" /> actuel n'est pas dans un conteneur d'attribution de noms qui implémente <see cref="T:System.Web.UI.IDataItemContainer" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataKeysContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au conteneur d'attribution de noms si celui-ci implémente <see cref="T:System.Web.UI.IDataKeysControl" />.</summary>
        <value>Conteneur d'attribution de noms. Dans une hiérarchie de conteneurs d'attribution de noms qui implémentent <see cref="T:System.Web.UI.IDataKeysControl" />, la propriété retourne le conteneur d'attribution de noms situé en haut de la hiérarchie, ou <see langword="null" /> si l'objet <see cref="T:System.Web.UI.Control" /> actif n'est pas dans un conteneur d'attribution de noms qui implémente <see cref="T:System.Web.UI.IDataKeysControl" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DesignMode : bool" Usage="System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si un contrôle est utilisé sur une aire de conception.</summary>
        <value><see langword="true" /> si le contrôle est utilisé dans un concepteur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.DesignMode%2A> retourne de la propriété `true` pour indiquer que le contrôle est utilisé dans le contexte d’un concepteur. Vos contrôles personnalisés peuvent utiliser cette propriété lorsqu’un comportement au moment du design est différent de celle de comportement au moment de l’exécution.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/wxh45wzs(v=vs.100)">Vue d’ensemble des concepteurs de contrôle ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="control.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet à un contrôle serveur d'effectuer le nettoyage final avant qu'il soit libéré de la mémoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Web.UI.Control.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.Web.UI.Control>. La méthode <xref:System.Web.UI.Control.Dispose%2A> rend le <xref:System.Web.UI.Control> inutilisable. Après avoir appelé cette méthode, vous devez libérer toutes les références au contrôle afin que la mémoire occupée peut être récupérée par le garbage collection.  
  
   
  
## Examples  
 Ce qui suit exemple de code remplace le <xref:System.Web.UI.Control.Dispose%2A> méthode pour fermer le <xref:System.Web.UI.HtmlTextWriter> objet associé à un contrôle et appelez le <xref:System.Web.UI.Control.Dispose%2A> méthode sur un <xref:System.Web.UI.WebControls.Button> contrôle nommé `myButton`. Si un <xref:System.Exception> est levée lorsque cette version de la <xref:System.Web.UI.Control.Dispose%2A> méthode est appelée, le contrôle écrit un message en cours <xref:System.Web.HttpResponse> objet.  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.IComponent.Disposed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un contrôle serveur est libéré de la mémoire, ce qui constitue la dernière étape du cycle de vie d'un contrôle serveur en cas de demande d'une page ASP.NET.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les ressources qui nécessitent un temps processeur non négligeable, telles que les connexions de base de données, doivent être libérées avec cet événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les thèmes s'appliquent à ce contrôle.</summary>
        <value><see langword="true" /> pour utiliser les thèmes ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.EnableTheming%2A> propriété indique si les thèmes sont activés pour un contrôle spécifié. Lorsque le <xref:System.Web.UI.Control.EnableTheming%2A> propriété est `true`, répertoire de thème de l’application est recherché des apparences de contrôle à appliquer. Si aucune apparence pour le contrôle particulier n’existe dans le répertoire du thème, les apparences ne sont pas appliquées.  
  
 Lorsque le <xref:System.Web.UI.Control.EnableTheming%2A> propriété est `false`, le répertoire de thème n’est pas recherché et le contenu de la <xref:System.Web.UI.Control.SkinID%2A> propriété n’est pas utilisée.  
  
 Thèmes peuvent être activés à la page, le conteneur ou le niveau de contrôle. Un contrôle peut substituer le <xref:System.Web.UI.Control.EnableTheming%2A> a de valeur par son contrôle parent ou par la page contenante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'événement <see langword="Page_PreInit" /> s'est déjà produit.  
  
ou 
Le contrôle a déjà été ajouté à la collection <see langword="Controls" />.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">Vue d’ensemble des thèmes ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le contrôle serveur conserve son état d’affichage, et l’état d’affichage de tous les contrôles enfants qu’il contient, au client demandeur.</summary>
        <value><see langword="true" /> si le contrôle serveur conserve son état d’affichage ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 État d’affichage permet à un contrôle serveur conserve son état entre les requêtes HTTP. État d’affichage pour un contrôle est activé si toutes les conditions suivantes sont remplies :  
  
-   Le <xref:System.Web.UI.Control.EnableViewState%2A> propriété pour la page est définie sur `true`.  
  
-   Le <xref:System.Web.UI.Control.EnableViewState%2A> propriété pour le contrôle est définie sur `true`.  
  
-   Le <xref:System.Web.UI.Control.ViewStateMode%2A> propriété pour le contrôle est définie sur <xref:System.Web.UI.ViewStateMode.Enabled> ou hérite le <xref:System.Web.UI.ViewStateMode.Enabled> paramètre.  
  
 Pour plus d'informations, consultez la propriété <xref:System.Web.UI.Control.ViewStateMode%2A>.  
  
 État d’affichage d’un contrôle serveur est l’accumulation de toutes ses valeurs de propriété. Pour préserver ces valeurs entre les requêtes HTTP, ASP.NET utilise une instance de la <xref:System.Web.UI.StateBag> classe pour stocker les valeurs de propriété. Les valeurs sont ensuite passées en tant que variable à un champ masqué lors du traitement des demandes suivantes. Pour plus d’informations sur l’état d’affichage, consultez [ASP.NET View State Overview](https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818).  
  
 Il est parfois utile de désactiver l’état d’affichage, en particulier pour améliorer les performances de l’application. Par exemple, si vous chargez une demande de base de données dans un contrôle serveur, définissez cette propriété sur `false`. Si vous ne le faites pas, temps processeur est gaspillé le chargement d’état d’affichage dans le contrôle serveur qui peut uniquement être substitué par la requête de base de données. Si <xref:System.Web.UI.Control.EnableViewState%2A> est `false`, vous pouvez utiliser l’état du contrôle pour conserver les informations de propriété qui sont spécifique à un contrôle et ne peut pas être désactivées comme propriété d’état de la vue. Pour plus d’informations sur la différence entre l’état du contrôle et l’état d’affichage, consultez [vs d’état du contrôle. Exemple de l’état d’affichage](https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681).  
  
 Pour plus d’informations sur la façon d’activer ou désactiver l’état d’affichage par déclaration pour une page ASP.NET, consultez [ \@ Page](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100)).
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.UI.Control.EnableViewState%2A> propriété `false`.  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Vue d’ensemble de gestion de l’état de ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681">État du contrôle vs. Exemple de l’état d’affichage</related>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.EndRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.EndRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">Objet qui écrit les données de trace.</param>
        <param name="traceObject">Objet de trace.</param>
        <summary>Met fin au traçage au moment du design des données de rendu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberSignature Language="F#" Value="abstract member EnsureChildControls : unit -&gt; unit&#xA;override this.EnsureChildControls : unit -&gt; unit" Usage="control.EnsureChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si le contrôle serveur contient des contrôles enfants. S'il ne contient pas de contrôles enfants, il en crée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vérifie d’abord la valeur actuelle de la <xref:System.Web.UI.Control.ChildControlsCreated%2A> propriété. Si cette valeur est `false`, le <xref:System.Web.UI.Control.CreateChildControls%2A> méthode est appelée.  
  
 Le <xref:System.Web.UI.Control.EnsureChildControls%2A> méthode est généralement utilisée dans les contrôles composites, qui sont des contrôles qui utilisent des contrôles enfants pour tout ou partie de leurs fonctionnalités. Le <xref:System.Web.UI.Control.EnsureChildControls%2A> méthode est appelée pour vous assurer que les contrôles enfants ont été créés et sont prêts à traiter l’entrée, pour effectuer la liaison de données, ou effectuer d’autres tâches.  
  
 Le <xref:System.Web.UI.WebControls.GridView> contrôle est un exemple d’un contrôle composite. Il crée des contrôles enfants tels que <xref:System.Web.UI.WebControls.Table>, <xref:System.Web.UI.WebControls.TableRow>, <xref:System.Web.UI.WebControls.TableCell>, <xref:System.Web.UI.WebControls.Label>, et <xref:System.Web.UI.WebControls.TextBox> contrôles, qui sont utilisés pour restituer le code HTML de table qui la <xref:System.Web.UI.WebControls.GridView> génère.  
  
 Dans la plupart des cas, les développeurs de contrôles serveur personnalisés n’ont pas de substituer cette méthode. Si vous substituez cette méthode, utilisez-le de manière similaire au comportement par défaut.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Web.UI.Control.EnsureChildControls%2A> méthode pour garantir que le contrôle serveur en cours possède des contrôles enfants. Elle puis d’Obtient ou définit un <xref:System.Web.UI.WebControls.TextBox.Text%2A> propriété pour un enfant <xref:System.Web.UI.WebControls.TextBox> contrôle dans du contrôle actuel serveur Web <xref:System.Web.UI.ControlCollection> objet.  
  
> [!IMPORTANT]
>  Cet exemple comprend une zone de texte qui accepte une entrée d'utilisateur, ce qui constitue une menace potentielle pour la sécurité. Par défaut, les pages web ASP.NET vérifient que l’entrée d’utilisateur n’inclut pas de script ou d’éléments HTML. Pour plus d’informations, consultez [Vue d’ensemble des attaques de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberSignature Language="F#" Value="member this.EnsureID : unit -&gt; unit" Usage="control.EnsureID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un identificateur pour les contrôles auxquels aucun identificateur n'est assigné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.EnsureID%2A> méthode génère un identificateur pour les contrôles qui sont contenus dans un autre contrôle. Les identificateurs sont générés uniquement pour les contrôles qui n’ont pas de valeur assignée à la <xref:System.Web.UI.Control.ID%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Events : System.ComponentModel.EventHandlerList" Usage="System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la liste des délégués de gestionnaires d'événements pour le contrôle. Cette propriété est en lecture seule.</summary>
        <value>Liste des délégués de gestionnaires d'événements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est de type <xref:System.ComponentModel.EventHandlerList>, qui utilise un algorithme de recherche linéaire pour rechercher des entrées dans la liste des délégués. Un algorithme de recherche linéaire est inefficace lorsque vous travaillez avec un grand nombre d’entrées. Par conséquent, lorsque vous avez une grande liste, recherche d’entrées avec cette propriété seront lentes.  
  
   
  
## Examples  
 L’exemple suivant crée un événement nommé `Click`, qui ajoute et supprime les gestionnaires à partir du contrôle <xref:System.ComponentModel.EventHandlerList> collection lorsque l’événement est appelé à partir d’une page.  
  
 **Remarque** cet exemple optimise comment un contrôle ajoute et supprime des événements de la liste qui conserve le contrôle. Si vous créez le contrôle personnalisé et que vous souhaitez définir un événement, utilisez le code similaire à celui-ci. Cette technique peut être utilisée dans c#, mais pas dans Visual Basic.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche le contrôle serveur spécifié dans le conteneur d'attribution de noms en cours.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string -&gt; System.Web.UI.Control&#xA;override this.FindControl : string -&gt; System.Web.UI.Control" Usage="control.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Identificateur du contrôle à rechercher.</param>
        <summary>Recherche un contrôle serveur possédant le paramètre <paramref name="id" /> spécifié dans le conteneur d'attribution de noms actuel.</summary>
        <returns>Contrôle spécifié, ou <see langword="null" /> s'il n'existe pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Web.UI.Control.FindControl%2A> accéder à un contrôle à partir d’une fonction dans une page code-behind, accéder à un contrôle qui se trouve dans un autre conteneur ou dans d’autres circonstances où le contrôle cible n’est pas directement accessible à l’appelant. Cette méthode trouve un contrôle uniquement si le contrôle est directement contenu dans le conteneur spécifié ; Autrement dit, la méthode ne recherche pas tout au long d’une hiérarchie des contrôles dans les contrôles. Pour plus d’informations sur la recherche d’un contrôle lorsque vous ne connaissez pas son conteneur immédiat, consultez [Comment : Contrôles de serveur par ID d’accès](https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3).  
  
   
  
## Examples  
 L’exemple suivant définit un `Button1_Click` Gestionnaire d’événements. Lorsqu’elle est appelée, ce gestionnaire utilise la <xref:System.Web.UI.Control.FindControl%2A> méthode pour localiser un contrôle avec une <xref:System.Web.UI.Control.ID%2A> propriété du `TextBox2` sur la page conteneur. Si le contrôle est localisé, son parent est déterminée en utilisant la <xref:System.Web.UI.Control.Parent%2A> propriété et le contrôle parent <xref:System.Web.UI.Control.ID%2A> est écrite dans la page. Si `TextBox2` n’est pas trouvée, « Contrôle Not Found » est écrite dans la page.  
  
> [!IMPORTANT]
>  Cet exemple comprend une zone de texte qui accepte une entrée d'utilisateur, ce qui constitue une menace potentielle pour la sécurité. Par défaut, les pages web ASP.NET vérifient que l’entrée d’utilisateur n’inclut pas de script ou d’éléments HTML. Pour plus d’informations, consultez [Vue d’ensemble des attaques de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3">Procédure : Contrôles de serveur d’accès par ID</related>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string * int -&gt; System.Web.UI.Control&#xA;override this.FindControl : string * int -&gt; System.Web.UI.Control" Usage="control.FindControl (id, pathOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">Identificateur du contrôle à rechercher.</param>
        <param name="pathOffset">Nombre de contrôles en haut de la hiérarchie des contrôles de la page nécessaires pour atteindre un conteneur de dénomination (naming container).</param>
        <summary>Recherche le conteneur d'attribution de noms actuel d'un contrôle serveur avec l'<paramref name="id" /> spécifié et un entier, spécifié dans le paramètre <paramref name="pathOffset" />, qui facilite la recherche. Vous ne devez pas substituer cette version de la méthode <see cref="Overload:System.Web.UI.Control.FindControl" />.</summary>
        <returns>Contrôle spécifié, ou <see langword="null" /> s'il n'existe pas.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; unit&#xA;override this.Focus : unit -&gt; unit" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Affecte le focus d'entrée à un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.Control.Focus%2A> pour définir le focus initial de la page Web au contrôle. La page s’ouvre dans le navigateur avec le contrôle sélectionné.  
  
 Le <xref:System.Web.UI.Control.Focus%2A> méthode provoque un appel au script de focus de page sur la page rendue. Si la page ne contient pas un contrôle avec HTML `ID` attribut qui correspond au contrôle qui le <xref:System.Web.UI.Control.Focus%2A> méthode a été appelée sur, puis le focus de page ne sera pas défini. Un exemple où cela peut se produire est lorsque vous définissez le focus sur un contrôle utilisateur au lieu de définir le focus sur un contrôle enfant du contrôle utilisateur. Dans ce scénario, vous pouvez utiliser la <xref:System.Web.UI.Control.FindControl%2A> méthode pour rechercher le contrôle enfant du contrôle utilisateur et appeler ses <xref:System.Web.UI.Control.Focus%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberSignature Language="F#" Value="abstract member GetDesignModeState : unit -&gt; System.Collections.IDictionary&#xA;override this.GetDesignModeState : unit -&gt; System.Collections.IDictionary" Usage="control.GetDesignModeState " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les données au moment du design pour un contrôle.</summary>
        <returns><see cref="T:System.Collections.IDictionary" /> contenant les données au moment du design du contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.GetDesignModeState%2A> méthode retourne les données au moment du design pour un contrôle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Le <see cref="M:System.Web.UI.Control.GetDesignModeState" /> méthode retourne <see langword="null" /> par défaut. Vous devez substituer cette méthode pour fournir les données au moment du design que requises par votre contrôle.</para></block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient l'URL qui correspond à un jeu de paramètres d'itinéraire, et éventuellement à un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : obj -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Paramètres d'itinéraire.</param>
        <summary>Obtient l'URL qui correspond à un jeu de paramètres d'itinéraire.</summary>
        <returns>URL qui correspond aux paramètres d'itinéraire spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> (méthode). Cette méthode convertit l’objet qui est passé dans `routeParameters` à un <xref:System.Web.Routing.RouteValueDictionary> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler le <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType> méthode pour obtenir l’URL d’un itinéraire qui a des paramètres nommés `productid` et `category`. Cet exemple suppose que vous avez créé un <xref:System.Web.UI.WebControls.HyperLink> contrôle nommé `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Paramètres d'itinéraire.</param>
        <summary>Obtient l'URL qui correspond à un jeu de paramètres d'itinéraire.</summary>
        <returns>URL qui correspond aux paramètres d'itinéraire spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour obtenir l’URL d’un itinéraire qui a des paramètres nommés `productid` et `category`. Cet exemple suppose que vous avez créé un <xref:System.Web.UI.WebControls.HyperLink> contrôle nommé `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * obj -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l’itinéraire.</param>
        <param name="routeParameters">Paramètres d'itinéraire.</param>
        <summary>Obtient l'URL qui correspond à un jeu de paramètres d'itinéraire et à un nom d'itinéraire.</summary>
        <returns>URL qui correspond aux paramètres d'itinéraire et au nom d'itinéraire spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> (méthode). Cette méthode convertit l’objet qui est passé dans `routeParameters` à un <xref:System.Web.Routing.RouteValueDictionary> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour obtenir l’URL d’un itinéraire qui est nommé `Product` et a des paramètres nommés `productid` et `category`. Cet exemple suppose que vous avez créé un <xref:System.Web.UI.WebControls.HyperLink> contrôle nommé `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l’itinéraire.</param>
        <param name="routeParameters">Paramètres d'itinéraire.</param>
        <summary>Obtient l'URL qui correspond à un jeu de paramètres d'itinéraire et à un nom d'itinéraire.</summary>
        <returns>URL qui correspond aux paramètres d'itinéraire et au nom d'itinéraire spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour obtenir l’URL d’un itinéraire qui est nommé `Product` et a des paramètres nommés `productid` et `category`. Cet exemple suppose que vous avez créé un <xref:System.Web.UI.WebControls.HyperLink> contrôle nommé `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetUniqueIDRelativeTo : System.Web.UI.Control -&gt; string" Usage="control.GetUniqueIDRelativeTo control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle qui est dans un conteneur d'attribution de noms.</param>
        <summary>Retourne la partie préfixée de la propriété <see cref="P:System.Web.UI.Control.UniqueID" /> du contrôle spécifié.</summary>
        <returns>Partie préfixée de la propriété <see cref="P:System.Web.UI.Control.UniqueID" /> du contrôle spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.UniqueID%2A> propriété d’un contrôle est générée en ajoutant un préfixe pour le contrôle <xref:System.Web.UI.Control.ID%2A> propriété. Le préfixe est composé de la <xref:System.Web.UI.Control.UniqueID%2A> propriété du contrôle d’attribution de noms conteneur concaténée avec un caractère de séparation. Si le conteneur d’attribution de noms est la page, il n’existe aucun préfixe. Cette méthode retourne la chaîne de préfixe. S’il n’y a aucune chaîne de préfixe, il retourne le <xref:System.Web.UI.Control.UniqueID%2A> valeur du contrôle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Web.UI.Control.NamingContainer" /> de <paramref name="control" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildViewState : bool" Usage="System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si les contrôles enfants du contrôle serveur en cours possèdent des paramètres d'état d'affichage enregistrés.</summary>
        <value><see langword="true" /> si des contrôles enfants possèdent des informations d'état d'affichage enregistrées ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez éviter les appels inutiles à la <xref:System.Web.UI.Control.ClearChildViewState%2A> méthode à l’aide de cette propriété pour vérifier que tous les contrôles enfants du contrôle serveur stockent des informations d’état d’affichage.  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberSignature Language="F#" Value="abstract member HasControls : unit -&gt; bool&#xA;override this.HasControls : unit -&gt; bool" Usage="control.HasControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si le contrôle serveur contient des contrôles enfants.</summary>
        <returns><see langword="true" /> si le contrôle contient d'autres contrôles ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans la mesure où cette méthode détermine simplement si des contrôles enfants existent, elle peut améliorer les performances en vous permettant d’éviter un inutiles <xref:System.Web.UI.ControlCollection.Count%2A> appel de la propriété. Les appels à cette propriété requièrent un <xref:System.Web.UI.ControlCollection> objet à instancier. S’il n’y a pas d’enfants, la création de cet objet gaspille des ressources de serveur.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Web.UI.Control.HasControls%2A> méthode pour déterminer si des contrôles existent avant d’utiliser le <xref:System.Web.UI.ControlCollection.Count%2A> propriété pour itérer un <xref:System.Web.UI.ControlCollection> objet.  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Le <see cref="M:System.Web.UI.Control.HasControls" /> méthode doit être substituée uniquement pour modifier les attributs de métadonnées telles que <see cref="T:System.ComponentModel.EditorBrowsableAttribute" />. Pour plus d’informations sur l’utilisation d’attributs, consultez [attributs](~/docs/standard/attributes/index.md).</para></block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberSignature Language="F#" Value="member this.HasEvents : unit -&gt; bool" Usage="control.HasEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si des événements sont inscrits pour le contrôle ou des contrôles enfants.</summary>
        <returns><see langword="true" /> si des événements sont inscrits ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'ID programmatique assigné au contrôle serveur.</summary>
        <value>ID programmatique assigné au contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de cette propriété sur un contrôle serveur vous offre un accès par programmation aux propriétés, événements et méthodes du contrôle serveur. Cette propriété peut être définie par les développeurs Web en déclarant un <xref:System.Web.UI.Control.ID%2A> attribut dans la balise d’ouverture d’un contrôle serveur ASP.NET.  
  
 Si cette propriété n’est pas spécifiée pour un contrôle serveur, soit de manière déclarative ou par programme, vous pouvez obtenir une référence au contrôle par le biais de son contrôle parent <xref:System.Web.UI.Control.Controls%2A> propriété.  
  
> [!NOTE]
>  Seules les combinaisons de caractères alphanumériques et le caractère de soulignement (_) sont des valeurs valides pour cette propriété. Y compris les espaces ou autres caractères non valides provoque une erreur d’analyseur de page ASP.NET.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le caractère utilisé pour séparer des identificateurs de contrôle.</summary>
        <value>Caractère de séparation. La valeur par défaut est "$".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le caractère contenu dans le <xref:System.Web.UI.Control.IdSeparator%2A> propriété est utilisée pour séparer les identificateurs de contrôle pour les contrôles enfants. Le caractère de séparation de code est ajouté à la <xref:System.Web.UI.Control.ID%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberSignature Language="F#" Value="member this.Init : EventHandler " Usage="member this.Init : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contrôle serveur est initialisé, ce qui constitue la première étape de son cycle de vie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les contrôles serveur doivent effectuer les étapes d’initialisation qui sont nécessaires pour créer et configurer une instance. Vous ne pouvez pas utiliser les informations d’état d’affichage au sein de cet événement ; Il n’est pas encore rempli. Vous ne devez pas accéder à un autre contrôle serveur pendant cet événement, qu’il s’agisse d’un enfant ou le parent de ce contrôle. Autres contrôles serveur ne sont pas certains créé et prêt pour l’accès. Pour plus d’informations sur les événements de contrôle de serveur, consultez [modèle d’événement ASP.NET Web Forms Server contrôle](https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
   
  
## Examples  
 L’exemple suivant assigne un gestionnaire d’événements personnalisé, `Calendar_Init`, à la `Init` événement d’un <xref:System.Web.UI.WebControls.Calendar> contrôle.  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsChildControlStateCleared : bool" Usage="System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si les contrôles contenus dans ce contrôle utilisent l'état du contrôle.</summary>
        <value><see langword="true" /> si les enfants de ce contrôle n'utilisent pas l'état du contrôle ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberSignature Language="F#" Value="member this.IsLiteralContent : unit -&gt; bool" Usage="control.IsLiteralContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si le contrôle serveur ne détient qu'un contenu littéral.</summary>
        <returns><see langword="true" /> si le contrôle serveur est uniquement composé de contenu littéral ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode retourne `true`, collection du contrôle de serveur conserve un seul contrôle littéral.  
  
   
  
## Examples  
 L’exemple suivant vérifie si la page qui contient les contrôles serveur a publiée. S’il possède, il appelle le <xref:System.Web.UI.Control.IsLiteralContent%2A> méthode pour déterminer si le contrôle contient uniquement un contenu littéral, ou est un contrôle parent à d’autres contrôles serveur. S’il contient uniquement un contenu littéral, la <xref:System.Web.UI.Control.UniqueID%2A> propriété de la <xref:System.Web.UI.LiteralControl> représentant ce contenu est écrit dans la réponse.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTrackingViewState : bool" Usage="System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le contrôle serveur enregistre les modifications apportées à son état d'affichage.</summary>
        <value><see langword="true" /> si le contrôle serveur est marqué pour enregistrer son état ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour un exemple de contrôle serveur personnalisé qui utilise cette propriété, consultez [exemple de contrôle de serveur basé sur un modèle](https://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.DataBind%2A> méthode dans un contrôle de serveur ASP.NET personnalisé. Il commence par appeler la base de <xref:System.Web.UI.Control.OnDataBinding%2A> (méthode), puis utilise le `ControlCollection` objet. <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> méthode pour supprimer tous les contrôles enfants et la <xref:System.Web.UI.Control.ClearChildViewState%2A> méthode pour supprimer tout état d’affichage paramètres enregistrés pour ces contrôles enfants. Enfin, le <xref:System.Web.UI.Control.ChildControlsCreated%2A> propriété est définie sur `true`. Le contrôle utilise ensuite le <xref:System.Web.UI.Control.IsTrackingViewState%2A> propriété afin de déterminer si l’état d’affichage de suivi est activé pour le contrôle. S’il n’est pas activé, le <xref:System.Web.UI.Control.TrackViewState%2A> méthode est appelée.  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsViewStateEnabled : bool" Usage="System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'état d'affichage est activé pour ce contrôle.</summary>
        <value><see langword="true" /> si l'état d'affichage est activé pour le contrôle ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 État d’affichage peut être activé à la page, le conteneur ou le niveau de contrôle. Lorsque l’état d’affichage est désactivé au niveau de la page ou du conteneur, l’état d’affichage est désactivé pour tous les contrôles contenus dans la page ou le conteneur. Le <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propriété indique si l’état d’affichage est activé par les pages, les conteneurs ou les contrôles.  
  
 Il est possible pour le <xref:System.Web.UI.Control.EnableViewState%2A> propriété et le <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propriété soit différent. Par exemple, si le <xref:System.Web.UI.Page> contenant le contrôle est désactivé, l’état d’affichage le <xref:System.Web.UI.Control.EnableViewState%2A> propriété peut être `true` tandis que le <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propriété est `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs de pages définira le <see cref="P:System.Web.UI.Control.EnableViewState" /> propriété et le <see cref="P:System.Web.UI.Control.ViewStateMode" /> propriété pour indiquer s’ils sont l’état d’affichage avec votre contrôle. Utilisez le <see cref="P:System.Web.UI.Control.IsViewStateEnabled" /> propriété et le <see cref="P:System.Web.UI.Control.ViewStateMode" /> propriété dans votre code pour déterminer si l’état d’affichage est activé pour votre contrôle et tous les conteneurs.</para></block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contrôle serveur est chargé dans l'objet <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avertit le contrôle de serveur à effectuer les étapes de traitement sont définies pour survenir sur chaque demande de page. Vous pouvez accéder informations état d’affichage et les données de publication de Web form à partir de cet événement. Vous pouvez également accéder d’autres contrôles serveur dans la hiérarchie des contrôles de la page.  
  
> [!NOTE]
>  Si vous définissez un modèle personnalisé dans un contrôle pendant le `Page_Load` événement, les valeurs texte des contrôles enfants dans le modèle personnalisé seront perdues. Cela se produit, car les valeurs de formulaire ont déjà été chargés.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadControlState : obj -&gt; unit&#xA;override this.LoadControlState : obj -&gt; unit" Usage="control.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="savedState"><see cref="T:System.Object" /> représentant l'état du contrôle à restaurer.</param>
        <summary>Restaure des informations sur l'état du contrôle à partir d'une demande de page antérieure enregistrée par la méthode <see cref="M:System.Web.UI.Control.SaveControlState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode lorsque vous avez besoin spécifier comment un contrôle serveur personnalisé restaure son état. Pour plus d’informations, consultez [ASP.NET State Management Overview](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).  
  
   
  
## Examples  
 Les éléments suivants exemple de code remplace le <xref:System.Web.UI.Control.LoadControlState%2A> méthode dans un contrôle ASP.NET personnalisé. Lorsque cette méthode est appelée, elle détermine si l’état du contrôle a été précédemment enregistré pour le contrôle et, dans ce cas, définit la propriété interne `currentIndex` à la valeur enregistrée.  
  
 Le <xref:System.Web.UI.Control.OnInit%2A> méthode est substituée pour appeler le <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> méthode sur le <xref:System.Web.UI.Control.Page%2A> pour indiquer que le contrôle personnalisé utilise l’état du contrôle.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadViewState : obj -&gt; unit&#xA;override this.LoadViewState : obj -&gt; unit" Usage="control.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState"><see cref="T:System.Object" /> représentant l'état du contrôle à restaurer.</param>
        <summary>Restaure les informations d'état d'affichage à partir d'une demande de page antérieure qui a été enregistrée par la méthode <see cref="M:System.Web.UI.Control.SaveViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est principalement utilisée par l’infrastructure .NET Framework et n’est pas destinée à être utilisée directement depuis votre code. Toutefois, les développeurs de contrôles peuvent substituer cette méthode pour spécifier comment un contrôle serveur personnalisé restaure son état d’affichage. Pour plus d’informations, consultez [ASP.NET State Management Overview](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.LoadViewState%2A> méthode pour un contrôle de serveur ASP.NET personnalisé. Il crée un <xref:System.Object> tableau destiné à contenir les informations d’état de vue transmies dans le `savedState` paramètre, puis appelle l’implémentation de base de la <xref:System.Web.UI.Control.LoadViewState%2A> méthode pour le premier emplacement d’index du tableau. Il assigne les valeurs stockées aux deux emplacements d’index pour les variables nommées `UserText` et `PasswordText`, respectivement.  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadViewStateByID : bool" Usage="System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le contrôle participe au chargement de son état d'affichage par <see cref="P:System.Web.UI.Control.ID" /> et non par index.</summary>
        <value><see langword="true" /> si le contrôle charge son état d'affichage par <see cref="P:System.Web.UI.Control.ID" /> ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, lorsqu’un contrôle parent charge l’état d’affichage dans les contrôles enfants qu’il crée, il procède à la position de chaque contrôle enfant dans le contrôle parent <xref:System.Web.UI.Control.Controls%2A> collection. Lorsque l’état d’affichage est appliqué au départ, tous les contrôles enfants ne peuvent pas avoir été créés. Dans ce cas, l’état d’affichage pour les contrôles ne sont pas encore créé est enregistré et appliqué lorsque les contrôles enfants sont créés ultérieurement.  
  
 Pour un contrôle parent appliquer l’état d’affichage à ses contrôles enfants, deux conditions doivent être remplies :  
  
-   Lors de la publication, le contrôle parent doit créer les contrôles enfants dans exactement le même ordre que la demande précédente afin que l’ordre des contrôles reste cohérent.  
  
-   Après la publication (postback), tous les contrôles enfants créés doivent être ajoutés à la fin du contrôle parent <xref:System.Web.UI.Control.Controls%2A> collection.  
  
 Si ces deux conditions ne peuvent pas être satisfaites, comme dans le cas de la création différée d’un contrôle enfant, le contrôle parent peut charger l’état d’affichage à l’aide de <xref:System.Web.UI.Control.ID%2A>. Pour définir le <xref:System.Web.UI.Control.LoadViewStateByID%2A> propriété `true`, utilisez le <xref:System.Web.UI.ViewStateModeByIdAttribute> attribut de métadonnées pour le contrôle parent.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPathSecure : string -&gt; string" Usage="control.MapPathSecure virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">URL relative ou relative à la racine.</param>
        <summary>Récupère le chemin d'accès physique auquel un chemin d'accès virtuel, absolu ou relatif, correspond.</summary>
        <returns>Chemin d'accès physique du fichier demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut uniquement être utilisée par les contrôles serveur qui ont des autorisations de lecture de fichiers et qui font partie de fichiers .dll entièrement fiables, tels que System.Web.dll. Cela permet d’éviter les failles de sécurité.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Web.UI.Control.MapPathSecure%2A> méthode pour obtenir le chemin d’accès physique d’un répertoire virtuel du contenant <xref:System.Web.UI.Page> ou <xref:System.Web.UI.UserControl> objet.  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> ou <see langword="null" /> est une chaîne vide ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au conteneur d'attribution de noms du contrôle serveur, qui crée un espace de noms unique pour différencier les contrôles serveur dont la propriété <see cref="P:System.Web.UI.Control.ID" /> possède la même valeur.</summary>
        <value>Conteneur d'attribution de noms du contrôle serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque page dans une application Web ASP.NET contient une hiérarchie de contrôles. Cette hiérarchie n’est pas dépendante d’indique si un contrôle génère une interface utilisateur visible par l’utilisateur. Le conteneur d’attribution de noms pour un contrôle donné est le contrôle parent au-dessus de lui dans la hiérarchie qui implémente le <xref:System.Web.UI.INamingContainer> interface. Un contrôle serveur qui implémente cette interface crée un espace de noms unique pour le <xref:System.Web.UI.Control.ID%2A> des valeurs de propriété de ses contrôles serveur enfants. Vous pouvez utiliser le <xref:System.Web.UI.Control.NamingContainer%2A> propriété du contrôle d’enfants d’un conteneur d’attribution de noms pour obtenir une référence à son conteneur parent.  
  
 Création d’un espace de noms unique pour les contrôles serveur est particulièrement important lorsque vous liez les contrôles serveur Web aux données, telles que la <xref:System.Web.UI.WebControls.Repeater> et <xref:System.Web.UI.WebControls.DataList> contrôles serveur. Lorsque plusieurs entrées dans la source de données créent plusieurs instances d’un contrôle serveur qui est un enfant du contrôle répété, le conteneur d’attribution de noms garantit que chaque instance de ces contrôles enfants ont <xref:System.Web.UI.Control.UniqueID%2A> les valeurs de propriété qui ne pas en conflit. Le conteneur d’attribution de noms par défaut pour une page est l’instance de la <xref:System.Web.UI.Page> classe qui est généré lorsque la page est demandée.  
  
 Le <xref:System.Web.UI.Control.ClientID%2A> propriété contient la valeur qui est restituée sous forme de l’élément `id` attribut dans le balisage HTML. Selon la valeur que vous attribuez à la <xref:System.Web.UI.Control.ClientIDMode%2A> propriété, la valeur est générée pour le <xref:System.Web.UI.Control.ClientID%2A> propriété peut-être inclure l’ID de la <xref:System.Web.UI.Control.NamingContainer%2A> objet. Lorsque vous définissez <xref:System.Web.UI.Control.ClientIDMode%2A> à <xref:System.Web.UI.ClientIDMode.Static>, le <xref:System.Web.UI.Control.ClientID%2A> valeur n’inclut pas l’ID de la <xref:System.Web.UI.Control.NamingContainer%2A> objet. Lorsque vous définissez <xref:System.Web.UI.Control.ClientIDMode%2A> soit <xref:System.Web.UI.ClientIDMode.AutoID> ou <xref:System.Web.UI.ClientIDMode.Predictable>, le <xref:System.Web.UI.Control.ClientID%2A> valeur inclut l’ID de la <xref:System.Web.UI.Control.NamingContainer%2A> objet. Pour plus d’informations, consultez [Identification du contrôle serveur web ASP.NET](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.UI.Control.NamingContainer%2A> propriété.  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBubbleEvent : obj * EventArgs -&gt; bool&#xA;override this.OnBubbleEvent : obj * EventArgs -&gt; bool" Usage="control.OnBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Source de l'événement.</param>
        <param name="args">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Détermine si l’événement du contrôle serveur est passé dans la hiérarchie des contrôles serveur de l’interface utilisateur de la page.</summary>
        <returns><see langword="true" /> si l'événement a été annulé ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrôles serveur ASP.NET, tels que le <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> et <xref:System.Web.UI.WebControls.GridView> contrôles Web peuvent contenir des contrôles enfants qui déclenchent des événements. Par exemple, chaque ligne dans un <xref:System.Web.UI.WebControls.GridView> contrôle peut contenir un ou plusieurs boutons créés dynamiquement par les modèles. Chaque bouton individuellement, les événements provenant des contrôles imbriqués sont « propagés » : autrement dit, ils sont envoyés vers le conteneur d’attribution de noms. Le conteneur de dénomination à son tour déclenche un événement générique appelé <xref:System.Web.UI.WebControls.GridView.RowCommand> avec les valeurs de paramètre. Ces valeurs permettent de déterminer le contrôle qui a déclenché l’événement d’origine. En répondant à cet événement, vous pouvez éviter d’avoir à écrire des méthodes de gestion des événements individuels pour les contrôles enfants.  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.OnBubbleEvent%2A> méthode dans un contrôle serveur ASP.NET personnalisé, `ParentControl`. Cette méthode est appelée lorsqu’un contrôle enfant de `ParentControl` appelle le <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> (méthode). Dans ce cas, le `ParentControl` classe écrit deux chaînes dans la page ASP.NET conteneur, la première indiquant que sa <xref:System.Web.UI.Control.OnBubbleEvent%2A> méthode a été appelée, la seconde identifiant le contrôle de source de la <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> (méthode).  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataBinding : EventArgs -&gt; unit&#xA;override this.OnDataBinding : EventArgs -&gt; unit" Usage="control.OnDataBinding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode avertit un contrôle serveur pour exécuter la logique pour la liaison de données qui lui sont associées.  
  
 Si vous souhaitez gérer le <xref:System.Web.UI.Control.DataBinding> événement, vous devez substituer cette méthode de gestion des événements. Cela garantit que tous les délégués attachés à la <xref:System.Web.UI.Control.DataBinding> événement sont appelées.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer la <xref:System.Web.UI.Control.OnDataBinding%2A> méthode pour ajouter des contrôles enfants au contrôle parent à partir d’une source de données.  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Vue d’ensemble du Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="control.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Init" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET appelle cette méthode pour déclencher le <xref:System.Web.UI.Control.Init> événement. Si vous développez un contrôle personnalisé, vous pouvez substituer cette méthode afin de fournir un traitement supplémentaire. Si vous substituez cette méthode, appelez le contrôle de base <xref:System.Web.UI.Control.OnInit%2A> méthode pour notifier les abonnés à l’événement.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="control.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Load" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET appelle cette méthode pour déclencher le <xref:System.Web.UI.Control.Load> événement. Si vous développez un contrôle personnalisé, vous pouvez substituer cette méthode afin de fournir un traitement supplémentaire. Si vous substituez cette méthode, appelez le contrôle de base <xref:System.Web.UI.Control.OnLoad%2A> méthode pour notifier les abonnés à l’événement.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="control.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.PreRender" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET appelle cette méthode pour déclencher le <xref:System.Web.UI.Control.PreRender> événement. Si vous développez un contrôle personnalisé, vous pouvez substituer cette méthode afin de fournir un traitement supplémentaire. Si vous substituez cette méthode, appelez le contrôle de base <xref:System.Web.UI.Control.OnPreRender%2A> méthode pour notifier les abonnés à l’événement.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="control.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Unload" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET appelle cette méthode pour déclencher le <xref:System.Web.UI.Control.Unload> événement. Si vous développez un contrôle personnalisé, vous pouvez substituer cette méthode afin de fournir un traitement supplémentaire. Si vous substituez cette méthode, appelez le contrôle de base <xref:System.Web.UI.Control.OnUnload%2A> méthode pour notifier les abonnés à l’événement.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string -&gt; System.IO.Stream" Usage="control.OpenFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier désiré.</param>
        <summary>Obtient un <see cref="T:System.IO.Stream" /> utilisé pour lire un fichier.</summary>
        <returns><see cref="T:System.IO.Stream" /> qui référence le fichier désiré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.OpenFile%2A> méthode retourne un <xref:System.IO.Stream> objet qui peut être utilisé pour lire le contenu du fichier spécifié dans le `path` paramètre. Le paramètre de chemin d’accès peut être soit relatif ou URL racine sans protocole (tel que « ~ / ~/MonSite/MonFichier.txt), ou un chemin d’accès physique, local (« c:\mySite\myFile.txt ») ou UNC («\\\myServer\myFile.txt »).  
  
 Le <xref:System.Web.UI.Control.OpenFile%2A> méthode utilise la sécurité d’accès du fichier pour contrôler l’accès au fichier spécifié. Si l’utilisateur ASP.NET en cours n’a pas accès au fichier, puis le fichier n’est pas ouvert et qu’un <xref:System.Web.HttpException> exception est levée pour indiquer que l’accès a été refusé. Si le `path` paramètre spécifié un chemin d’accès relatif, l’exception n’inclut pas d’informations sur le chemin d’accès physique au fichier demandé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'accès au fichier spécifié a été refusé.</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page with get, set" Usage="System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à l'instance de <see cref="T:System.Web.UI.Page" /> qui contient le contrôle serveur.</summary>
        <value>Instance de <see cref="T:System.Web.UI.Page" /> qui contient le contrôle serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Valeur de cette propriété reflète le nom du fichier .aspx qui contient le contrôle serveur.  
  
   
  
## Examples  
 L'exemple suivant substitue la méthode <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>. Il utilise le <xref:System.Web.UI.Page> propriété pour accéder à la <xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType> propriété et déterminez si la page qui contient ce contrôle a simplement été chargée pour la première fois ou est le résultat d’une publication (postback).  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le contrôle est un contrôle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Web.UI.Control" Usage="System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au contrôle parent du contrôle serveur dans la hiérarchie des contrôles de la page.</summary>
        <value>Référence à un contrôle parent du contrôle serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque fois qu’une page est demandée, une hiérarchie des contrôles serveur sur cette page est générée. Cette propriété vous permet de déterminer le contrôle parent du contrôle serveur en cours de cette hiérarchie et du programmer.  
  
   
  
## Examples  
 L’exemple suivant définit un nouvel <xref:System.Web.UI.Control> objet sur une page, `myControl1`, le contrôle spécifié dans un <xref:System.Web.UI.Control.FindControl%2A> appel de méthode. Si l’appel retourne un contrôle, le code utilise le <xref:System.Web.UI.Control.Parent%2A> propriété pour identifier le contrôle qui contient `myControl1`. Si le contrôle parent existe, la chaîne « le parent de la zone de texte est » est concaténé avec la <xref:System.Web.UI.Control.ID%2A> propriété du contrôle parent et écrite dans le <xref:System.Web.UI.Control.Page%2A>. Si aucun contrôle parent n’est trouvée, la chaîne « contrôle not found » est écrit.  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberSignature Language="F#" Value="member this.PreRender : EventHandler " Usage="member this.PreRender : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après le chargement de l'objet <see cref="T:System.Web.UI.Control" /> mais avant le rendu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cet événement pour effectuer des mises à jour avant que le contrôle serveur est restitué à la page. Les modifications apportées à l’état d’affichage du contrôle serveur peuvent être enregistrées pendant cet événement. De telles modifications apportées pendant la phase de rendu ne seront pas enregistrées.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.RaiseBubbleEvent : obj * EventArgs -&gt; unit" Usage="control.RaiseBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Source de l'événement.</param>
        <param name="args">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Assigne les sources éventuelles de l'événement et ses informations au parent du contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrôles serveur ASP.NET, tels que le <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> et <xref:System.Web.UI.WebControls.GridView> contrôles Web peuvent contenir des contrôles enfants qui déclenchent des événements. Par exemple, chaque ligne dans un <xref:System.Web.UI.WebControls.GridView> contrôle peut contenir un ou plusieurs boutons créés dynamiquement par les modèles. Chaque bouton individuellement, les événements provenant des contrôles imbriqués sont « propagés » : autrement dit, ils sont envoyés au parent du contrôle. À son tour, le parent déclenche un événement générique appelé <xref:System.Web.UI.WebControls.GridView.RowCommand> avec les valeurs de paramètre. Ces valeurs permettent de déterminer le contrôle qui a déclenché l’événement d’origine. En répondant à cet événement, vous pouvez éviter d’avoir à écrire des méthodes de gestion des événements individuels pour les contrôles enfants.  
  
 Même si vous ne pouvez pas substituer cette méthode, les contrôles que vous créez peuvent traiter ou déclencher des événements propagés en substituant le <xref:System.Web.UI.Control.OnBubbleEvent%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivants montrent comment créer une classe personnalisée, `ChildControl`, qui substitue le <xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType> méthode à appeler le <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> méthode envoie le <xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType> événement à son parent du contrôle serveur ASP.NET. Lorsque l’utilisateur clique sur un bouton dans une page ASP.NET qui inclut une instance de `ChildControl`, il déclenche le <xref:System.Web.UI.Control.OnBubbleEvent%2A> méthode sur le contrôle parent qui contient l’instance de `ChildControl` et écrit la chaîne « la ChildControl class OnClick est (méthode) appelée » à la page.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RemovedControl : System.Web.UI.Control -&gt; unit&#xA;override this.RemovedControl : System.Web.UI.Control -&gt; unit" Usage="control.RemovedControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.Control" /> qui a été supprimé.</param>
        <summary>Méthode appelée après la suppression d’un contrôle enfant de la collection <see cref="P:System.Web.UI.Control.Controls" /> de l’objet <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.RemovedControl%2A> méthode est appelée immédiatement après un contrôle est supprimé de la <xref:System.Web.UI.Control.Controls%2A> collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le contrôle est un contrôle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.Web.UI.HtmlTextWriter" /> qui reçoit le contenu du contrôle serveur.</param>
        <summary>Envoie le contenu du contrôle serveur à un objet <see cref="T:System.Web.UI.HtmlTextWriter" />, qui écrit le contenu à rendre sur le client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous développez des contrôles serveur personnalisés, vous pouvez remplacer cette méthode pour générer le contenu d’une page ASP.NET.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la substitution de la <xref:System.Web.UI.Control.Render%2A> (méthode). Le <xref:System.Web.UI.Control.HasControls%2A> méthode est utilisée pour déterminer si le contrôle serveur possède des contrôles enfants stockés dans son <xref:System.Web.UI.ControlCollection> objet, qui est accessible via la <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propriété. Si <xref:System.Web.UI.Control.HasControls%2A> retourne la valeur true et le premier contrôle de serveur dans la collection est un texte littéral, puis le texte littéral est ajouté à une chaîne au format HTML.  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.Web.UI.HtmlTextWriter" /> qui reçoit le contenu rendu.</param>
        <summary>Renvoie le contenu des enfants d'un contrôle serveur dans un objet <see cref="T:System.Web.UI.HtmlTextWriter" /> fourni, qui écrit le contenu à rendre sur le client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode avertit ASP.NET restitue de n’importe quel code Active Server Pages (ASP) dans la page. Si aucun code ASP n’existe sur la page, cette méthode restitue les enfants des contrôles pour le contrôle serveur. Cette méthode est appelée par le <xref:System.Web.UI.Control.Render%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.RenderChildren%2A> méthode dans un contrôle serveur personnalisé. Il détermine si le contrôle actuel possède des contrôles enfants son <xref:System.Web.UI.ControlCollection> objet. Dans l’affirmative, il utilise le <xref:System.Web.UI.ControlCollection.Count%2A> propriété pour effectuer une itération dans la collection. Qu’il identifie chaque contrôle enfant, il utilise le <xref:System.Web.UI.Control.RenderControl%2A> méthode pour restituer le parent de contrôle et tous ses contrôles enfants, dans la page conteneur.  
  
 Substituées <xref:System.Web.UI.Control.Render%2A> méthode appelle ensuite substituées <xref:System.Web.UI.Control.RenderChildren%2A> (méthode).  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Extrait le contenu du contrôle serveur et stocke des informations de traçage au sujet du contrôle si le traçage est activé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderControl writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.Web.UI.HtmlTextWriter" /> qui reçoit le contenu du contrôle.</param>
        <summary>Envoie le contenu du contrôle serveur à un objet <see cref="T:System.Web.UI.HtmlTextWriter" /> fourni et stocke les informations de traçage sur le contrôle si le traçage est activé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un contrôle serveur <xref:System.Web.UI.Control.Visible%2A> propriété est définie sur `true`, cette méthode détermine si le traçage est activé pour la page. Dans ce cas, il stocke les informations de trace associées au contrôle et restitue le contenu du contrôle serveur à la page.  
  
 Cette méthode est appelée automatiquement par la page pendant le rendu, mais peut être substituée par les développeurs de contrôles personnalisés.  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.RenderChildren%2A> méthode dans un contrôle serveur personnalisé. Il détermine si le contrôle actuel possède des contrôles enfants son <xref:System.Web.UI.ControlCollection> objet. Dans l’affirmative, il utilise le <xref:System.Web.UI.ControlCollection.Count%2A> propriété pour effectuer une itération dans la collection. Qu’il identifie chaque contrôle enfant, il utilise le <xref:System.Web.UI.Control.RenderControl%2A> méthode pour restituer l’enfant, contrôle et tous ses contrôles enfants, dans la page conteneur. Le <xref:System.Web.UI.XhtmlTextWriter> objet est passé à cette méthode est instancié par le <xref:System.Web.UI.Page.Render%2A> (méthode).  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="member this.RenderControl : System.Web.UI.HtmlTextWriter * System.Web.UI.Adapters.ControlAdapter -&gt; unit" Usage="control.RenderControl (writer, adapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> qui reçoit le contenu du contrôle.</param>
        <param name="adapter"><see cref="T:System.Web.UI.Adapters.ControlAdapter" /> qui définit le rendu.</param>
        <summary>Génère le contenu du contrôle serveur dans un objet <see cref="T:System.Web.UI.HtmlTextWriter" /> à l'aide d'un objet <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les pages Web ASP.NET sont utilisables à travers une large gamme d’appareils et navigateurs qui peuvent demander des informations à partir du Web. Le <xref:System.Web.UI.Control.Adapter%2A> propriété retourne le <xref:System.Web.UI.Adapters.ControlAdapter> objet qui restitue le contrôle sur l’appareil demandeur ou l’écran de navigateur.  
  
 Pour plus d’informations à propos des adaptateurs, consultez [Architectural Overview of Adaptive Control Behavior](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)).  
  
 Si un contrôle serveur <xref:System.Web.UI.Control.Visible%2A> propriété est définie sur `true` le traçage est activé pour la page, puis les informations de trace associées au contrôle sont capturées.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors du remplacement de la <see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" /> méthode dans les contrôles personnalisés, appelez la méthode de classe de base pour garantir des informations de trace sont capturées correctement.</para></block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">Présentation de l’architecture du comportement de contrôle adaptatif</related>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingCompatibility : Version with get, set" Usage="System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie la version ASP.NET avec laquelle le HTML restitué sera compatible.</summary>
        <value>Version ASP.NET avec laquelle le HTML restitué sera compatible.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET affecte à cette propriété la valeur de la `controlRenderingCompatibilityVersion` attribut de la `pages` élément dans le fichier Web.config. Si le `controlRenderingCompatibilityVersion` attribut n’est pas défini dans le fichier Web.config, la valeur par défaut est la version actuelle d’ASP.NET.  
  
> [!CAUTION]
>  Il existe un accesseur set public pour cette propriété, mais l’accesseur set prend en charge l’infrastructure .NET Framework et n’est pas destinée à être utilisée directement depuis votre code. Si vous définissez cette valeur dans votre code, l’effet est imprévisible.  
  
 Chaque version d’ASP.NET peut restituer le HTML différemment des versions antérieures. Par exemple, dans ASP.NET 3.5, si le <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> propriété d’un <xref:System.Web.UI.WebControls.Label> contrôle est `false`, par défaut, ASP.NET restitue un `span` élément dont `disabled` attribut est défini sur « désactivé ». Dans ASP.NET 4, par défaut, le `span` élément est rendu avec une feuille de style en cascade (CSS) `class` au lieu du `disabled` attribut. Cela vous permet de spécifier l’apparence du contrôle désactivée et que vous évite de rendu HTML non valide. (Dans HTML 4.0 et XHTML 1.1, le `span` élément ne prend pas en charge la `disabled` attribut.)  
  
 Une application Web peut inclure du code qui fonctionnerait pas correctement si le rendu HTML change. Pour éviter ce problème, vous pouvez définir le `controlRenderingCompatibilityVersion` attribut de la `pages` élément dans le fichier Web.config pour indiquer la version antérieure dans laquelle vous souhaitez assurer la compatibilité avec. Par exemple, si vous définissez la <xref:System.Web.UI.Control.RenderingCompatibility%2A> propriété `3.5`, désactivé <xref:System.Web.UI.WebControls.Label> contrôle affichera un `disabled` attribut et non une classe CSS.  
  
> [!NOTE]
>  Est la version la plus ancienne que vous pouvez définir cette propriété à `3.5`.  
  
 Pour assurer la compatibilité descendante, lorsque vous utilisez Visual Studio pour mettre à niveau un projet Web vers ASP.NET 4 à partir d’une version antérieure, Visual Studio définit automatiquement le `controlRenderingCompatibilityVersion` attribut dans le fichier Web.config pour `3.5`. Si vous souhaitez un site Web mis à niveau pour le rendu HTML à l’aide de l’algorithme qui a été introduit dans ASP.NET 4, vous pouvez modifier ou supprimer la `controlRenderingCompatibilityVersion` attribut.  
  
 La plupart du temps, le comportement contrôlé par cette propriété est automatique et vous n’êtes pas obligé de vérifier le <xref:System.Web.UI.Control.RenderingCompatibility%2A> propriété dans votre code. Toutefois, si vous programmez un contrôle personnalisé, vous devrez peut-être inclure du code qui modifie le comportement du contrôle en fonction du paramètre de cette propriété. Par exemple, un contrôle personnalisé pour ASP.NET 4 peut être composé de <xref:System.Web.UI.WebControls.Label> contrôles et le contrôle personnalisé peuvent spécifier l’apparence désactivée du contrôle en générant le code JavaScript qui modifie la `aspNetDisabled` classe. Cela fonctionne comme prévu si <xref:System.Web.UI.Control.RenderingCompatibility%2A> est `4.0` ou version ultérieure. Mais pour obtenir le même effet que lorsque <xref:System.Web.UI.Control.RenderingCompatibility%2A> est `3.5`, code de contrôle personnalisé doit définir le contrôle `CssClass` propriété « aspNetDisabled » lors de la <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> propriété est `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberSignature Language="F#" Value="abstract member ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter&#xA;override this.ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter" Usage="control.ResolveAdapter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient l'adaptateur de contrôles responsable du rendu du contrôle spécifié.</summary>
        <returns><see cref="T:System.Web.UI.Adapters.ControlAdapter" /> qui générera le rendu du contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les pages Web ASP.NET peuvent être affichées sur un large éventail de périphériques qui sont capables de demander des pages à partir du Web. Le <xref:System.Web.UI.Control.ResolveAdapter%2A> méthode retourne l’adaptateur de contrôles responsable pour restituer le contrôle sur le navigateur spécifique ou un périphérique qui demande la page ASP.NET.  
  
 Le type d’adaptateur spécifique retourné dépend du type de descendant de la <xref:System.Web.UI.Control> classe qui est rendue.  
  
 Pour plus d’informations à propos des adaptateurs, consultez [Architectural Overview of Adaptive Control Behavior](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="abstract member ResolveClientUrl : string -&gt; string&#xA;override this.ResolveClientUrl : string -&gt; string" Usage="control.ResolveClientUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">URL relative à la page actuelle.</param>
        <summary>Obtient une URL qui peut être utilisée par le navigateur.</summary>
        <returns>URL qualifiée complète à la ressource spécifiée utilisable sur le navigateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utiliser le <xref:System.Web.UI.Control.ResolveClientUrl%2A> méthode pour retourner une chaîne URL pouvant être utilisée par le client pour accéder aux ressources sur le serveur Web, comme les fichiers image, des liens vers des pages supplémentaires et ainsi de suite.  
  
> [!NOTE]
>  L’URL retournée par cette méthode est relatif au dossier contenant le fichier source dans lequel le contrôle est instancié. Les contrôles qui héritent de cette propriété, tel que <xref:System.Web.UI.UserControl> et <xref:System.Web.UI.MasterPage>, renvoie une URL qualifiée complète par rapport au contrôle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeUrl" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="member this.ResolveUrl : string -&gt; string" Usage="control.ResolveUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">URL associée à la propriété <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" />.</param>
        <summary>Convertit une URL en une URL que le client soit en mesure d'utiliser.</summary>
        <returns>URL convertie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `relativeUrl` paramètre contient une URL absolue, l’URL est retourné sans modification. Si le `relativeUrl` paramètre contient une URL relative, que l’URL est modifiée pour une URL relative qui est correcte pour le chemin d’accès de la demande actuelle, afin que le navigateur puisse résoudre l’URL.  
  
 Par exemple, examinez le scénario suivant :  
  
-   Un client a demandé une page ASP.NET qui contient un contrôle utilisateur qui possède une image associée.  
  
-   La page ASP.NET se trouve dans /Store/page1.aspx.  
  
-   Le contrôle utilisateur se trouve dans /Store/UserControls/UC1.ascx.  
  
-   Le fichier image se trouve à /UserControls/Images/Image1.jpg.  
  
 Si le contrôle utilisateur transmet le chemin d’accès relatif à l’image (autrement dit, /Store/UserControls/Images/Image1.jpg) à la <xref:System.Web.UI.Control.ResolveUrl%2A> (méthode), la méthode retourne la valeur/images/image1.jpg.  
  
 Cette méthode utilise le <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriété à résoudre à l’URL absolue. L’URL retournée est destinée au client.  
  
 Pour plus d’informations sur les chemins d’accès de ressource dans un site Web, consultez [chemins de projet Web ASP.NET](https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd).  
  
> [!NOTE]
>  Pour les pages Web mobiles uniquement, si votre application s’appuie sur les sessions sans cookies ou peut recevoir des demandes provenant des navigateurs mobiles qui nécessitent des sessions sans cookies, à l’aide un tilde («\~») dans un chemin d’accès peut entraîner par inadvertance création d’une nouvelle session et perte potentielle de données de session. Pour définir une propriété avec un chemin d’accès tel que «\~/*chemin d’accès «*, résoudre le chemin d’accès en appelant le <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> avec un argument tel que «\~/*chemin d’accès »* avant de l’assigner à la propriété.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Web.UI.WebControls.Image> Web objet de contrôle de serveur et utilise le <xref:System.Web.UI.Control.ResolveUrl%2A> méthode pour définir le chemin d’accès à l’image, qui est stocké par le <xref:System.Web.UI.WebControls.Image.ImageUrl%2A> propriété.  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se produit si le paramètre <paramref name="relativeUrl" /> contient <see langword="null" />.</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
        <related type="Article" href="https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd">Chemins d’accès du Site Web ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveControlState : unit -&gt; obj&#xA;override this.SaveControlState : unit -&gt; obj" Usage="control.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre tous les changements d’état de contrôle serveur qui ont eu lieu depuis que la page a été publiée sur le serveur.</summary>
        <returns>Retourne l’état actuel du contrôle serveur. Si aucun état n’est associé au contrôle, cette méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.UI.Control.SaveControlState%2A> méthode pour enregistrer les informations d’état requises pour l’opération d’un contrôle spécifique. Ces données d’état du contrôle sont stockées séparément à partir des données d’état d’affichage du contrôle.  
  
 Contrôles personnalisés à l’aide de l’état du contrôle doivent appeler la <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> méthode sur le <xref:System.Web.UI.Control.Page%2A> avant d’enregistrer l’état du contrôle.  
  
   
  
## Examples  
 Les éléments suivants exemple de code remplace le <xref:System.Web.UI.Control.SaveControlState%2A> méthode dans un contrôle ASP.NET personnalisé. Lorsque cette méthode est appelée, elle détermine si la propriété interne `currentIndex` est définie sur une valeur par défaut et, dans ce cas, enregistre la valeur à l’état de contrôle.  
  
 Le <xref:System.Web.UI.Control.OnInit%2A> méthode est substituée pour appeler le <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> méthode sur le <xref:System.Web.UI.Control.Page%2A> pour indiquer que le contrôle personnalisé utilise l’état du contrôle.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque l’état du contrôle est enregistré, un objet de chaîne est retourné au client en tant que variable qui est stockée dans le code HTML <see langword="HIDDEN" /> élément. Substituez cette méthode pour extraire les informations d’état à utiliser dans votre contrôle.  
  
État du contrôle est conçu pour les petites quantités de données critiques, comme un index de page ou un mot clé. À l’aide de l’état du contrôle pour les grandes quantités de données peut nuire aux performances de la page. Pour plus d’informations, consultez [ASP.NET State Management Overview](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).</para></block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Vue d’ensemble de gestion de l’état de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveViewState : unit -&gt; obj&#xA;override this.SaveViewState : unit -&gt; obj" Usage="control.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre les changements d’état d’affichage du contrôle serveur qui se sont produits depuis que la page a été republiée sur le serveur.</summary>
        <returns>Retourne l’état d’affichage actuel du contrôle serveur. Si aucun état d’affichage n’est associé au contrôle, cette méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 État d’affichage est l’accumulation des valeurs de propriétés d’un contrôle serveur. Ces valeurs sont automatiquement placés dans le contrôle serveur <xref:System.Web.UI.Control.ViewState%2A> propriété, qui est une instance de la <xref:System.Web.UI.StateBag> classe. Valeur de cette propriété est ensuite conservée dans un objet string après l’enregistrement étape du cycle de vie du contrôle serveur. Pour plus d’informations, consultez [vue d’ensemble du Cycle de vie de Page ASP.NET](https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 Lorsque l’état d’affichage est enregistré, cet objet de chaîne est retourné au client en tant que variable qui est stockée dans le code HTML `HIDDEN` élément. Lorsque vous créez un contrôle serveur personnalisé avec un état d’affichage personnalisé, l’état d’affichage peut être géré explicitement avec le <xref:System.Web.UI.Control.SaveViewState%2A> et <xref:System.Web.UI.Control.LoadViewState%2A> méthodes. Pour plus d’informations, consultez [ASP.NET State Management Overview](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)). Pour plus d’informations sur l’implémentation d’un fournisseur d’état de session personnalisé, consultez [implémentation d’un fournisseur de Store d’état de Session](https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.SaveViewState%2A> méthode dans un contrôle de serveur ASP.NET personnalisé. Lorsque cette méthode est appelée, elle détermine si le contrôle possède des contrôles enfants et si le contenant <xref:System.Web.UI.Page> objet est le résultat d’une publication (postback). Si les deux sont true, elle modifie le <xref:System.Web.UI.WebControls.Label.Text%2A> propriété d’un <xref:System.Web.UI.WebControls.Label> Web de contrôle de serveur pour lire `Custom Control Has Saved State`. Elle enregistre ensuite l’état d’affichage du contrôle en tant que tableau d’objets, nommé `allStates`.  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Vue d’ensemble de gestion de l’état de ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66">Implémentation d’un fournisseur d’état de Session Store</related>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetDesignModeState : System.Collections.IDictionary -&gt; unit&#xA;override this.SetDesignModeState : System.Collections.IDictionary -&gt; unit" Usage="control.SetDesignModeState data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data"><see cref="T:System.Collections.IDictionary" /> contenant les données au moment du design du contrôle.</param>
        <summary>Définit les données au moment du design pour un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.SetDesignModeState%2A> méthode enregistre les données au moment du design pour un contrôle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode pour enregistrer les données au moment du design que requises par votre contrôle.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberSignature Language="F#" Value="member this.SetRenderMethodDelegate : System.Web.UI.RenderMethod -&gt; unit" Usage="control.SetRenderMethodDelegate renderMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">Informations nécessaires à passer au délégué afin qu'il puisse générer le rendu du contrôle serveur.</param>
        <summary>Assigne un délégué de gestionnaires d'événements pour générer le rendu du contrôle serveur et de son contenu dans son contrôle parent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie à titre d’implémentation uniquement ; Vous ne devez jamais l’appeler directement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit les données de trace pour le suivi du rendu des données au moment du design.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj -&gt; unit" Usage="control.SetTraceData (traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">Clé de données de trace.</param>
        <param name="traceDataValue">Valeur de données de trace.</param>
        <summary>Définit les données de trace pour le suivi du rendu des données au moment du design à l'aide de la clé des données de trace et de la valeur des données de trace.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj * obj -&gt; unit" Usage="control.SetTraceData (tracedObject, traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataKey" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="tracedObject">Objet suivi.</param>
        <param name="traceDataKey">Clé de données de trace.</param>
        <param name="traceDataValue">Valeur de données de trace.</param>
        <summary>Définit les données de trace pour le suivi du rendu des données au moment du design, à l'aide de l'objet suivi, de la clé des données de trace et de la valeur des données de trace.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient des informations sur le conteneur qui héberge le contrôle en cours lorsqu'il est rendu sur une aire de conception.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> qui contient des informations sur le conteneur qui héberge le contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un site lie un <xref:System.ComponentModel.Component> de l’objet à un <xref:System.ComponentModel.Container> de l’objet et permet la communication entre les deux. Il fournit également un moyen pour le conteneur gérer ses composants.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le contrôle est un contrôle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’apparence à appliquer au contrôle.</summary>
        <value>Nom de l’apparence à appliquer au contrôle. La valeur par défaut est <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les apparences disponibles pour un contrôle sont contenus dans un ou plusieurs fichiers d’apparence dans un répertoire de thème. Le <xref:System.Web.UI.Control.SkinID%2A> propriété spécifie les apparences à appliquer au contrôle. Une apparence est spécifique à un contrôle particulier ; Vous ne pouvez pas partager les paramètres d’apparence entre les contrôles de types différents.  
  
 Si vous ne définissez pas le <xref:System.Web.UI.Control.SkinID%2A> propriété, un contrôle utilise l’apparence par défaut si elle a été définie. Par exemple, si une apparence sans ID est définie pour un <xref:System.Web.UI.WebControls.Image> contrôler, puis elle s’applique à tous les <xref:System.Web.UI.WebControls.Image> contrôles qui ne référencent pas explicitement une apparence par ID et qui ne sont pas définies pour désactiver les thèmes. Si une apparence avec ID est définie pour un <xref:System.Web.UI.WebControls.Image> contrôler, puis elle s’applique uniquement aux <xref:System.Web.UI.WebControls.Image> contrôles dont <xref:System.Web.UI.Control.SkinID%2A> propriété est définie à cet ID.  
  
 Si les fichiers d’apparence dans un répertoire de thème ne contiennent pas d’apparence avec spécifié <xref:System.Web.UI.Control.SkinID%2A> propriété, un <xref:System.ArgumentException> exception est levée au moment de l’exécution.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La feuille de style a déjà été appliquée.  
  
ou 
L'événement <see langword="Page_PreInit" /> s'est déjà produit.  
  
ou 
Le contrôle a déjà été ajouté à la collection <see langword="Controls" />.</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">Vue d’ensemble des thèmes ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System::Web::UI::IControlBuilderAccessor::ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />.</summary>
        <value><see cref="T:System.Web.UI.ControlBuilder" /> qui a généré le contrôle ; sinon, <see langword="null" /> si aucun générateur n'a été utilisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IControlBuilderAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />.</summary>
        <returns><see cref="T:System.Collections.IDictionary" /> de l'état du contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data"><see cref="T:System.Collections.IDictionary" /> contenant les données au moment du design du contrôle.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="owner">Propriétaire du contrôle.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 Le <xref:System.Web.UI.IControlDesignerAccessor> interface est utilisée par un concepteur de contrôles pour effectuer les actions au moment du design sur le contrôle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="owner" /> a la valeur du contrôle actuel.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System::Web::UI::IControlDesignerAccessor::UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />.</summary>
        <value><see cref="T:System.Collections.IDictionary" /> contenant les informations sur le contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System::Web::UI::IDataBindingsAccessor::DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />.</summary>
        <value>Collection de liaisons de données.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IDataBindingsAccessor::HasDataBindings { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />.</summary>
        <value><see langword="true" /> si le contrôle contient une logique de liaison de données ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System::Web::UI::IExpressionsAccessor::Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />.</summary>
        <value><see cref="T:System.Web.UI.ExpressionBindingCollection" /> contenant des objets <see cref="T:System.Web.UI.ExpressionBinding" /> qui représentent les propriétés et expressions d'un contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IExpressionsAccessor::HasExpressions { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />.</summary>
        <value><see langword="true" /> si le contrôle dispose de propriétés définies par le biais d'expressions ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à ajouter.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Web.UI.Control> est castée en interface <xref:System.Web.UI.IParserAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TemplateControl : System.Web.UI.TemplateControl with get, set" Usage="System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une référence au modèle qui contient ce contrôle.</summary>
        <value>Instance de <see cref="T:System.Web.UI.TemplateControl" /> qui contient ce contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un <xref:System.Web.UI.Control> instance fait partie d’un modèle de contrôle, le <xref:System.Web.UI.Control.TemplateControl%2A> propriété contient une référence au contrôle conteneur. Pour plus d’informations, consultez le <xref:System.Web.UI.TemplateControl?displayProperty=nameWithType> documentation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplateSourceDirectory : string" Usage="System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le répertoire virtuel du <see cref="T:System.Web.UI.Page" /> ou du <see cref="T:System.Web.UI.UserControl" /> qui contient le contrôle serveur en cours.</summary>
        <value>Répertoire virtuel de la page ou du contrôle utilisateur qui contient le contrôle serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriété spécifie le chemin d’accès au contrôle utilisateur ou de la page qui contient le contrôle actuel. Par exemple, si la page Web réside à http://www.contoso.com/application/subdirectory, le <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriété retourne « application/sous-répertoire ».  
  
 Pour retourner le chemin d’accès virtuel relatif à l’application (« ~ / sous-répertoire »), utilisez le <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriété à deux reprises. La première fois, il est utilisé dans un <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType> appel de méthode pour obtenir le chemin d’accès au répertoire dans lequel réside le contrôle. La deuxième fois, il se trouve dans un <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> appel de méthode pour obtenir la liste de tous les fichiers contenus dans ce répertoire.  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberSignature Language="F#" Value="abstract member TrackViewState : unit -&gt; unit&#xA;override this.TrackViewState : unit -&gt; unit" Usage="control.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoque le suivi des modifications de l'état d'affichage pour le contrôle serveur afin qu'elles puissent être stockées dans l'objet <see cref="T:System.Web.UI.StateBag" /> du contrôle serveur. Cet objet est accessible via la propriété <see cref="P:System.Web.UI.Control.ViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée automatiquement à la fin de la <xref:System.Web.UI.Control.Init> événements de cycle de vie du contrôle serveur.  
  
 Appelez cette méthode lorsque vous développez des contrôles liés aux données. Cette méthode avertit ASP.NET pour surveiller les modifications à l’état d’affichage d’un contrôle serveur, qui est requis lorsque vous substituez le <xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant remplace le <xref:System.Web.UI.Control.DataBind%2A> méthode dans un contrôle de serveur ASP.NET personnalisé. Il commence par appeler la base de <xref:System.Web.UI.Control.OnDataBinding%2A> (méthode), puis utilise le <xref:System.Web.UI.ControlCollection.Clear%2A> méthode pour supprimer tous les contrôles enfants et la <xref:System.Web.UI.Control.ClearChildViewState%2A> méthode pour supprimer tout état d’affichage paramètres enregistrés pour ces contrôles enfants. Enfin, le <xref:System.Web.UI.Control.ChildControlsCreated%2A> propriété est définie sur `true`. Le contrôle utilise ensuite le <xref:System.Web.UI.Control.IsTrackingViewState%2A> propriété afin de déterminer si l’état d’affichage de suivi est activé pour le contrôle. S’il n’est pas activé, le <xref:System.Web.UI.Control.TrackViewState%2A> méthode est appelée.  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueID : string" Usage="System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur unique qualifié sur le plan hiérarchique du contrôle serveur.</summary>
        <value>Identificateur complet du contrôle serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est différente de la <xref:System.Web.UI.Control.ID%2A> propriété, qui le <xref:System.Web.UI.Control.UniqueID%2A> propriété inclut l’identificateur pour le contrôle serveur d’attribution de noms conteneur. Cet identificateur est généré automatiquement lors du traitée d’une demande de page.  
  
 Cette propriété est particulièrement importante dans la différenciation des contrôles serveur contenus dans un contrôle de serveur de liaison de données qui se répète. Le contrôle répété, qui sont <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList>, <xref:System.Web.UI.WebControls.DetailsView>, <xref:System.Web.UI.WebControls.FormView>, et <xref:System.Web.UI.WebControls.GridView> contrôles serveur Web (ou tout contrôle serveur personnalisé que vous créez qui incluent des fonctionnalités de répétition lorsque lié aux données), sert de la conteneur de dénomination pour son enfant contrôles. Cela signifie qu’il crée un espace de noms unique pour ses enfants contrôles afin que leurs <xref:System.Web.UI.Control.ID%2A> valeurs de propriété ne pas en conflit.  
  
 Par exemple, si vous incluez un ASP.NET <xref:System.Web.UI.WebControls.Label> Web de contrôle de serveur dans un <xref:System.Web.UI.WebControls.Repeater> contrôle serveur et attribuez le <xref:System.Web.UI.WebControls.Label> contrôle un <xref:System.Web.UI.Control.ID%2A> valeur de propriété de `MyLabel`et le <xref:System.Web.UI.WebControls.Repeater> un <xref:System.Web.UI.Control.ID%2A> de `MyRepeater`. Si vous liez des données à la <xref:System.Web.UI.WebControls.Repeater> à un <xref:System.Collections.ArrayList> objet avec trois entrées, résultant <xref:System.Web.UI.Control.UniqueID%2A> propriétés pour chaque instance de la <xref:System.Web.UI.WebControls.Label> sont des contrôles serveur `MyRepeater$ctl00$MyLabel`, `MyRepeater$ctl01$MyLabel`, et `MyRepeater$ctl02$MyLabel`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Collections.ArrayList> de l’objet et le remplit avec trois chaînes de texte, puis lie un <xref:System.Web.UI.WebControls.Repeater> Web de contrôle de serveur pour les données dans le <xref:System.Collections.ArrayList> lorsque la page est chargée. Le code obtient le <xref:System.Web.UI.Control.UniqueID%2A> propriété pour chaque contrôle enfant généré lors de la liaison de données. Le code génère trois versions de la <xref:System.Web.UI.WebControls.Label> contrôle et écrit leurs `UniqueID` les valeurs de propriété à la page.  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : EventHandler " Usage="member this.Unload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contrôle serveur est déchargé de la mémoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les contrôles serveur doivent effectuer tout nettoyage final, telles que la fermeture de fichiers, les connexions de base de données et la suppression d’objets, pendant cette phase du cycle de vie de contrôle avant que l’instance soit déchargé.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introduction au Cycle de vie de Page ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le contrôle vérifie l'entrée cliente du navigateur à la recherche de valeurs potentiellement dangereuses.</summary>
        <value>Valeur qui détermine si le contrôle vérifie l'entrée d'un client. Les valeurs peuvent inclure <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />, <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />, et <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />. La valeur par défaut est <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />, ce qui signifie que le contrôle obtient la valeur de son parent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la validation de la demande, consultez <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewState : System.Web.UI.StateBag" Usage="System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un dictionnaire d'informations d'état qui vous permet d'enregistrer et de restaurer l'état d'affichage d'un contrôle serveur entre plusieurs demandes de la même page.</summary>
        <value>Instance de la classe <see cref="T:System.Web.UI.StateBag" /> qui contient les informations d'état d'affichage du contrôle serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 État d’affichage d’un contrôle serveur est l’accumulation de toutes ses valeurs de propriété. Afin de conserver ces valeurs entre les requêtes HTTP, les contrôles serveur ASP.NET utilisent cette propriété, qui est une instance de la <xref:System.Web.UI.StateBag> (classe), pour stocker les valeurs de propriété. Les valeurs sont ensuite passées en tant que variable à un élément input masqué HTML lors du traitement des demandes suivantes. Pour plus d’informations sur l’enregistrement d’état d’affichage de contrôle de serveur, consultez [ASP.NET State Management Overview](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).  
  
 État d’affichage est activé pour tous les contrôles de serveur par défaut, mais il existe certains cas dans lequel vous souhaitez désactiver. Pour plus d’informations, consultez [vue d’ensemble des performances ASP.NET](https://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b).  
  
 Pour plus d’informations sur les dictionnaires et leur utilisation, consultez [Collections et Structures de données](~/docs/standard/collections/index.md).  
  
   
  
## Examples  
 L’exemple suivant illustre l’implémentation d’un `Text` propriété qui stocke et récupère sa valeur à partir de son contrôle <xref:System.Web.UI.Control.ViewState%2A> propriété.  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Vue d’ensemble de gestion de l’état de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateIgnoresCase : bool" Usage="System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'objet <see cref="T:System.Web.UI.StateBag" /> respecte la casse.</summary>
        <value><see langword="true" /> si l'instance de <see cref="T:System.Web.UI.StateBag" /> ne respecte pas la casse ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode si vous créez un contrôle serveur personnalisé qui enregistre son état d’affichage sans tenir compte de la casse. Lorsque vous procédez ainsi, plusieurs objets avec la même clé, mais avec une casse différente, peuvent être stockées dans le <xref:System.Web.UI.StateBag> associé à la <xref:System.Web.UI.Control.ViewState%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer la <xref:System.Web.UI.Control.ViewStateIgnoresCase%2A> propriété à retourner `true`.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateMode : System.Web.UI.ViewStateMode with get, set" Usage="System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode d'état d'affichage de ce contrôle.</summary>
        <value>Mode d'état d'affichage de ce contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Web.UI.Control.ViewStateMode%2A> propriété pour activer l’état d’affichage d’un contrôle même si l’état d’affichage est désactivé pour la page. Pour plus d’informations sur l’état d’affichage et l’état du contrôle, consultez le <xref:System.Web.UI.Control.EnableViewState%2A> propriété.  
  
 Pour désactiver l’état d’affichage pour une page et de l’activer pour un contrôle spécifique sur la page, définissez la <xref:System.Web.UI.Control.EnableViewState%2A> propriété de la page et le contrôle à `true`, définissez le <xref:System.Web.UI.Control.ViewStateMode%2A> propriété de la page pour <xref:System.Web.UI.ViewStateMode.Disabled>et définissez le <xref:System.Web.UI.Control.ViewStateMode%2A> propriété de la le contrôle à <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 La valeur par défaut de la <xref:System.Web.UI.Control.ViewStateMode%2A> propriété pour une page est <xref:System.Web.UI.ViewStateMode.Enabled>. La valeur par défaut de la <xref:System.Web.UI.Control.ViewStateMode%2A> propriété pour un contrôle de serveur Web dans une page est <xref:System.Web.UI.ViewStateMode.Inherit>. Par conséquent, si vous ne définissez pas cette propriété à la page ou le niveau de contrôle, la valeur de la <xref:System.Web.UI.Control.EnableViewState%2A> propriété détermine le comportement de l’état d’affichage.  
  
 Le <xref:System.Web.UI.Control.ViewStateMode%2A> propriété d’une page ou un contrôle a un effet uniquement si la <xref:System.Web.UI.Control.EnableViewState%2A> propriété est définie sur `true`. Si le <xref:System.Web.UI.Control.EnableViewState%2A> propriété est définie sur `false`, pas même si à l’état d’affichage sera désactivé le <xref:System.Web.UI.Control.ViewStateMode%2A> propriété est définie sur <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une tentative a été effectuée pour affecter à cette propriété une valeur qui n'est pas dans l'énumération <see cref="T:System.Web.UI.ViewStateMode" />.</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100)">Vue d’ensemble de gestion de l’état de ASP.NET</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb386448(v%3dvs.100)">Vue d’ensemble de l’état d’affichage ASP.NET</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cteh3e77(v=vs.100)">Contrôle de l’état d’affichage</related>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si un contrôle serveur est rendu en tant qu’interface utilisateur sur la page.</summary>
        <value><see langword="true" /> si le contrôle est visible sur la page ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété est `false`, le contrôle de serveur n’est pas restitué. Prenez ce point en considération lors de l’organisation de la disposition de votre page.  
  
> [!NOTE]
>  Si un contrôle conteneur n’est pas rendu, tous les contrôles qu’il contient ne seront pas restitués même si vous définissez la <xref:System.Web.UI.Control.Visible%2A> propriété d’un contrôle individuel pour `true`. Dans ce cas, le contrôle retourne `false` pour le <xref:System.Web.UI.Control.Visible%2A> même si vous avez explicitement affectez-lui la valeur de la propriété `true`. (Autrement dit, si le `Visible` propriété du contrôle parent est définie sur `false`, le contrôle enfant hérite de ce paramètre et le paramètre est prioritaire sur tous les paramètres locaux.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>